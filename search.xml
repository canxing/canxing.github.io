<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx 自定义模块]]></title>
    <url>%2F2018%2F08%2F23%2Fngxin-customize-module%2F</url>
    <content type="text"><![CDATA[Nginx 有核心模块和第三方模块，我们也可以自定义模块来使用。Nginx 就像一个小型的编程语言，要添加自定义模块就要满足一些 Nginx 的编写要求，就像 C 语言必须有一个 main 函数一样。 这里大部分的内容來自于《Nginx 开发从入门到精通》，只不过整理了一下以满足我自己的思考方式，更详细的内容可以访问 《Nginx 开发从入门到精通》。ngx_http_hello_module.c 为主要模块，config 是添加自定义模块到 Nginx 时使用的。 模块所有代码在这里 配置指令Nginx 都是以指令的形式进行配置的，所以我们的自定义模块也需要自定义指令来实现功能。自定义指令需要借助于 ngx_command_t 结构体。ngx_command_t 结构体定义在 src/core/ngx_conf_file.h 文件中。 12345678struct ngx_command_s &#123; ngx_str_t name; ngx_uint_t type; char *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); ngx_uint_t conf; ngx_uint_t offset; void *post;&#125;; 在 src/core/ngx_core.h 文件中将使用 ngx_command_t 来表示 struct ngx_command_s。 1typedef struct ngx_command_s ngx_command_t; 这是关于自定义指令的描述。 12345678910111213141516171819static ngx_command_t ngx_http_hello_commands[] = &#123; &#123; ngx_string("hello_string"), NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1, ngx_http_hello_string, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_hello_loc_conf_t, hello_string), NULL &#125;, &#123; ngx_string("hello_counter"), NGX_HTTP_LOC_CONF|NGX_CONF_FLAG, ngx_http_hello_counter, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_hello_loc_conf_t, hello_counter), NULL &#125;, ngx_null_command&#125;; name 表示指令的名称，定义好后在 Nginx 配置文件中就可以直接使用该名称作为指令，比如在配置文件中可以使用 hello_string 来配置。 type 为指令接受参数的条件。条件由两部分构成：位置和参数个数。 位置由以下参数表示 名称 描述 NGX_DIRECT_CONF 可以出现在配置文件中最外层。例如已经提供的配置指令 daemon, master_process 等。 NGX_MAIN_CONF http, mail, events, error_log 等。 NGX_ANY_CONF 该配置指令可以出现在任意配置级别上。 NGX_HTTP_MAIN_CONF 可以直接出现在 http 配置指令里。 NGX_HTTP_SRV_CONF 可以出现在 http 里面的 server 配置指令里。 NGX_HTTP_LOC_CONF 可以出现在 http server 块里面的 location 配置指令里。 NGX_HTTP_UPS_CONF 可以出现在 http 里面的 upstream 配置指令里。 NGX_HTTP_SIF_CONF 可以出现在 http 里面的 server 配置指令里的 if 语句所在的 block 中。 NGX_HTTP_LMT_CONF 可以出现在 http 里面的 limit_except 指令的 block 中。 NGX_HTTP_LIF_CONF 可以出现在 http server 块里面的 location 配置指令里的 if 语句所在 block 中。 参数个数由以下参数表示 名称 描述 NGX_CONF_NOARGS 配置指令不接受任何参数。 NGX_CONF_TAKE1 配置指令接受 1 个参数。 NGX_CONF_TAKE2 配置指令接受 2 个参数。 NGX_CONF_TAKE3 配置指令接受 3 个参数。 NGX_CONF_TAKE4 配置指令接受 4 个参数。 NGX_CONF_TAKE5 配置指令接受 5 个参数。 NGX_CONF_TAKE6 配置指令接受 6 个参数。 NGX_CONF_TAKE7 配置指令接受 7 个参数。 NGX_CONF_MULTI 配置指令接受多个参数，即个数不定。 NGX_CONF_BLOCK 配置指令可以接受的值是一个配置信息。也就是一对大括号扩起来的内容。里面可以再包括很多个配置指令。比如常见的 server 指令就是这个属性。 NGX_CONF_FLAG 配置指令可以接受的值是 on 或者 off，最终会被转成 bool 值。 NGX_CONF_ANY 配置指令可以接受的任意的参数值 上面这些参数可以使用 | 进行组合，比如上面配置中 NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1 就表示定义在 http server 块中的 location 配置指令中，接受 0 个或者 1 个参数。 set 是一个函数指针，为该指令的处理函数，因为指令如何处理只有定义这个指令的人最清楚。 函数处理成功时返回 NGX_OK，否则返回 NGX_CONF_ERROR 或者一个自定义的错误信息的字符串。 函数调用时会传入三个参数： cf: 该参数里面保存从配置文件读取到的原始字符串以及相关的一些信息。特别注意的是这个参数的 args 字段是一个 ngx_str_t 类型的数组，该数组的首个元素是这个配置指令本身，第二个元素是指令的第一个参数，第三个元素是第二个参数，依次类推。 cmd: 这个配置指令对应的 ngx_command_t 结构。 conf: 就是定义的存储这个配置值的结构体。 为了方便对配置指令参数的读取，Nginx 默认提供了一些对标准类型的参数进行读取的函数，可以直接复制给 set 字段使用。 函数名称 作用 ngx_conf_set_flag_slot 读取 NGX_CONF_FLAG 类型的参数。 ngx_conf_set_str_slot 读取字符串类型的参数。 ngx_conf_set_str_array_slot 读取字符串数组类型的参数。 ngx_conf_set_keyval_slot 读取键值对类型的参数。 ngx_conf_set_num_slot 读取整数类型（有符号）的参数 ngx_conf_set_size_slot 读取 size_t 类型的参数，也就是无符号数。 ngx_conf_set_off_slot 读取 off_t 类型的参数。 ngx_conf_set_msec_slot 读取毫秒值类型的参数。 ngx_conf_set_sec_slot 读取秒值类型的参数。 ngx_conf_set_bufs_slot 读取的参数值是 2 个，一个是 buf 的个数，一个是 buf 的大小。 ngx_conf_set_enum_slot 读取枚举类型的参数，将其转换成 ngx_uint_t 类型。 ngx_conf_set_bitmask_slot 读取参数的值，并将这些参数以 bit 位的形式存储。 下面是对 hello_string 进行处理的代码。 123456789static char *ngx_http_hello_counter(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_hello_loc_conf_t* local_conf; local_conf = conf; char* rv = NULL; rv = ngx_conf_set_flag_slot(cf, cmd, conf); ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "hello_counter:%d", local_conf-&gt;hello_counter); return rv;&#125; 该函数返回的是指令接收的参数，使用 ntx_http_hello_loc_conf_t 只是为了打印一下输出。 ngx_http_hello_loc_conf_t 的定义如下。在传入 set 函数指针时，conf 指向的就是这个结构体。 1234typedef struct &#123; ngx_str_t hello_string; ngx_int_t hello_counter;&#125;ngx_http_hello_loc_conf_t; conf 该字段被NGX_HTTP_MODULE类型模块所用 (我们编写的基本上都是NGX_HTTP_MOUDLE，只有一些nginx核心模块是非NGX_HTTP_MODULE)，该字段指定当前配置项存储的内存位置。实际上是使用哪个内存池的问题。因为http模块对所有http模块所要保存的配置信息，划分了main, server和location三个地方进行存储，每个地方都有一个内存池用来分配存储这些信息的内存。这里可能的值为 NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET或NGX_HTTP_LOC_CONF_OFFSET。当然也可以直接置为0，就是NGX_HTTP_MAIN_CONF_OFFSET。 offset: 指定该配置项值的精确存放位置，一般指定为某一个结构体变量的字段偏移。因为对于配置信息的存储，一般我们都是定义个结构体来存储的。那么比如我们定义了一个结构体A，该项配置的值需要存储到该结构体的b字段。那么在这里就可以填写为offsetof(A, b)。 该字段存储一个指针。可以指向任何一个在读取配置过程中需要的数据，以便于进行配置读取的处理。大多数时候，都不需要，所以简单地设为0即可。 需要注意的是，就是在ngx_http_hello_commands这个数组定义的最后，都要加一个ngx_null_command作为结尾。 模块上下文模块上下文和 ngx_http_module_t 有关，这个结构体的定义在 src/http/ngx_http_config.h 文件。 12345678910111213typedef struct &#123; ngx_int_t (*preconfiguration)(ngx_conf_t *cf); ngx_int_t (*postconfiguration)(ngx_conf_t *cf); void *(*create_main_conf)(ngx_conf_t *cf); char *(*init_main_conf)(ngx_conf_t *cf, void *conf); void *(*create_srv_conf)(ngx_conf_t *cf); char *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf); void *(*create_loc_conf)(ngx_conf_t *cf); char *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);&#125; ngx_http_module_t; 这个变量实际上是提供一组回调函数指针，这些函数有在创建存储配置信息的对象的函数，也有在创建前和创建后会调用的函数。这些函数都将被nginx在合适的时间进行调用。 参数名称 作用 preconfiguration 在创建和读取该模块的配置信息之前被调用。 postconfiguration 在创建和读取该模块的配置信息之后被调用。 create_main_conf 调用该函数创建本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。 init_main_conf 调用该函数初始化本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串 create_srv_conf 调用该函数创建本模块位于 http server block 的配置信息存储结构，每个 server block 会创建一个。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。 merge_srv_conf 因为有些配置指令既可以出现在 http block，也可以出现在 http server block 中。那么遇到这种情况，每个 server都会有自己存储结构来存储该 server 的配置，但是在这种情况下 http block 中的配置与 server block 中的配置信息发生冲突的时候，就需要调用此函数进行合并，该函数并非必须提供，当预计到绝对不会发生需要合并的情况的时候，就无需提供。当然为了安全起见还是建议提供。该函数执行成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。 create_loc_conf 调用该函数创建本模块位于 location block 的配置信息存储结构。每个在配置中指明的 location 创建一个。该函数执行成功，返回创建的配置对象。失败的话，返回 NULL。 merge_loc_conf 与 merge_srv_conf 类似，这个也是进行配置值合并的地方。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。 Nginx 里面的配置信息都是上下一层层的嵌套的，对于具体某个 location 的话，对于同一个配置，如果当前层次没有定义，那么就使用上层的配置，否则使用当前层次的配置。 下面为该自定义模块的上下文定义 12345678910111213static ngx_http_module_t ngx_http_hello_module_ctx = &#123; NULL, ngx_http_hello_init, NULL, NULL, NULL, NULL, ngx_http_hello_create_loc_conf, NULL,&#125;; 上述配置说明了在创建和读取该模块的配置信息之后调用初始化函数，并且在 location 块中配配置信息存储结构。 ngx_http_hello_init 函数定义如下: 123456789101112131415static ngx_int_tngx_http_hello_init(ngx_conf_t *cf) &#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_hello_handler; return NGX_OK;&#125; ngx_http_hello_handler 函数定义如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static ngx_int_tngx_http_hello_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_buf_t *b; ngx_chain_t out; ngx_http_hello_loc_conf_t* my_conf; u_char ngx_hello_string[1024] = &#123;0&#125;; ngx_uint_t content_length = 0; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "ngx_http_hello_handler is called!"); my_conf = ngx_http_get_module_loc_conf(r, ngx_http_hello_module); if (my_conf-&gt;hello_string.len == 0) &#123; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "hello string is empty!"); return NGX_DECLINED; &#125; if (my_conf-&gt;hello_counter == NGX_CONF_UNSET || my_conf-&gt;hello_counter == 0) &#123; ngx_sprintf(ngx_hello_string, "%s", my_conf-&gt;hello_string.data); &#125; else &#123; ngx_sprintf(ngx_hello_string, "%s Visited Times:%d", my_conf-&gt;hello_string.data, ++ngx_hello_visited_times); &#125; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "hello_string:%s", ngx_hello_string); content_length = ngx_strlen(ngx_hello_string); if (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) &#123; return NGX_HTTP_NOT_ALLOWED; &#125; rc = ngx_http_discard_request_body(r); if (rc != NGX_OK) &#123; return rc; &#125; ngx_str_set(&amp;r-&gt;headers_out.content_type, "text/html"); if (r-&gt;method == NGX_HTTP_HEAD) &#123; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = content_length; return ngx_http_send_header(r); &#125; b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t)); if (b == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; out.buf = b; out.next = NULL; b-&gt;pos = ngx_hello_string; b-&gt;last = ngx_hello_string + content_length; b-&gt;memory = 1; b-&gt;last_buf = 1; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = content_length; rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) &#123; return rc; &#125; return ngx_http_output_filter(r, &amp;out);&#125; 模块的定义上面分别说了指令的配置以及模块的上下文定义，关于模块本身的定义说的不多。 对于开发一个模块来说，我们都需要定义一个 ngx_module_t 类型的变量来说明这个模块本身的信息，从某种意义上来说，这是这个模块最重要的一个信息，它告诉了 Nginx 这个模块的一些信息，上面定义的配置信息，还有模块上下文信息，都是通过这个结构来告诉 Nginx 系统的，也就是加载模块的上层代码，都需要通过定义的这个结构，来获取这些信息。 ngx_module_t 的定义在 src/core/ngx_module.h 文件 1234567891011121314151617181920212223242526272829303132333435363738394041struct ngx_module_s &#123; ngx_uint_t ctx_index; ngx_uint_t index; char *name; ngx_uint_t spare0; ngx_uint_t spare1; ngx_uint_t version; const char *signature; void *ctx; ngx_command_t *commands; ngx_uint_t type; ngx_int_t (*init_master)(ngx_log_t *log); ngx_int_t (*init_module)(ngx_cycle_t *cycle); ngx_int_t (*init_process)(ngx_cycle_t *cycle); ngx_int_t (*init_thread)(ngx_cycle_t *cycle); void (*exit_thread)(ngx_cycle_t *cycle); void (*exit_process)(ngx_cycle_t *cycle); void (*exit_master)(ngx_cycle_t *cycle); uintptr_t spare_hook0; uintptr_t spare_hook1; uintptr_t spare_hook2; uintptr_t spare_hook3; uintptr_t spare_hook4; uintptr_t spare_hook5; uintptr_t spare_hook6; uintptr_t spare_hook7;&#125;;#define NGX_MODULE_V1 \ NGX_MODULE_UNSET_INDEX, NGX_MODULE_UNSET_INDEX, \ NULL, 0, 0, nginx_version, NGX_MODULE_SIGNATURE#define NGX_MODULE_V1_PADDING 0, 0, 0, 0, 0, 0, 0, 0 在 src/core/ngx_core.h 中有如下定义: 1typedef struct ngx_module_s ngx_module_t; Nginx 为了简化配置，将前面 7 个配置使用 NGX_MODULE_V1 宏来表示，后 8 个配置使用 NGX_MODULE_V1_PADDING 宏来表示。因此只需要配置 10 个参数就行了。 1234567891011121314ngx_module_t ngx_http_hello_module = &#123; NGX_MODULE_V1, &amp;ngx_http_hello_module_ctx, //该模块的上下文 ngx_http_hello_commands, //该模块的指令集合 NGX_HTTP_MODULE, //该模块的种类 NULL, //在 master 初始化的函数 NULL, //模块初始化函数 NULL, //初始化工作进程 NULL, //初始化线程 NULL, //离开线程 NULL, //离开工作进程 NULL, //离开 master NGX_MODULE_V1_PADDING&#125;; 模块挂载定义好一个模块之后还需要把模块挂载到相应的请求处理阶段上，Nginx 有 11 个请求处理阶段，其中有 4 个阶段不能配置，剩下 7 个可以进行挂载。在 ngx_http_hello_module_ctx 中传入的指针函数 ngx_http_hello_init 就是用来挂载到相应模块上的。 123456789101112131415static ngx_int_tngx_http_hello_init(ngx_conf_t *cf) &#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_hello_handler; return NGX_OK;&#125; 其中 ngx_http_conf_get_module_main_conf 根据 conf 结构和模块得到主配置，然后使用 ngx_array_push 在 NGX_HTTP_CONTENT_PHASE 阶段进行挂载。 总结一个模块可以有多个指令，Nginx 使用 ngx_command_t 来描述一个指令，比如指令名称，指令所在位置，指令参数，指令处理函数，指令存储空间以及指令参数在哪个结构体的哪个属性等。 为了将指令的参数在回调函数中可以被明白的解析，需要定义一个结构体来存储传入的参数，这里使用的结构体是 ngx_http_hello_loc_conf_t，其中 hello_string 指令的参数通过 offsetof(ngx_http_hello_loc_conf_t, hello_string) 传入 ngx_http_hello_loc_conf_t 的 hello_string 属性。封装好后 Nginx 会将 ngx_http_hello_loc_conf_t 传入处理回调函数，因为 C 语言的原因，所以传入的指针为 void* 类型的指针，在处理函数中需要进行转换。hello_string 指令的处理函数为 ngx_http_hello_string，hello_counter 指令的处理函数为 ngx_http_hello_counter。 指令在不同阶段可能进行各种初始化工作，Nginx 定义了 ngx_http_module_t 结构体来描述一个指令的上下文环境。可以根据情况来进行上下文的初始化。 最后需要使用 ngx_module_t 结构体来描述该模块本身的信息，模块本身的信息需要传入模块上下文，模块的指令，模块的类型，以及各种钩子函数等。值得注意的是，Nginx 提供了两个宏来减少配置操作，分别时 NGX_MODULE_V1 和 NGX_MODULE_V1_PADDING。 hello 模块在模块上下文定义中，在配置读取和创建结束之后传入了 ngx_http_hello_init 函数，该函数会将模块挂载到 NGX_HTTP_CONTENT_PHASE，并且将 ngx_hettp_hello_handler 函数作为主要的处理函数。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM 配置]]></title>
    <url>%2F2018%2F08%2F12%2FVIM-config%2F</url>
    <content type="text"><![CDATA[VIM 配置 这个配置比较简单，只有有限的几个插件，涉及少数几个 VIM 命令，不同于其他 VIM 成熟的配置，如果你需要的是一个成熟的 VIM 配置，那么你应该去别的地方找找，如果你只需要一份简单的配置以便与后续的自定义，这个说不定就是你想要的。 VIM 显示界面 上述 VIM 样式是终端 VIM，对于 GUI VIM 也有一定的效果，但是不一定完全一样。 VIM 配置包括两部分，一部分是 VIM 插件，一部分 VIM 配置文件。 VIM 插件集中在 bundle 目录下，bundle 应该放在 ~/.vim/ 目录下，对于 windows 用户需要自行搜索插件存放目录。 VIM 配置文件 .vimrc 应该放在用户的根目录下，用于启动 VIM 时加载。 VIM 配置使用了以下几个插件 Vundle 用于管理其他插件的插件 nerdtree 用于在 VIM 中显示目录树的插件 gruvbox VIM 的主题插件 tabular 和 vim-markdown 是让 VIM 可以支持 Markdonw 的插件 插件和配置文件可以在这里找到]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb-学习记录]]></title>
    <url>%2F2018%2F07%2F24%2Fmongodb-note%2F</url>
    <content type="text"><![CDATA[MongoDB 学习记录 什么是 MongoDB MongoDB 的组织形式 MongoDB 有几种数据结构 如何创建数据库 那么怎么样才可以创建集合 如何删除集合和数据库 如何查看帮助文档 如何插入文档 插入一条数据 插入多条数据 如何查询插入的数据 查询全部数据 如何仅查询需要的字段 如何根据条件进行查询 如何查询 stars 大于 50 的数据 如何多条件查询 如何查询满足其中一个条件的数据 如何按照 stars 从大到小，从小到大排序 如何实现分页 如何实现分组 如何删除数据 如何删除一条数据 如何删除多条数据 如何更新数据 如何更新一条数据 如何更新多条数据 如何更新数据中的文档数据 如何删除文档类型数据中的域 如何在文档类型数据中插入新的数据 如何更新数组中的数据 如何往数组中插入新的数据 如何删除数组中的数据 如何向数组中插入另一个数组的内容 如何向数组中插入不重复数据 如何删除数组中的多个元素 如何创建索引 创建升序索引 创建降序索引 如何查看创建索引 如何删除创建的索引 什么是MongoDBMongoDB 是一个 NoSQL 数据库，和 MySQL 等关系型数据库不一样 MongoDB 更简单易用。MongoDB 是 NoSQL 的一种。 MongoDB的组织形式MongoDB 中可以有多个数据库，每个数据库中可以有多个集合，每个集合有多个文档（文档就相当于 MySQL 中的表，但是表中的数据都有相同的域，文档中的每一条数据不一定有相同的域），每个文档都有域，这些域可能存在也可能不存在，在实际使用中每个文档应该有相同的域。 MongoDB 的组织形式图解: MongoDB 和 MySQL 的对对比： MongoDB有几种数据结构MongoDB 中以下几种数据结构： 数字 字符串 布尔 日期 数组 文档（JavaScript 中的对象） 如何创建数据库MongoDB 中的数据库不用手动创建，只需要使用 use &lt;collection&gt; 就可以选择数据库，如何没有这个数据库，在创建一个集合的同时也会创建数据库 那么怎么样才可以创建集合使用以下命令就可以创建一个集合 1db.createCollection("collectionName") 如何删除集合和数据库使用以下命令可以删除一个集合，其中 &lt;collection&gt; 表示选中的集合 1db.&lt;collection&gt;.drop() 删除数据库可以使用以下命令删除，注意，这个 db 是由 use &lt;database&gt; 选中的数据库 1db.dropDatabase() 如何查看帮助文档在 Mongo shell 中直接使用 help 命令可以查看在线帮助文档 使用 db.help() 可以查看数据库相关的帮助文档 使用 db.&lt;collectionname&gt;.help() 可以查看数据库集合的相关帮助文档 如何插入文档查看 db.&lt;collectionname&gt;.help() 可以看见 MongoDB 定义了三种方式来插入文档，有 insert,insertOne,insertMany，其中 insert 用处最多，具备有 insertOne 和 insertMany 的功能。 insertOne 用于向数据库中插入单条数据的情况，insertMany 用于一条命令向数据库中插入多条数据。 插入一条数据12345678db.blog.insert(&#123; title: 'mongodb 的使用', author: 'canxing', publishDate: new Date(2018,7,16,17,31), content : 'mongodb 插入语句的实现', stars : 10, comment : []&#125;) 插入多条数据123456789101112131415161718db.blog.insert([&#123; title: 'mongodb 插入多条数据的使用', author: 'canxing', publishDate : new Date(2018,7,16,17,33), content : "mongodb 插入多条数据的实现", stars: 12, comment : []&#125;,&#123; title: 'mongodb 插入多条数据的使用2', author:'canxing', publishDate: new Date(2018, 7, 16, 17, 34), content: "mongodb 插入多条数据的实现2", stars: 2, comment : []&#125;]) 如何查询插入的数据首先保证数据库中已经插入了下面这些数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647db.blog.insert([ &#123; title: 'mongodb 数据库的创建', author: &#123; firstName: 'liu', lastName: 'xin' &#125;, publishDate: new Date(2018, 7, 20, 9, 12), content: 'mongodb 数据库的创建', stars: 30, comment:[ 'aaaa', 'bbbb', 'cccc' ] &#125;, &#123; title: "走两步", author: &#123; firstName: "tom", lastName: "jerry" &#125;, publishDate: new Date(2018, 7, 21, 8, 23), content: "随便走两步", stars: 32, comment: [ 'dddd', 'eeee', 'ffff' ] &#125;, &#123; title: "葫芦娃救爷爷", author: &#123; firstName: "忘了", lastName: "忘了" &#125;, publishDate: new Date(2018, 7, 22, 10, 23), content: "7个葫芦娃轮流救爷爷，结果都被抓了", stars: 11000, comment: [ 'gggggggggg', 'hhhhhhhhhhh', 'iiiiiiiiiii' ] &#125;]) 查询全部数据 要想查询的结果可读性更强，可以试试 pretty 方法 db.blog.find().pretty() 1db.blog.find() 如何仅查询需要的字段1db.blog.find(&#123;&#125;, &#123;title:1, author:1, publishDate:1, _id:1&#125;) 查询的第一个参数是筛选条件，{} 表示不过滤直接查询，也就是查询所有的数据，第二个参数设置需要显示的域，要显示的设置为 1, 不显示的设置为 0, _id 域默认显示，不想显示需要手动指定。 如何根据条件进行查询123db.blog.find(&#123;title: "mongodb 数据库的创建"&#125;) //根据博客名称进行查询db.blog.find(&#123;author: &#123;firstName: "liu", lastName: "xin"&#125;&#125;) //根据作者进行查询db.blog.find(&#123;comment: 'dddd'&#125;) //根据评论进行查询 上面展示了三种根据条件进行查询的方式，这种方式类似于 MySQL 中的 where 字句但是也有不同。 第一条查询语句使用 {title: &quot;mongodb 数据库的创建&quot;} 来筛选，返回所有数据中满足 title 域对应的值等于 mongodb 数据库的创建 的语句。 第二条查询语句使用 {author: {firstName: &quot;liu&quot;, lastName: &quot;xin&quot;}} 来筛选，注意，这个 author 是一个文档类型，查询的时候需要该文档类型中的所有域都相等。 第三条查询语句使用 {comment: &#39;dddd&#39;} 来筛选，comment 是一个数组类型，查询时可以使用这种方式，表示查询的数组中含有 dddd 元素的数据，也可以使用 db.blog.find({comment: [&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;]}) 来查询，使用后一种方式时要使用匹配该数组中的所有元素才行。 如何查询stars大于 50 的数据1db.blog.find(&#123;stars: &#123;$gt: 50&#125;&#125;) 在 MongoDB 中 &gt;,&lt;, 都不能使用，要使用特殊符号来表示这些。符号如下: 含义 表示 大于 $gt 小于 $lt 不等于 $ne 大于等于 $gte 小于等于 $lte 用法和示例类似 如何多条件查询1db.blog.find(&#123;stars: 32, title: "走两步"&#125;) 要查询同时满足多个条件的数据，只需要如示例添加条件就行了。 如何查询满足其中一个条件的数据如果要求返回匹配多个条件中的一个条件的数据，需要使用关键字 $or，相当于 or 语句。 1db.blog.find(&#123;$or: [&#123;stars: 32&#125;, &#123;stars: 30&#125;]&#125;) 如何按照stars从大到小从小到大排序12db.blog.find(&#123;&#125;).sort(&#123;stars:1&#125;) //升序db.blog.find(&#123;&#125;).sort(&#123;stars:-1&#125;) //降序 如何实现分页MongoDB 中也有 limit 方法，但是这个 limit 和 MySQL 中的 limit 不同，这个 limit 只会返回指定条数的数据，不能指定从什么位置开始读取。要实现和 MySQL 中的 limit 相同的功能，需要同时使用 skip 和 limit。 1db.blog.find(&#123;&#125;).skip(1).limit(1) skip 表示跳过多条数据，limit 表示只读取多条数据，这里跳过第一条，只读取一条，那么就会读取所有数据的第二条。 如何实现分组在 MySQL 中，分组首先要有一个字段，按照这个字段的不同分成不同的组。MongoDB 中也是一样，需要某一个域作为参数，返回这个参数的不同的值。 分组要 aggregate 方法和 $group 操作符，在 $group 操作符中，使用 _id 来说明分组的 key 。 1db.blog.aggregate([&#123;$group: &#123;_id:'$stars'&#125;&#125;]) //按照 stars 字段进行分组 如何删除数据删除数据可以使用 remove,deleteOne 和 deleteMany 中的某一个。 如何删除一条数据如果只想删除一条数据，使用 deleteOne，它会删除满足条件的第一条语句。 1db.blog.deleteOne(&#123;title: "mongodb 数据库的创建"&#125;) 如何删除多条数据删除多条数据使用 deleteMany 是很不错的。 1db.blog.deleteMany(&#123;stars: &#123;$gt: 30&#125;&#125;) 删除单条数据使用 deleteOne，删除多条数据使用 deleteMany，至于 remove 一般情况下不需要使用，毕竟 deleteMany 既可以删除一条也可以删除多条。 如何更新数据更新数据使用 update,updateOne 和 updateMany。 如何更新一条数据更新一条数据使用 updateOne 方法，updateOne 方法会更新第一个匹配的数据。 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$set: &#123;stars: 50&#125;&#125;) updateOne 接收两个参数，第一个参数是要修改数据的查询条件，和查询时使用的条件一样，第二个参数表示要更新的数据。 注意 ：如果没有使用 $set 那么这条数据就只有一个域那就是 {stars:50}，使用 $set 之后才会修改指定的域，不然就是覆盖整条数据。 如何更新多条数据更新多条数据使用 updateMany，使用 update 也可以，可是使用 update 需要额外添加 {multi: true}，有些时候会忘记添加，忘记添加就相当于使用 updateOne。 1db.blog.updateMany(&#123;$or: [&#123;title: "mongodb 数据库的创建"&#125;, &#123;title: "走两步"&#125;]&#125;, &#123;$set: &#123;stars: 1000&#125;&#125;) 如何更新数据中的文档数据在我们插入的数据中有 author 域，该域是一个文档类型，和普通数据类型不同，如何修改，删除，添加里面的数据 如何删除文档类型数据中的域1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$unset: &#123;'author.lastName': 1&#125;&#125;) 这里使用了 $unset，这个操作会删除一个域，&#39;author.lastName&#39; 表示 author 文档的 lastName 属性，1 表示删除。$unset 不仅可以删除一个文档中的域，也可以删除一个域。 如何在文档类型数据中插入新的数据1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$set: &#123;'author.lastName': 'xin'&#125;&#125;) 上述操作不仅可以插入新的数据，也可以用来更新数据 如何更新数组中的数据和数组有关的操作符看这里 如何往数组中插入新的数据往数组中插入新的数据使用 $push 操作符 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$push: &#123;comment: 'zzzzzzzzzz'&#125;&#125;) 如何删除数组中的数据删除数组中的数据使用 $pop 操作符和 $pull 操作符。$pop 操作符用于删除并返回数组中的第一个或最后一个元素。$pull 操作符用于精确删除数组中匹配的数据。 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$pop:&#123;comment:1&#125;&#125;) 其中 {comment: 1} 中的 1 表示弹出并删除最后一个元素 1db.blog.updateOne(&#123;title:"mongodb 数据库的创建"&#125;, &#123;$pull: &#123;comment: 'bbbb'&#125;&#125;) 如何向数组中插入另一个数组的内容如果直接使用 $push 向数组中插入一个数组的话，都将数组作为一个元素插入，而不是将数组中的所有元素依次插入。 为了将一个数组中的所有元素都插入到数组中，需要使用 $each 关键字。 1db.blog.updateOne(&#123;title:"mongodb 数据库的创建"&#125;, &#123;$push: &#123;comment: &#123;$each: [1, 2, 3, 4, 5]&#125;&#125;&#125;); 如何向数组中插入不重复数据mongodb 没有提供编程语言中集合类型相似的数据结构，只有数组，为了不插入重复数据，可以使用 $addToSet 关键字，或者在输出的时候去重。 1db.log.updateOne(&#123;title: &quot;mongodb 数据库的创建&quot;&#125;, &#123;$addToPush: &#123;comment: &#123;$each: [7, 7, 7, 7]&#125;&#125;&#125;); 如何删除数组中的多个元素只使用 $pusll 关键字无法删除数组中的多个元素，只能删除一个元素，要删除多个使用 $in 关键字。 1db.blog.updateOne(&#123;titile: "mongodb 数据库的创建"&#125;, &#123;$pull : &#123;comment: &#123;$in: [1, 2, 3, 4, 5]&#125;&#125;&#125;); 如何创建索引使用文档中某个域创建索引，使用该域进行查询时可以加快查询速度 创建升序索引1db.blog.createIndex(&#123;title:1&#125;) 创建降序索引1db.blog.createIndex(&#123;title:-1&#125;) 如何查看创建索引1db.blog.getIndexes() 如何删除创建的索引删除对应索引，删除索引时的名称不是创建索引时的名称，而是使用 getIndexes 查看的 name 属性的名称 1db.blog.dropIndex('title_1')]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-简单爬虫]]></title>
    <url>%2F2018%2F06%2F30%2Fpython-reptile%2F</url>
    <content type="text"><![CDATA[python 简单爬虫 这不是一篇完整的爬虫教程，这是一篇使用python完成简单爬虫的使用过程记录。使用 python3 以及第三方库 requests 和 lxml 以及 xpath 技术来爬取一些网页数据这里只是用了 GET 请求，没有使用 POST 请求 第三方库和技术介绍requests: 这里使用 requests 来请求一个网页，并将响应结果封装在一个对象中返回 lxml: 使用 lxml 中的 etree 库对响应的 HTML 页面进行解析 xpath: 一种解析 xml 文档的技术，也可以解析 HTML 页面。在w3c可以找到文档 过程介绍 使用 requests.get 函数请求对应的URL 如果请求正常并有返回，将返回结果通过etree.HTML处理 使用xpath技术对etree.HTML处理过的对象进行解析，获取对应的数据 数据存储 请求页面请求头使用requests.get(url)方式可以请求对应的url内容，并将响应结果封装在一个对象中返回，但是直接使用这种方式的请求头中包含这个&quot;User-Agent&quot;:&quot;python-requests/2.19.1&quot;有些服务器会通过这个请求头得知这是一个python爬虫请求从而拒绝响应。为了正常访问，需要传入一个请求头来覆盖这个属性，从而骗过请求服务器。 在firefox浏览器中通过请求http://httpbin.org/get可以获得本机的请求头，下面是我请求的该链接的部分内容 将请求中的User-Agent对应的属性作为键值对形式传入requests.get()的headers参数，如下 12header = &#123;"User-Agent":"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"&#125;response = requests.get(url, headers=header) 请求参数如果你想要传入查询参数，只需要以键值对的形式传入requests.get中的params，下面的查询键为’user’，对应的值为’tom’ 123456789data = &#123;"user":"tom"&#125;response = requests.get(url, params=data)```python如果你有多个查询值也可以添加多个键值对```pythondata = &#123;"user":"tom","pwd":"jerry"&#125;response = requests.get(url, params=data) 请求超时设置对requests.get函数的timeout参数传入一个数字可以设置请求的最长时间 1response = requests.get(url, timeout=0.1) 响应处理使用response = requests.get()之后就获取了响应结果，这时可以对响应做一些处理 响应码response.status_code返回请求的响应码，正常情况下返回200 字符设置响应返回的结果不一定可以正常显示，对response.encoding属性进行赋值可以修改返回的字符集，一般设置为utf-8 1response.encoding = 'utf-8' 返回结果response.text将数据以文本形式返回，文本形式的字符集和字符设置有关，如果没有设置则返回响应数据设置的字符集 response.content将数据以字节形式返回，使用这种方式返回就不用担心返回的数据出现乱码问题 一个完整的请求实例请求一个url并将响应结果以文本的形式返回 123456789101112131415user_agent = "User-Agent"my_user_agent = "Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"header = &#123;user_agent: my_user_agent&#125;def getPage(url, data=None) : '''根据url请求一个html页面并返回''' try : r = requests.get(url, headers=header, params=data) r.encoding = 'utf-8' if r.status_code == 200: return r.text else : raise Exception("返回页面信息失败") except : raise Exception("请求链接失败") xpath处理使用lxml中的etree库中的HTML函数可以将一个HTML页面转换为一个对象，对该对象使用xpath语法即可获取对应的数据。有关更多的xpath技术点击这里 123from lxml import etreehtml = etree.HTML(html)html.xpath(xpath) 对于使用xpath语法来获取数据，在firefox浏览器中使用这个插件，可以在线使用xpath语法来匹配 注意:使用xpath语法返回的数据都是以列表形式返回 一个完整的可以爬取腾讯社招技术类的所有招聘信息的爬虫程序]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>reptile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA社区版使用maven搭建web开发环境]]></title>
    <url>%2F2018%2F04%2F17%2FIntelljJ-IDEA-Community-Edition-maven-webapp%2F</url>
    <content type="text"><![CDATA[IDEA社区版是不支持web应用程序开发，但是IDEA支持Maven，在Maven配置文件中可以添加tomcat插件，因此可以使用IDEA进行web应用程序开发 一 新建Maven项目在选择新项目时选择maven项目，勾选 Create from archetype，在下方选择maven-archetype-webapp，点击Next 输入GroupId和ArtifactId 选择Maven位置，如果Maven已经添加到环境变量，那么可以自动找到，如果没有配置，那么需要手动添加User setting file为你的Maven配置文件，如果不是默认路径需要手动添加Local repository为你的Maven仓库，如果不是默认路径需要手动添加 最后输入工程名称和工程位置 首次使用Maven会下载一些东西需要一些时间 二 配置tomcat 首先在tomcat中添加tomcat插件 123456789101112&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;hostName&gt;localhost&lt;/hostName&gt; &lt;!-- Default: localhost --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 启动端口 Default:8080 --&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;!-- uri编码 Default: ISO-8859-1 --&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 这里使用的tomcat7 配置tomcat7 单击菜单栏 Run，选择Edit Configurations…，进入如下界面 默认只有一个Defaults，Maven是我配置好了的 选择+-&gt;Maven 输入Tomcat7，在Command line输入tomcat7:run完成配置 点击Run开始运行，打开浏览器查看结果如下]]></content>
      <categories>
        <category>ide</category>
      </categories>
      <tags>
        <tag>configure</tag>
        <tag>ide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述九-插入排序和希尔排序]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B9%9D-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序插入排序基于这样一种情况，待插入的数组是顺序的(升序或降序)，此时将插入数据从数组从后向前比较，满足条件就插入，不满足就依次向后移动 插入排序就好象玩扑克时一张一张的拿牌，大的在左边，小的在右边，每拿一张牌就从右到左一次比较，在第一张大于的牌的右边插入新的扑克 插入算法1234567891011121314typedef int ElementType;void insertSort(ElementType* array,int len)&#123; int arrayMaxIndex = len - 1; int arrayMinIndex = 0; int index = 0; int j = 0; for(index = arrayMinIndex + 1;index &lt;= arrayMaxIndex;index++)&#123; int insertValue = array[index]; for(j = index - 1;j &gt;= 0 &amp;&amp; array[j] &gt; insertValue;j--)&#123; array[j + 1] = array[j]; &#125; array[j + 1] = insertValue; &#125;&#125; 希尔排序希尔排序通过比较相距一定间隔的元素来工作，将比较的元素按照大小排列到比较元素的位置，然后通过减小间隔再次比较，最后间隔为1时所有比较完成 最上面数据为未排序数据，由上往下增量依次为 5,3,1 希尔排序算法12345678910111213141516171819202122typedef int ElementType;void shellSort(ElementType* array,int increment,int len)&#123; int arrayMinIndex = 0; int arrayMaxIndex = len - 1; int sortTime = 0; int j = 0; int insertValue = 0; //当一趟的增量大于排序数组长度时进行的处理 if(increment &gt; len)&#123; shellSort(array,1,len); &#125; for(;sortTime &lt; increment;sortTime++)&#123; //插入排序的变形 for(int i = sortTime + increment;i &lt; len;i += increment)&#123; insertValue = array[i]; for(j = i - increment;j &gt;= arrayMinIndex &amp;&amp; array[j] &gt;= insertValue;j -= increment)&#123; array[j + increment] = array[j]; &#125; array[j + increment] = insertValue; &#125; &#125;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述八-再散列]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AB-%E5%86%8D%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么是再散列再散列也是散列表的一种，不同的是再散列可以动态的扩充表长，再搭配好的散列函数解决冲突 再散列在散列表到达某一临界点时扩充原来表长的容量，再将原来散列表中的数据重新散列移动到新的散列表的过程 类型声明1234567891011121314151617181920212223242526typedef unsigned int Index;typedef Index Position;struct HashTbl;typedef struct HashTbl* HashTable;typedef int ElementType;HashTable InitializeTable(int TableSize,float Facotr);void DestroyTable(HashTable H);Position Find(ElementType key,HashTable H);HashTable Insert(ElementType key,HashTable H);void Delete(ElementType key,HashTable H);HashTable Rehash(HashTable H);static Index Hash(const int key,int TableSize);enum KindOfEntry&#123;Legitimate,Emtry,Deleted&#125;;struct HashEntry&#123; ElementType Element; enum KindOfEntry Info;&#125;;typedef struct HashEntry Cell;struct HashTbl&#123; int TableSize; int Capacity; float LocalFacotr;//装填因子 int MaxCapacity;//散列表所能容纳的最大容量，超过该容量后就要扩容 Cell* TheCells;&#125;; 这里采用当散列表容量达到指定的装填因子时进行再散列，采用的默认散列因子是 0.75，TableSize 表示散列表的长度，Capacity 表示散列表容乃数据的大小，MaxCapacity 表示散列表可以容纳的最大容量，由 TableSize × LocalFacotr 得出 散列表的插入123456789101112131415HashTable Insert(ElementType key,HashTable H)&#123; if(H == NULL) return NULL ; if(H-&gt;Capacity &gt;= H-&gt;MaxCapacity)&#123; H = Rehash(H); &#125; int index = Hash(key,H-&gt;TableSize); //如果已经在相同下标的散列表上有值，那就不管了 if(H-&gt;TheCells[index].Info != Emtry)&#123; return H; &#125; H-&gt;Capacity++; H-&gt;TheCells[index].Element = key; H-&gt;TheCells[index].Info = Legitimate; return H;&#125; 当散列表的容量超过最大容量是就要使用再散列方法 12345678910HashTable Rehash(HashTable H)&#123; if(H == NULL) return NULL; HashTable T = InitializeTable(H-&gt;TableSize &lt;&lt; 1,H-&gt;LocalFacotr); for(int i = 0;i &lt; H-&gt;TableSize;i++)&#123; if(H-&gt;TheCells[i].Element != 0) Insert(H-&gt;TheCells[i].Element,T); &#125; DestroyTable(H); return T;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述七-开放定址散列表]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%83-%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是开放定址法开放定址法是另一种不用链表解决散列表冲突问题的方法，在开放定址散列算法系统中，如果发生冲突，那么就要尝试选择另外的单元，直到找出空的单元为止 冲突解决的方法 线性探测法 平方探测法 双散列 这里使用平方探测法进行示例，平方探测法在第一次冲突时将第一次哈希值的结果加上 F(i)，如果还是冲突，那么 i 加 1 ,再次使用第一次哈希值加上 F(i) 以此循环; F(i) = i * i(i = 1) 类型声明12345678910111213141516171819202122typedef unsigned int Index;typedef Index Position;struct HashTbl;typedef struct HashTbl* HashTable;typedef int ElementType;HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(ElementType key,HashTable H);HashTable Insert(ElementType key,HashTable H);static Index Hash(const int key,int TableSize);enum KindOfEntry&#123;Legitimate,Empty,Deleted&#125;;struct HashEntry&#123; ElementType Element; enum KindOfEntry Info;&#125;;typedef struct HashEntry Cell;struct HashTbl&#123; int TableSize; int Capacity; Cell* TheCells;&#125;; 在哈希表中，保存有哈希表的表长，当前表的容量，以及存储单元，每个存储单元保存实际存储的值，以及存储单元的信息，包括已经存储，没有存储和原来有存储现在被删除三种信息 哈希表的插入1234567891011121314151617181920HashTable Insert(ElementType key,HashTable H)&#123; if(H == NULL) return NULL ; int index = Hash(key,H-&gt;TableSize); int number = 0; //检查表容量 if(H-&gt;Capacity &gt;= H-&gt;TableSize) &#123; return H; &#125; //查找可以可以插入的点 while(H-&gt;TheCells[index].Info == Legitimate)&#123; index = index + 2 * (++number) + 1; if(index &gt;= H-&gt;TableSize) index = index - H-&gt;TableSize; &#125; //插入数据，重置单元信息，表容量加1 H-&gt;TheCells[index].Element = key; H-&gt;TheCells[index].Info = Legitimate; H-&gt;Capacity++; return H;&#125; 哈希表的查找查找操作也是和插入操作差不多的，不同的是如果查找的单元为空，则说明查找不成功 123456789101112131415Position Find(ElementType key,HashTable H)&#123; if(H == 0) return -1; int index = Hash(key,H-&gt;TableSize); int number = 0; while(1)&#123; if(H-&gt;TheCells[index].Info == Empty)&#123; return -1; &#125; if(H-&gt;TheCells[index].Element == key) return index; index += 2 * (++number) + 1; if(index &gt;= H-&gt;TableSize) index = index - H-&gt;TableSize; &#125; return -1;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述六-分离链接散列表]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AD-%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是分离链接散列表分离链接散列表是散列表解决冲突的一种方法，其做法是将散列到同一个值的所有元素保留到一个表中。为方便起见，这些表都有表头 分离链接散列表的定义 123456789101112131415161718192021struct ListNode;typedef struct ListNode* Position;struct HashTbl;typedef struct HashTbl* HashTable;typedef int ElementType;HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(ElementType key,HashTable H);void Insert(ElementType key,HashTable H);ElementType Retrieve(Position P);static int Hash(const int key,int TableSize);struct ListNode&#123; ElementType Element; Position Next;&#125;;typedef Position List;struct HashTbl&#123; int TableSize; List* TheList;&#125;; 分离链接散列表的初始化分离链接散列表在数组的每个位置保存有冲突元素组成链表的表头 123456789101112HashTable InitializeTable(int TableSize)&#123; HashTable H = NULL; H = (HashTable)malloc(sizeof(struct HashTbl)); if(H == NULL) return NULL; H-&gt;TableSize = TableSize; H-&gt;TheList = (List*)malloc(sizeof(struct ListNode) * TableSize); for(int i = 0;i &lt; TableSize;i++)&#123; H-&gt;TheList[i] = (List)malloc(sizeof(struct ListNode)); H-&gt;TheList[i]-&gt;Next = NULL; &#125; return H;&#125; 分离链接散列表的插入插入时先计算Hash值，然后将值作为对应表头的第一个元素，这里就相当与链表的头插法 12345678910void Insert(ElementType key,HashTable H)&#123; if(H == NULL) return ; int index = Hash(key,H-&gt;TableSize); Position ptr = H-&gt;TheList[index]; Position temp = (List)malloc(sizeof(struct ListNode)); if(temp == NULL) return ; temp-&gt;Element = key; temp-&gt;Next = ptr-&gt;Next; ptr-&gt;Next = temp;&#125; 分离链接散列表的查找查找时首先计算要查找值的Hash值，然后返回对应的表头，遍历链表，找到就返回 123456789101112Position Find(ElementType key,HashTable H)&#123; if(H == NULL) return NULL; int index = Hash(key,H-&gt;TableSize); Position ptr = H-&gt;TheList[index]; ptr = ptr-&gt;Next; while(ptr != NULL)&#123; if(ptr-&gt;Element == key) return ptr; ptr = ptr-&gt;Next; &#125; return NULL;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述五-伸展树]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%94-%E4%BC%B8%E5%B1%95%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是伸展树伸展树保证了从空树开始任意连续 M 次对树的操作最多话费 O(M log N) 时间，伸展树是二叉搜索树的一种变形，不同于 AVL 树，伸展树不需要维护节点的高度，相对 AVL 树来说比较容易实现 当一个节点被访问时它就有可能在不久之后被再次访问，因此，伸展树的基本思想是：当一个节点被访问，它就经过一系列 AVL 树的旋转操作将该节点放到根上 将某个节点经过一系列的变形移动到树根上的操作称之为伸展(Splay)，伸展操作主要进行六个形态的转变，再将伸展节点伸展之后会再次检查伸展节点的位置，如果伸展节点是根结点则返回，否则继续伸展 伸展树声明12345678910111213141516171819202122SplayTree MakeEmpty(SplayTree T);Position Find(ElementType X,SplayTree T);Position FindMin(SplayTree T); Position FindMax(SplayTree T);SplayTree Insert(ElementType X,SplayTree T); SplayTree Delete(ElementType X,SplayTree T);ElementType Retrieve(Position P);Position FindPositionUp(SplayTree T,ElementType X);void printTree(SplayTree T);static Position SingleRotaleWithLeft(Position T);static Position SingleRotaleWithRight(Position T);static Position ContinuRotaleWithLeft(Position T);static Position ContinuRotaleWithRight(Position T);static Position DoubleRotaleWithLeft(Position T);static Position DoubleRotaleWithRight(Position T);static Position Splay(ElementType X,SplayTree T);struct TreeNode&#123; ElementType Element; SplayTree Left; SplayTree Right;&#125;; 伸展功能伸展功能依赖于 6 个函数分别时左旋转，右旋转，连续左旋转，连续右旋转，左双旋转，右双旋转，分别对应 6 中变形 12345678910111213141516171819202122232425262728293031323334//左旋转static Position SingleRotaleWithLeft(Position T)&#123; Position ptr = T-&gt;Left; T-&gt;Left = ptr-&gt;Right; ptr-&gt;Right = T; return ptr;&#125;//右旋转static Position SingleRotaleWithRight(Position T)&#123; Position ptr = T-&gt;Right; T-&gt;Right = ptr-&gt;Left; ptr-&gt;Left = T; return ptr;&#125;//连续左旋转static Position ContinuRotaleWithLeft(Position T)&#123; Position ptr = SingleRotaleWithLeft(T); return SingleRotaleWithLeft(ptr);&#125;//左双旋转static Position DoubleRotaleWithLeft(Position T)&#123; T-&gt;Right = SingleRotaleWithLeft(T-&gt;Right); return SingleRotaleWithRight(T);&#125;//连续右旋转static Position ContinuRotaleWithRight(Position T)&#123; Position ptr = SingleRotaleWithRight(T); return SingleRotaleWithRight(ptr);&#125;//右双旋转static Position DoubleRotaleWithRight(Position T)&#123; T-&gt;Left = SingleRotaleWithRight(T-&gt;Left); return SingleRotaleWithLeft(T);&#125; 伸展树的伸展流程如下: 伸展节点为根节点，不做任何改变，并返回 伸展节点是根结点的左儿子，将伸展节点向左旋转 伸展节点是根结点的右儿子，将伸展节点向左旋转 伸展节点不属于上述三种情况，将伸展节点称为X,X的父结点称为F，F的父结点称为G，G节点就是X节点的’祖父’节点4.1. 如果G的左儿子是F，并且F的左儿子是X，进行连续左旋转4.2. 如果G的右儿子是F，并且F的右儿子是X，进行连续右旋转4.3. 如果G的左儿子是F，并且F的右儿子是X，进行左双旋转4.4. 如果G的右儿子是F，并且F的左儿子是X，进行有双旋转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static Position Splay(ElementType X,SplayTree T)&#123; if(T == NULL || T-&gt;Element == X) return T; //查找伸展节点的父结点 Position fatherNode = FindPositionUp(T,X); if(fatherNode == T)&#123; if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123; //伸展节点属于根结点的左儿子 return SingleRotaleWithLeft(fatherNode); &#125;else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123; //伸展节点属于根结点的右儿子 return SingleRotaleWithRight(fatherNode); &#125; &#125;else&#123; Position grandNode = FindPositionUp(T,fatherNode-&gt;Element); Position grandGrandNode = FindPositionUp(T,grandNode-&gt;Element); Position temp = NULL; int level = -1; //判断伸展节点，父结点和祖父节点的关系 if(grandNode-&gt;Left != NULL &amp;&amp; grandNode-&gt;Left == fatherNode)&#123; if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123; level = 1; &#125;else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123; level = 2; &#125; &#125;else if(grandNode-&gt;Right != NULL &amp;&amp; grandNode-&gt;Right == fatherNode)&#123; if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123; level = 3; &#125;else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123; level = 4; &#125; &#125; switch(level)&#123; case 1://左左 temp = ContinuRotaleWithLeft(grandNode); break; case 2://左右 temp = DoubleRotaleWithRight(grandNode); break; case 3://右左 temp = DoubleRotaleWithLeft(grandNode); break; case 4://右右 temp = ContinuRotaleWithRight(grandNode); break; &#125; if(grandNode == T) return temp; else if(grandGrandNode-&gt;Left == grandNode) grandGrandNode-&gt;Left = temp; else if(grandGrandNode-&gt;Right == grandNode) grandGrandNode-&gt;Right = temp; return Splay(X,T); &#125;&#125; 查询操作查询操作先要确定树中含有要查询的节点，如果没有则直接返回，否则将查询到的节点进行伸展移动到根结点然后返回 12345678910111213Position Find(ElementType X,SplayTree T)&#123; if(T-&gt;Element == X) return T; Position dst = T; while(dst != NULL &amp;&amp; X != dst-&gt;Element)&#123; if(X &lt; dst-&gt;Element) dst = dst-&gt;Left; else if(X &gt; dst-&gt;Element) dst = dst-&gt;Right; &#125; if(dst != NULL) return Splay(X,T); return T;&#125; 插入操作插入操作先将元素按照二叉搜索树的性质插入树中，然后在将插入的节点伸展到根结点 12345678910111213141516171819202122232425262728293031SplayTree Insert(ElementType X,SplayTree T)&#123; Position temp = NULL; temp = (SplayTree)malloc(sizeof(struct TreeNode)); if(temp == NULL)&#123; printf("初始化树失败\n"); return NULL; &#125; temp-&gt;Element = X; temp-&gt;Left = temp-&gt;Right = NULL; if(T == NULL)&#123; T = temp; return T; &#125; Position ptr = T; //按照二叉搜索树的性质插入节点 while(1)&#123; if(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left != NULL)&#123; ptr = ptr-&gt;Left; &#125;else if(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right != NULL)&#123; ptr = ptr-&gt;Right; &#125;else if(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left == NULL)&#123; ptr-&gt;Left = temp; break; &#125;else if(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right == NULL)&#123; ptr-&gt;Right = temp; break; &#125; &#125; return Splay(X,T);&#125; 删除操作删除操作先将删除节点伸展到根结点，此时，根结点的左子树元素都小于根节点，右子树元素都大于根结点，删除根结点，然后将左子树的最大元素进行伸展，此时左子树根结点是左子树中的最大元素，没有右儿子，然后再将左子树的右指针指向右子树，删除完成 1234567891011121314SplayTree Delete(ElementType X,SplayTree T)&#123; if(T == NULL) return NULL; if(X == T-&gt;Element)&#123; if(T-&gt;Left == NULL) return T-&gt;Right; else if(T-&gt;Right == NULL) return T-&gt;Left; //再查找最大元素的同时就对最大元素进行了伸展操作 Position left = FindMax(T-&gt;Left); left-&gt;Right = T-&gt;Right; free(T); return left; &#125; T = Splay(X,T); return Delete(X,T);&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述四-AVL树]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%9B%9B-AVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AVL 树是带有平衡条件的二叉查找树，所谓平衡条件就是:任何节点的深度均不得过深，如下图所示的二叉查找树是不应该出现的 一颗 AVL 树是其每个节点的左子树和右子树的高度最多差1的二叉查找树（空树的高度定义为-1），这是一颗 AVL 树，树的高度为 3 AVL树的定义123456789101112131415161718192021//头文件中的函数定义struct AvlNode;typedef struct AvlNode* Position;typedef struct AvlNode* AvlTree;typedef int ElementType ;AvlTree MakeEmpty(AvlTree T);Position Find(ElementType X,AvlTree T);Position FindMin(AvlTree T);Position FindMax(AvlTree T);AvlTree Insert(ElementType X,AvlTree T);AvlTree Delete(ElementType X,AvlTree T);ElementType Retrieve(Position P);//具体实现文件中的树节点定义，这里的树节点元素使用int类型struct AvlNode&#123; ElementType Element; AvlTree Left; AvlTree Right; int Height;&#125;; 可以看见，AVL 树和二叉查找树的定义没有什么区别，在节点定义上多了一个变量用来存储树的高度 AVL树的实现AVL 树的不同主要体现在插入和删除时的不同，在插入和删除时都有可能破坏 AVL 树的平衡，此时就需要对 AVL 树进行平衡修复 AVL树的插入实现图摘自维基百科 进行插入操作时，有四种情况可能破坏AVL树的平衡，我们把被破坏的平衡的节点称为root 对 root 左儿子的左子树进行一次插入，对应上图的左左情况 对 root 右儿子的右子树进行一次插入，对应上图的右右情况 对 root 左儿子的右子树进行一次插入，对应上图的左右情况 对 root 右儿子的左子树进行一次哈入，对应上图的右左情况 对于 1，2 情况，插入节点相对于 root 节点的’外侧’，这时只需要对 root 节点和 root 节点的左儿子或者右儿子进行一次右旋转或者左旋转就可以了; 3，4 情况相对于 root 节点的’内侧’，这是需要实行两次的旋转达到平衡 注意，无论是一次旋转还是两次旋转，都是为了满足二叉查找树的性质和平衡条件 下图演示了依次将 3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9 插入 AVL 树的过程，带箭头的表示插入时使用了旋转操作 上图演示了从1到7顺序插入AVL树的过程，这里都是1和2的情况 插入代码实现123456789101112131415161718192021222324252627AvlTree Insert(ElementType X,AvlTree T)&#123; if(T == NULL)&#123; T = (AvlTree)malloc(sizeof(struct AvlNode)); if(T == NULL) return NULL; T-&gt;Left = T-&gt;Right = NULL; T-&gt;Element = X; T-&gt;Height = 0; &#125;else&#123; if(X &gt; T-&gt;Element)&#123; T-&gt;Right = Insert(X,T-&gt;Right); if(Height(T-&gt;Right) - Height(T-&gt;Left) == 2) if(X &gt; T-&gt;Right-&gt;Element) T = SingleRotaleWithRight(T); else T = DoubleRotaleWithRight(T); &#125;else&#123; T-&gt;Left = Insert(X,T-&gt;Left); if(Height(T-&gt;Left) - Height(T-&gt;Right) == 2) if(X &lt; T-&gt;Left-&gt;Element) T = SingleRotaleWithLeft(T); else T = DoubleRotaleWithLeft(T); &#125; &#125; T-&gt;Height = max(Height(T-&gt;Left),Height(T-&gt;Right)) + 1; return T;&#125; AVL树的删除实现AVL树的删除实现比起插入实现要复杂 基本想法是删除成功时，修正删除路径上节点高度，然后判断删除路径上的节点的平衡，然后进行旋转 删除失败时，不改变任何东西 由于删除功能是按照本人自己的想法实现，实现过程较长，这里不进行展示，如有兴趣可以查看参考源码 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述三-二叉查找树]]></title>
    <url>%2F2018%2F03%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%89-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树是二叉树的特殊形式，主要性质是，对于树中的每个节点X，它的左子树中所有值小于X的值，而它的右子树中所有值大于X的值 因此，二叉查找树可以用某种统一的方式排序 根据这一性质，可以对二叉查找树有如下的函数定义 12345678910111213141516171819202122//头文件中的函数定义struct TreeNode;typedef struct TreeNode* Position;typedef struct TreeNode* SearchTree;typedef int ElementType;SearchTree MakeEmpty(SearchTree T);Position Find(ElementType X,SearchTree T);Position FindMin(SearchTree T);Position FindMax(SearchTree T);SearchTree Insert(ElementType X,SearchTree T);SearchTree Delete(ElementType X,SearchTree T);ElementType Retrieve(Position P);Position FindPositionUp(SearchTree T,ElementType X);//具体实现文件中树节点的定义，这里将树节点元素类型定义为int类型typedef int ElementType;struct TreeNode&#123; ElementType Element; SearchTree Left; SearchTree Right;&#125;; 函数实现 二叉查找树中最主要的两个功能就是插入数据和删除数据，在插入和删除数据之后需要保持整个二叉查找树任然具备二叉查找树的性质，这是很关键的 插入功能的实现根据二叉查找树的性质，那么要插入的数据是出入叶子节点实现算法如下: 判断插入元素与根节点元素的大小: 如果被插入的树是空树，那么分配内存空间并将新节点插入空树中; 如果插入元素大于根节点元素，使用递归的方式将插入元素插入到根节点的右子树上; 如果插入元素小于根节点元素，使用递归的方式将插入元素插入根节点的左子树上; 如果插入元素等于根节点元素，什么也不做 代码实现如下 12345678910111213141516SearchTree Insert(ElementType X,SearchTree T)&#123; if(T == NULL)&#123; T = (SearchTree)malloc(sizeof(struct TreeNode)); if(T == NULL) &#123; printf("初始化树失败\n"); return NULL; &#125; T-&gt;Element = X; T-&gt;Left = T-&gt;Right = NULL; &#125;else if(X &lt; T-&gt;Element)&#123; T-&gt;Left = Insert(X,T-&gt;Left); &#125;else if(X &gt; T-&gt;Element)&#123; T-&gt;Right = Insert(X,T-&gt;Right); &#125; return T;&#125; 删除功能的实现删除功能相比于插入功能要困难， 如果删除的节点是叶子节点直接删除就行了， 如果删除的节点不是叶子节点，那么就需要找到一个节点来代替这个删除节点继续维持性质 删除功能算法如下: 如果删除元素小于根节点元素，就去根节点的左子树删除该元素 如果删除元素大于根节点元素，就去根节点的右子树删除该元素 如果删除元素等于根节点元素，并且这个根节点还有两个子节点，先找到根节点右子树的最小值(或者根节点左子树的最大值)，将根节点的值修改为右子树的最小值(或者左子树的最大值)，然后去根节点的右子树删除最小值(或者去根节点的左子树删除最大值)。这里实际上把删除一个根节点改变为删除一个叶子节点 如果删除元素等于根节点，并且这个根节点只有一个或者没有子节点4.1 如果根节点只有右节点，将根节点变为右节点4.2 如果根节点只有左节点，将根节点变为左节点4.3 如果根节点没有子节点，参照4.1 代码实现如下 1234567891011121314151617181920212223SearchTree Delete(ElementType X,SearchTree T)&#123; Position ptr = T; if(T == NULL) return T; else if(X &lt; T-&gt;Element) T-&gt;Left = Delete(X,T-&gt;Left); else if(X &gt; T-&gt;Element) T-&gt;Right = Delete(X,T-&gt;Right); else if(T-&gt;Left != NULL &amp;&amp; T-&gt;Right != NULL)&#123; //找到根节点右子树的最小值 ptr = FindMin(T-&gt;Right); //将右子树的最小值赋给根节点 T-&gt;Element = ptr-&gt;Element; //前往右子树删除最小值 T-&gt;Right = Delete(T-&gt;Element,T-&gt;Right); &#125;else&#123; ptr = T; if(T-&gt;Left == NULL)&#123; T = T-&gt;Right; &#125;else if(T-&gt;Right == NULL)&#123; T = T-&gt;Left; &#125; free(ptr); &#125; return T;&#125; 二叉查找树可以方便的查找，但是在某些情况下，如果在二叉查找树中依次插入 1,2,3,4,5,6，那么得到的二叉查找树图如下: 这样的情况不是我们想看见的，在这种情况下使用平衡二叉树可以改善这个问题 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-collect方法]]></title>
    <url>%2F2018%2F01%2F13%2Fjava8-collect%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[collect方法collect 方法是 Stream 中一个很重要的方法，通过这个方法可以将流中的数据格式转换为需要的形式，如，List，Set，Map，求流数据的总数，流中数据某条属性的平均值或者其他值，将流中的字符串拼接为一条字符串等。 收集器是 Stream 用于收集某种形式的数据信息，基本上所有的 Stream 的终端操作都可以使用 collect 方法来实现 collect的定义collect 方法有两种形式 123456方法原型1&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);方法原型2&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 这里主要使用方法原型 2,这个方法原型接收一个实现了 Collector 接口的对象，Collector 接口有五个抽象方法，幸运的是 java8 封装了一些常用的方法供我们使用，这些常用方法封装在 java.util.stream.Collectors 对象中，这个对象含有多个静态方法，用来返回 Collector 对象 collect 方法示例Apple.java 1234567891011public class Apple &#123; private int weight; private String color; public Apple(int weight, String color) &#123; super(); this.weight = weight; this.color = color; &#125; //getter //setter&#125; Main.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Main &#123; public static void main(String[] args) &#123; List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,"green"), new Apple(20,"red"), new Apple(12,"red"), new Apple(12,"red"), new Apple(25,"green")); //返回重量最重的苹果 System.out.println("-------------------返回重量最重的苹果----------------"); Optional&lt;Apple&gt; heaviestApple = inventory.stream().collect(Collectors.maxBy(Comparator.comparing(Apple::getWeight))); System.out.println(heaviestApple); //返回重量最轻的苹果 System.out.println("-------------------返回重量最轻的苹果----------------"); Optional&lt;Apple&gt; lightestApple = inventory.stream().collect(Collectors.minBy(Comparator.comparing(Apple::getWeight))); System.out.println(lightestApple); //返回苹果的总重量 System.out.println("-------------------返回苹果的总重量----------------"); int sumInt = inventory.stream().collect(Collectors.summingInt(Apple::getWeight)); System.out.println(sumInt); //使用Collectors.averagingInt方法求苹果的平均重量 System.out.println("-------------------求苹果的平均重量-----------------"); double averageWeight = inventory.stream().collect(Collectors.averagingDouble(Apple::getWeight)); System.out.println(averageWeight); //返回苹果的重量的各个数据 System.out.println("-------------------返回苹果重量的各个数据属性-----------------"); IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); System.out.println(intSummartStatistics); //将所有苹果颜色拼接为一个字符串 System.out.println("-------------------将所有苹果颜色拼接为一个字符串-----------------"); //joining会自动将流中的数据拼接为字符串，在处理时需要保证流中的数据都是字符串 String appleColors = inventory.stream() .map(Apple::getColor) //将流中的apple转换为apple的颜色 .collect(Collectors.joining(/*将每一个颜色后面加上一个空格*/" ")); System.out.println(appleColors); //返回苹果数量 System.out.println("-------------------返回苹果的总数量-----------------"); Long count = inventory.stream().collect(Collectors.counting()); System.out.println(count); //分组 System.out.println("-------------------将苹果按照苹果颜色进行分组----------------"); Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); System.out.println(appleColorMap); System.out.println("-------------------将苹果按照苹果颜色和重量进行分组 ----------------"); System.out.println(inventory.stream().collect(Collectors.groupingBy(Apple::getColor, Collectors.groupingBy(apple -&gt; &#123; if(apple.getWeight() &gt; 10 &amp;&amp; apple.getWeight() &lt; 20) return "一般"; else if(apple.getWeight() &gt;= 20 ) return "很重"; else return "轻"; &#125;)))); //收集每个颜色的苹果有多少个 System.out.println("-------------------收集每个颜色的苹果有多少个----------------"); Map&lt;String, Long&gt; colorCount = inventory.stream().collect(Collectors.groupingBy(Apple::getColor,Collectors.counting())); System.out.println(colorCount); //分区 System.out.println("-------------------根据苹果颜色进行分区----------------"); Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals("red"))); System.out.println(colorPartition); //归约 System.out.println("-------------------归约操作----------------"); System.out.println(inventory.stream().collect(Collectors.reducing(0,Apple::getWeight,(a,b) -&gt; a + b))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing((a,b) -&gt; &#123; if(a &gt; b) return a; else return b; &#125;))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing(100,(a,b) -&gt; &#123; if(a &gt; b) return a; else return b; &#125;))); &#125;&#125; 上面代码使用了大多数 Collectors 的方法，还有一些类型的方法,如: averagingDouble,averagingInt,averagingLong 都是相同的。 Collectors 中的方法大致分为分组，分区，容器（返回list，set，map），简单的数值计算和其他 其中分组和分区是有区别的，分区可以看做是分组的特殊形式，分区只会有两个区别满足条件的（true）和不满足条件的（false），不管是分区还是分组，都可以再分,分组是根据返回的条件进行分组 1Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); 这里就是根据苹果的颜色进行分组，map 中只会有两个主键，red 或者 green。如果将条件改为 Apple::getWeight，那么主键就会有 10,20,12,25，因为有两个重量为 12 的苹果，这两个苹果就会分在一组 1Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals("red"))); 这里根据苹果颜色是不是红色进行分区，只会有两个主键，true 或者 false，true 分区里的苹果都是红色的，false 分区里的值都不是红色的，但是 partitioningBy 里面可以传第二个参数，可以对分区里面再进行收集（collect方法）操作 容器可以为三种，List，Set，Map 容器，只需要调用 Collectors.toXxxx() 方法就可以将流最后组装成一个容易 简单的数值计算可以直接通过流计算得出，例如 Stream.max() 方法和 Stream.collect(Collectors.maxBy()) 方法是相同的，在某些方面，如 1IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); 可以返回多种数据的不同运算结果，还是很方便的 collect 方法接收一个 Collector 对象，而大多数的 Collector 对象都可以通过 Collectors 对象的静态工厂方法获取，如果有需要可以查阅手册]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-使用流]]></title>
    <url>%2F2018%2F01%2F12%2Fjava8-%E4%BD%BF%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[流介绍流是java API的新成员，他允许你以声明的方式处理数据集合（通过查询语句，而不是临时编写一个实现） 使用流集合是流最容易上手的方式，Java8 中的集合支持一个新的stream方法，他会放回一个流对象（接口定义在java.util.stream.Stream）中 使用流可以完成什么事？他可以让我们以一种流水线的方法处理集合数据 像我们前面处理苹果集合时那样，可以实现一个方法来收集或处理某些数据，比如过滤颜色不是红色的苹果，收集苹果的重量列表，但是每一次都需要调用一个方法，流为我们处理这种“一系列”数据提供了一些方法，可以像工厂流水线的方法对流数据进行处理 比如要收集颜色是红色苹果的重量集合，可以想这样写 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).map(Apple::getWeight).forEach(System.out::println); 这里先通过方法stream()生成一个流对象，再使用filter方法过滤掉颜色不是红色的苹果，接着通过map将所有颜色是红色的苹果的重量返回成一个数值流也就是剩下苹果重量的集合，接着调用forEach方法打印剩下苹果的重量。可以读作先过滤掉颜色不是红色的苹果，接着返回所有苹果重量的集合，然后打印如果使用上一节自定义方法实现这些操作书写格式如下: inventory = filter(inventory,apple -&gt; apple.getColor().equals(&quot;red&quot;)); List&lt;Integer&gt; weights = map(inventory,Apple::getWeight); forEach(weights, System.out::println); 可以看见流的可读性以及书写性都要高于自定义实现 流方法流的方法分为两类，一类是中间操作，一类是终端操作，中间操作是对流完成操作之后还会返回一个流对象，而终端操作的返回结果是任何不是流的值，前面的filter，map就是中间操作，forEach就是终端操作 使用流方法对苹果库存进行操作 使用forEach打印数据 inventory.stream().forEach(System.out::println); 筛选颜色为红色的苹果 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).forEach(System.out::println); 对苹果颜色进行排序，如果个颜色相同，根据重量大小由小到大排序 Comparator&lt;Apple&gt; colorSort = (a1,a2) -&gt; a1.getColor().compareTo(a2.getColor()); Comparator&lt;Apple&gt; weightSort = (a1,a2) -&gt; a1.getWeight() - a2.getWeight(); inventory.stream().sorted(colorSort.thenComparing(weightSort)).forEach(System.out::println); 去除颜色和重量相同的苹果 inventory.stream().distinct().forEach(System.out::println); 只获取前三个苹果 inventory.stream().limit(3).forEach(System.out::println); 跳过前面两个苹果，只获取后面三个 inventory.stream().skip(2).forEach(System.out::println); 不要第一个苹果也不要最后一个苹果 inventory.stream().skip(1).limit(inventory.size() - 2).forEach(System.out::println); 将所有苹果的重量加10 inventory.stream().peek(apple -&gt; apple.setWeight(apple.getWeight() + 10)).forEach(System.out::println); 查看有没有重量是20,颜色是红色的苹果 System.out.println(inventory.stream().anyMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是所有苹果的重量是20,颜色是红色 System.out.println(inventory.stream().allMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是没有苹果是红色的 System.out.println(inventory.stream().noneMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看第一个苹果 System.out.println(inventory.stream().findFirst()); 返回苹果的总重量 System.out.println(inventory.stream().map(Apple::getWeight).reduce(0, (a,b) -&gt; (a + b))); 返回苹果的最小重量 System.out.println(inventory.stream().map(Apple::getWeight).min((n1,n2) -&gt; n1 - n2)); 返回苹果的最大重量 System.out.println(inventory.stream().map(Apple::getWeight).max((n1,n2) -&gt; n1 - n2)); 流的终端操作 方法 作用 boolean allMatch(Predicate&lt;? super T&gt; predicate) 如果流对象都可以匹配谓词，返回true，否则返回false boolean anyMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中有一个或多个匹配谓词，返回true，否则返回false boolean noneMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中任何一个都没有匹配谓词，返回true，否则返回false Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最大值 Oprional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最小值 Optional&lt;T&gt; findAny() 未知 Optional&lt;T&gt; findFirst() 返回流对象中的第一个值 long count() 返回流中数据的个数 &lt;R,A&gt; R collect(Collecotr&lt;? super T,A,R&gt; collector) 未知 &lt;R&gt; R collecot(Supplier&lt;R&gt; supplier,BiConsumer&lt;R,? super T&gt; accumulator,BiConsumer&lt;R,R&gt; combiner) 未知 void forEach(Consumer&lt;? super T&gt; action) 未知 void forEachOrDered(Consumer&lt;? super T&gt; action) 未知 Oprional&lt;T&gt; reduce&lt;T identity,BinaryOperator&lt;T&gt; accumulator) 未知 &lt;U&gt; U reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner) 未知 Object[] toArray() 未知 &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) 未知 流的中间操作 方法 作用 distinct() 去重，流中的对象需要实现equlas方法 filter(Predicate&lt;? super T&gt; predicate) 按照规则过滤，满足规则的留下，不满足的去掉 limit(long maxSize) 返回数据的最大个数，10表示返回10个数据，5表示返回5个 map(Function&lt;? super T,? extends R&gt; mapper) 将每个流对象作为函数的参数，并且将返回值填充流对象 flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 将每个流对象作为函数的参数，但是只返回一个流对象 peek(Consumer&lt;? super T&gt; action) 可以在流处理时对每个流数据进行操作，并返回Stream对象 skip(long n) 跳过n个数据，n等于10,表示跳过前面10个数据，和limit方法一起使用效果更好 sorted() 默认排序，排序类需要实现默认排序接口 sorted(Comparator&lt;? super T&gt; comparator) 使用自定义排序对流数据进行排序 值得注意的是flatMap方法，这个方法和map方法不同，map方法会将每一个流对象都作用于Function&lt;? super T,? extends R&gt;返回一个R对象，flatMap方法也会将所有的流对象作用于Function的方法，但是只会返回一个`流对象`，这个方法可以用作一个流中的对象的属性是集合，并且需要将所有流对象为集合的属性收集起来的情况，比如收集几个字符串中所有不重复的字符。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-复合lambda表达式]]></title>
    <url>%2F2018%2F01%2F11%2Fjava8-%E5%A4%8D%E5%90%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java8中的函数式借口提供了允许你进行复合的方法，可以把多个lambda表达式复合成更复杂的表达式,就好像与操作(and)，或操作(or)，非操作(not)，以及组合操作 Predicate系列的组合操作接口 相关方法 Predicate&lt;T&gt; Predicate&lt;T&gt; negate() Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) DoublePredicate negate() DoublePredicate DoublePredicate and(DoublePredicate other) DoublePredicate or(DoublePredicate other) IntPredicate negate() IntPredicate IntPredicate and(IntPredicate other) IntPredicate or(IntPredicate other) LongPredicate negate() LongPredicate LongPredicate and(LongPredicate other) LongPredicate or(LongPredicate other) BiPredicate&lt;T,U&gt; negate() BiPredicate&lt;T,U&gt; BiPredicate&lt;T,U&gt; and(BiPredicate&lt;? super T,? super U&gt; other) BiPredicate&lt;T,U&gt; or(BiPredicate&lt;? super T,? super U&gt; other) Predicate系列的每个借口都含有and,or,not操作，可以和其他相同的借口进行组合对于苹果类，根据苹果的颜色和重量筛选符合要求的苹果可以有 //筛选颜色为红色的苹果 Predicate&lt;Apple&gt; redApple = (Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;); //筛选苹果重量大于15的苹果 Predicate&lt;Apple&gt; weightApple = apple -&gt; apple.getWeight() &gt; 15; //对苹果的颜色和重量筛选进行复合，筛选出即是红色重量有大于15的苹果 List&lt;Apple&gt; filterApples = filter(inventory,redApple.and(weightApple)); //筛选出是红色或者重量大于15的苹果 filterApples = filter(inventory,redApple.or(weightApple)); //筛选出既不是颜色既不是红色重量也不大于15的苹果 filterApples = filter(inventory,redApple.negate().or(weightApple.negate())); Function系列的组合操作接口 相关方法 Function&lt;T,R&gt; Function&lt;T,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before) BiFunction&lt;T,U,R&gt; BiFunction&lt;T,U,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function系列的接口只有Function和BiFunction可以进行复合操作 Function的意思是函数，作为函数，具有参数和返回值，类似于f(x) = x + 1, 那么Function的addThen方法可以理解为将我的返回值作为别的函数的参数，在别的函数中进行函数运算。 如果说有两个函数 f(x) = x + 1 和 g(y) = y + 2，那么addThen可以将f(x)的返回值作为g(x)的参数传递进去，类似于g(f(x)) = f(x) + 2 = (x + 1) + 2这种 同样compose方法可以将别的函数的返回值作为自己的参数进行函数运算 BiFunction和Function不同的是，他具有三个泛型参数，以及他的addThen方法接收的是一个Function&lt;? super V,? extends T&gt;对象 同样也是将BiFunction的运算结果作为Function的参数，返回Function的运算结果 使用Function接口实现为苹果的重量加20，并返回一个列表 //获取苹果的重量 Function&lt;Apple,Integer&gt; getWeight = Apple::getWeight; //将一个数字加上20,在这里这个数字表示重量 Function&lt;Integer,Integer&gt; addWeight = weight -&gt; weight + 20; //使用Function的addThen方法将所有苹果的重量加上20并返回一个列表 List&lt;Integer&gt; weights = map(inventory,getWeight.andThen(addWeight)); //使用Function的compose方法将所有苹果的重量加上20并返回一个列表 weights = map(inventory,addWeight.compose(getWeight)); Consumer系列接口接口 相关方法 Consumer&lt;T&gt; Consumer&lt;T&gt; addThen(Consumer&lt;? super T&gt; after) DoubleConsumer DoubleConsumer addThen(DoubleConsumer after) IntConsumer IntConsumer addThen(IntConsumer after) LongConsuemr LongConsumer addThen(LongConsumer after) BiConsumer&lt;T,U&gt; BiConsumer&lt;T,U&gt; addThen(BiConsumer&lt;? super T,? super U&gt; after) Consumer系列的接口只接收一个泛型参数的都可以使用addThen方法，接收两个参数的只有BiConsumer接口可以使用addThen方法 关于addThen方法，很显然，在经过当前的Consumer对象的处理之后，可以继续被某个Consumer对象处理 使用Consumer将苹果的重量在原有的基础上乘2再加上10 //将苹果的重量乘2 Consumer&lt;Apple&gt; two = apple -&gt; apple.setWeight(apple.getWeight() * 2); //将苹果的重量加10 Consumer&lt;Apple&gt; add = apple -&gt; apple.setWeight(apple.getWeight() + 10); //使用组合将苹果的重量先乘2再加10 forEach(inventory,two.andThen(add));]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian-环境搭建]]></title>
    <url>%2F2018%2F01%2F08%2Fdebian-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用usb installer创建debian启动盘选择系统类型时，选择debian系统无法正确的创建启动盘，要选择其他linux系统类型才能正常创建 安装系统三个挂载目录，/,/home，/opt，其中/home和/opt是原来使用的挂载目录，没有改变，只覆盖了/目录debian桌面环境选择xfce桌面，核心功能模块 联网安装完系统后，第一步就是联网，正常连接校园网，免去了回退ubuntu的烦恼 设置镜像源debian在中国有两个主镜像源 123456deb http://security.debian.org/debian-security stretch/updates main contribdeb-src http://security.debian.org/debian-security stretch/updates main contribdeb http://ftp2.cn.debian.org/debian/ stretch main contrib non-freedeb-src http://ftp2.cn.debian.org/debian/ stretch main contrib non-freedeb http://ftp2.cn.debian.org/debian/ stretch-updates main contrib non-freedeb-src http://ftp2.cn.debian.org/debian/ stretch-updates main contrib non-free debian的主镜像源在国内也可以正常访问在/etc/apt/source.list文件中添加以下类似的源 安装vim切换管理员用户 12suapt-get install vim-gnome 安装中文输入法linux下的中文输入法有很多，这里选择fcitx，其他的ibus和搜狗输入法都与各种原因没有安装上，很遗憾没有体验一次切换管理员用户 1234suapt install fcitxapt install im-configapt install fcitx-sunpinyin 这个中文输入可以自行更换，不一定只能是这个 然后输入im-config进行配置，将下载的输入法添加到fcitx中就行了 如果 im-config 命令提示缺少什么就需要下载什么 设置完成之后无法显示输入法的提示框，先删除 ~/.config/fcitx 目录，然后卸载已将安装的 fcitx 重新安装 安装无线网卡驱动debian 不会自动安装无线网卡驱动，如果需要手动安装 12apt install firmware-iwlwifimodprobe -r iwlwifi ; modprobe iwlwifi 配置java环境原来的java文件夹位于/opt/jdk下，因为没有覆盖/opt，所以不用重新下载 修改.bashrc文件，在哪个用户目录下修改.bashrc就只会影响该用户 在最后添加 123export JAVA_HOME=/opt/jdkexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib 修改完成后，使用输入 12source ～/.basercjava -version 如果看见java信息说明安装成功 但是注销后进入发现运行的java不是sunjdk，而是openjdk，直接卸载openjdk，发现由于依赖关系，debian自动又下载了一个gcj-jdk，将依赖的libreoffice卸载后，sunjdk运行成功 配置maven环境同样修改.bashrc,在最后添加下面语句 1export PATH=$&#123;PATH&#125;:/opt/maven/bin 配置eclipseeclipse也是放在/opt目录下，没有修改，但是无法运行，报错缺少java运行时的环境。 解决方法，修改eclipse目录下的eclipse.ini文件，在最开始添加 12-vm/opt/jdk/bin 运行成功 安装mysql前往mysql下载页面根据版本下载mysql包 在mysql包下载目录下打开终端，输入 123dpkg -i mysql-apt-config_w.x.y-z_all.debapt-get updateapt-get install mysql-server 下载mysql server，中途会选择版本，输入管理员密码 修改mysql字符集，解决中文乱码问题编辑/etc/mysql/my.cnf，输入下面几句话 1234[client]default-character-set=utf8[mysqld]character-set-server=utf8 退出，使用service mysql stop 停止mysql 服务 然后在使用service mysql start 开启mysql服务 进入mysql 输入 1show variables like &quot;%char%&quot;; 查看字符集，如果都是utf8说明修改成功，如果失败，再去找找其他办法吧 下载msyql-workbench1apt install mysql-workbench 安装git1apt install git 安装visual studio code前往visual studio code官网，下载deb包 12dpkg -i codeXXXXX.debapt-get install -f 解决冲突问题 安装chrome下载文件包 1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 执行安装命令 1dpkg -i google-chrome-stableXXX.deb 解决依赖问题 1apt-get install -f 根据选择的架构不同，安装的chrome版本不同 安装hexonvm安装命令 1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装之后需要配置到用户环境变量 ~/.bashrc 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 下载最新的 Node 1nvm install stable hexo 安装命令 1npm install -g hexo-cli 安装pip3根据python版本，python2使用如下命令下载 1apt-get install python-pip python3 使用如下命令 1apt-get install python3-pip 安装jupyter notebookjupyter官方安装指南 更新 pip 1pip3 install --upgrade pip 下载 jupyter 1pip3 install jupyter 安装 jupyter 之后因该是可以直接启动，但是输入命令 jupyter notebook 无法正常启动，重启后输入命令 1jupyter notebook 可以正常启动 注意:如果在第 2 步安装 jupyter 时出错，无法导入 name 为 ‘main’ 可以尝试使用以下命令修复 1apt install --reinstall python3-requests 安装 idle31apt install idle3 安装 shadowsocks-qt5 客户端感谢网友提供的连接安装成功 安装 virtualbox[官方指南][https://www.virtualbox.org/wiki/Linux_Downloads] 先将virtualbox的源添加到主机，这里的mydist指的是你的系统名称 1deb https://download.virtualbox.org/virtualbox/debian `&lt;mydist&gt;` contrib 添加密钥到主机 12wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add - 更新源并下载virtualbox，并不是只能下载virtualbox5.2版本可以选择其他版本下载 12apt updateapt install virtualbox-5.2 安装 kazam1apt install kazam 安装 dia1apt install dia 安装dia有可能会遇到无法输入中文字符的问题，解决方法如下: 1231. 点击一个流程图下的图形2. 绘出图形3. 在图形上右键`-&gt;`Input Methods 选择X输入法 ssh如果是第一次使用ssh可以使用ssh-keygen生成密钥对 1ssh-keygen 然后使用ssh-copy-id 将公钥发送给远程主机 1ssh-copy-id username@ip-addr 然后在远程主机上将公钥文件名称修改为authorized_keys 接着使用ssh登陆远程主机，如果不行你也许还要做这一步 1ssh-add private-key 将你的私钥保存起来]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-方法引用]]></title>
    <url>%2F2018%2F01%2F07%2Fjava8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是方法引用方法引用是lambd表达式的一种特殊形式。看起来更易读更自然 如果想要对苹果的重量进行排序我们可以这样写: inventory.sort((a1,a2) -&gt; a1.getWeight() - a2.getWeight()); 使用方法引用之后是这样的 inventory.sort(Apple::getWeight); 方法引用的语法格式 指向静态方法的引用Class::staticMethod 指向现有对象的实例方法的方法引用object::instanceMethod 指向任意类型实例方法的方法引用Class::instanceMethod 语法简述指向静态方法的引用类的静态方法必须满足函数描述符，也就是Class.staticMethod的参数和返回值要和函数描述符一致 对于Function function = Class::staticMethod;Class的staticMethod的静态方法定义应该是: public static intstaticMethod(int number){ //一个返回int类型的代码块 } 对于Consumer consumer = Class:staticMethod;Class的staticMethod的静态方法定义应该是: public static void staticMethod(int number){ //没有返回值的代码块 } 对于Predicate pred = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static boolean staticMethod(int number){ //返回boolean类型的代码块 } 对于Supplier supplier = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static int staticMethod(){ //返回int类型的代码块 } 指向现有对象的实例方法的方法引用类的实例方法必须满足函数描述符，也就是对象调用的方法的参数和返回值要和函数描述法一致 对于Function function = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 如果是BiFunction function = object::instanceMethod;Class的实例方法定义应该是: public int instacneMethod(int number){ //返回int类型的代码块 } 下同 对于Consumer consumer = object::instanceMethod;Class的实例方法定义应该是: public void instacneMethod(int number){ //没有返回值的代码块 } 对于Predicate predicate = object::instanceMethod;Class的实例方法定义应该是: public boolean instanceMethod(){ //返回boolean类型的代码块 } 对于Suplier supplier = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 对于第三种格式，函数描述符至少含有一个参数，也就是说必须有一个参数用来调用方法 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(int number){ //返回int类型的代码块 } 对于Consumer consumer = Class::instanceMethod;Class的实例方法定义应该是: public void instanceMethod(){ //没有返回值的代码块 } 对于Comparator comparator = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(Class clazz){ //比较两个数大小的代码块，最后返回一个数用来表示大于，小于，等于 } 实例:使用方法引用来完成列表苹果的筛选，排序，输出，增加重量，返回对应的苹果重量列表 Apple.java public class Apple { private int weight; private String color; //getter setter } Main.java public class Main { public static void main(String[] args) { List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,&quot;green&quot;), new Apple(20,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(25,&quot;green&quot;)); List&lt;String&gt; strs = Arrays.asList( &quot;red&quot;,&quot;green&quot;,&quot;red&quot;,&quot;black&quot; ); //筛选 List&lt;Apple&gt; redApples = filter(inventory,Apple::getColor,&quot;red&quot;); forEach(redApples,System.out::println); List&lt;String&gt; red = filter(strs,String::toString,&quot;red&quot;); forEach(red,System.out::println); //将所有苹果的重量表示为一个列表 List&lt;Integer&gt; appleWeight = map(inventory,Apple::getWeight); forEach(appleWeight,System.out::println); //将所有苹果的重量加10 addWeight(inventory,Apple::getWeight,Apple::setWeight,10); forEach(inventory,System.out::println); //排序 inventory.sort(Comparator.comparing(Apple::getColor)); forEach(inventory,System.out::println); } public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } public static &lt;T&gt; void addWeight(List&lt;T&gt; inventory,ToIntFunction&lt;T&gt; func,ObjIntConsumer&lt;T&gt; consumer,int added) { for(T t : inventory) { consumer.accept(t,func.applyAsInt(t) + added); } } public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { result.add(func.apply(t)); } return result; } public static &lt;T,R&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Function&lt;T,R&gt; func,Object obj){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { if(func.apply(t).equals(obj)) { result.add(t); } } return result; } } 可以看见方法引用的可读性是要强于lanbda表达式的，如： List redApples = filter(inventory,Apple::getColor,”red”); 可以读作:筛选苹果库存中颜色为红色的苹果 inventory.sort(Comparator.comparing(Apple::getColor)); 可以读作:库存根据苹果的颜色进行排序但是方法引用在某些方面的比较复杂的，比如要将所有苹果的重量加10,需要使用两个方法引用 addWeight(inventory,Apple::getWeight,Apple::setWeight,10);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-函数式接口]]></title>
    <url>%2F2018%2F01%2F05%2Fjava8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在上一次使用自定义的函数接口来使用lambda表达式，每一个lambda都要自定义一个已知的接口来实现，这样比较麻烦，如果可以使用通用的函数式接口，那么会方便很多。幸运的是java8中新增了一些通用的函数式接口供我们使用。下面就来看看吧。 函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口 —《java核心技术卷I基础知识第10版》一言蔽之，只有一个抽象方法的接口称为函数式接口 —《java8实战》 java8提供了一系列通用的函数式接口，位于java.util.function包中 可以看见这个包中只有含有接口，没有任何的抽象类，类，这些接口都需于函数接口，不要慌张，这些接口大部分表达的意思相同，只有少量的区别 函数描述符函数式接口的抽象方法的签名基本上就是lambda表达式的签名。我们将这种抽象方法叫做函数描述符lambda表达式的参数和返回值都要和函数式接口的签名对应，比如说函数式接口ApplePredicate的签名就是接收一个Apple类型的参数返回一个boolean类型的参数所以基本上满足接收一个Apple类型返回一个boolean类型的lambda表达式都可以看作是ApplePredicate的实现 下面来介绍几个函数式接口 Consumer翻译过来为消费者，接收一个参数没有返回值。源码接口如下： public interface Consumer&lt;T&gt; { void accept(T t); } 使用Consumer来实现一个List的遍厉public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } //使用forEach遍历列表 forEach(redApples,apple -&gt; System.out.println(apple)); 其他Consumer系列接口 接口 抽象方法 DoubleConsumer void accept(double value); IntConsumer void accept(int value); LongConsumer void accept(long value); ObjDoubleConsumer&lt;T&gt; void accept(T t,double value); ObjIntConsumer&lt;T&gt; void accept(T t,int value); ObjLongConsumer&lt;T&gt; void accept(T t,int long value); BiConsumer&lt;T,U&gt; void accept(T t,U u); Predicate谓词，用来描述或判断客体性质等(百度百科),这里用来表示判断 Predicate接口有5个方法，包括4个默认方法，1个抽象方法，默认方法以后再说，这里主要关注抽现方法 接口源码如下,接收一个泛型参数，返回一个boolean型数据，至于根据什么返回，怎么判断交给用户来实现 public interface Predicate&lt;T&gt;{ boolean test(T t); } 使用Predicate来实现过滤 public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Predicate&lt;T&gt; pred){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) if(pred.test(t)) result.add(t); return result; } 筛选红色苹果 List&lt;Apple&gt; redApples = filter(inventory,(Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;)); forEach(redApples,apple -&gt; System.out.println(apple)); 其他Predicate系列接口 接口 抽象方法 DoublePredicate boolean test(double value); IntPredicate boolean test(int value); LongPredicate boolean test(long value); BiPredicate&lt;T,U&gt; boolean test(T t,U u); DoublePredicate,LongPredicate,IntPredicate分别是用来判断double,long,int类型，由于double,long,int类型在使用泛型时会有一个自动装箱拆箱的过程，这是为了提高效率实现的三个类,使用上和Predicate没有什么区别 Function函数，接收一个参数返回一个值 public interface Function&lt;T,R&gt;{ R apply(T t); } 使用Function来实现遍历列表，并对列表进行某种操作，操作后返回一个值 public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) result.add(func.apply(t)); return result; } 使用map来将列表中的所有苹果的重量返回并用列表返回 List&lt;Integer&gt; weights = map(inventory,(Apple apple) -&gt; apple.getWeight()); 其他Function系列接口 接口 抽象方法 DoubleFunction&lt;R&gt; R apply(double value); IntFunction&lt;R&gt; R apply(int value); LongFunction&lt;R&gt; R apply(long value); ToDoubleFunction&lt;T&gt; double apply(T value); ToIntFunction&lt;T&gt; int apply(T value); ToLongFunction&lt;T&gt; long apply(T value); BiFunction&lt;T,U,R&gt; R apply(T t,U u); ToDoubleBiFunction&lt;T,U&gt; double apply(T t,U u); ToIntBiFunction&lt;T,U&gt; int apply(T t,U u); ToLongBuFunction&lt;T,U&gt; long apply(T t,U u); 可以看见大多数接口都是为了解决基本类型的封箱拆箱进行优化的接口 Supplier供应商，没有参数，只有返回值。少有使用，这里只提供接口 接口 抽象方法 Supplier&lt;T&gt; T get(); BooleanSupplier boolean get(); DoubleSupplier double get(); IntSupplier int get(); LongSupplier long get(); 其他函数式接口java.util.function包中还有几个使用Operator结尾的接口，现在还不太明白如何使用，以后再加。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-lambda表达式]]></title>
    <url>%2F2018%2F01%2F04%2Fjava8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[测试环境 JDK 10 ，JUnit4 如何使用 lambda 表达式 定义一个只含有一个抽象方法的接口 AbstractFuncOfSingle (只能是接口) 123public interface AbstractFuncOfSingle &#123; int print(int a, int b);&#125; 传入两个int类型的参数，返回一个类型的参数 定义一个方法，传入参数为 AbstractFuncOfSingle 1234public void callAbstractFuncOfSingle(AbstractFuncOfSingle singleFunc, int a, int b)&#123; int result = singleFunc.print(a, b); System.out.println(result * 2);&#125; 在方法中将方法参数 a，b 作为参数传入 AbstractFuncOfSingle.print() 方法，并使用 result 接收返回参数然后打印 调用上述方法 1234567@Testpublic void testAbstractFuncOfSingle()&#123; callAbstractFuncOfSingle((a, b)-&gt;&#123; System.out.println(a + b); return a + b; &#125;, 10, 23);&#125; 使用 lambda 表达式创建一个内部类，打印 a + b 的和并返回 a + b 和 如果接口的抽象方法具有多个参数，那么 lambda 的传入参数个数也要一一对应，如果抽象方法具有返回值，在 lambda 表达式中也要有返回值，否则可以省略 return 语句注意：lambda 表达式的参数类型和返回类型要和抽象方法的参数类型和返回类型相同 lambda 表达式和匿名内部类lambda 表达式是匿名内部类的一种简化形式，lambda 表达式只能书写于只有一个抽象方法的接口，匿名内部类可以书写具有多个抽象方法的接口和抽象类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-tcp套接字编程]]></title>
    <url>%2F2017%2F12%2F28%2Fjava-tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是套接字传送们维基百科java中的套接字屏蔽了许多细节，不需要关注更多的底层信息。在java中套接字服务器可以使用java.net.ServerSocket创建一个常用的构造方法如下: 1ServerSocket server = new ServerSocket(int port); port: 表示套接字服务器需要监听的本机的端口，常见的端口有 80 端口，3306 端口等，这个监听的端口不允许重复监听，建议使用靠后面的端口号然后可以使用 Socket client = server.accept() 等待客户端的连接并返回一个 Socket 对象，通过这个 Socket 对象可以和客户端进行通信: 12OutputStream out = client.getOutputStream();InputStream in = client.getInputStream(); out 可以向客户端输出消息，in 可以接受客户端的消息（消息的输入和输出都是相对于内存而言的，如果是写入内存中，那么就是输入，如果是从内存中读出，那么就是输出） 服务器一般都是长时间运行服务多个客户端，所以服务器一般不会关闭，在客户端和服务器中端连接时，只需要关闭输入输出流就行了。 套接字客户端的创建使用 Socket 创建，需要指定要连接的 ip 地址和端口，这个端口要和套接字服务器监听的端口号相同，ip 地址要和套接字服务器所在主机的 ip 地址相同，linux 下可以使用 ifconfig 命令查看 ip 地址，如果是在本机进行套接字编程，可以使用 127.0.0.1 或者 localhost 确定本机 ip 1Socket socket = new Socket(Stirng ipAddress,int port); 创建套接字之后就可以获取输入输出流和服务器交流，这里的输入输出流是相对于客户端的输入输出，客户端的输入是服务器端的输出。 客户端不同于服务器，客户端关闭时需要关闭 Socket，使用 socket.close() 关闭 一个简单的服务器 Socket： 123456789101112131415//创建套接字服务器ServerSocket server = new ServerSocket(int port);//套接字服务器一般不会关闭，所以使用死循环不同的获取连接，在获取客户端连接是一般要开线程while(true)&#123; //获取客户端连接 Socket socket = server.accept(); //获取输入输出流,按情况获取，如果即需要输入也需要输出那么两个都需要获取，io可以包装成Reader和Writer OutputStream out = socket.getOutputStream();//获取输出流 InputStream in = socket.getInputStream();//获取输入流 //进行消息的获取或发送 //... //关闭输入输出流 out.close(); in.close();&#125; 简单的客户端套接字: 123456789101112131415//创建客户端套接字Socket socket = new Socket(String serverIp,int port);//获取输入输出流（一般来说客户端都是会先获取输出流发送消息到服务器，服务器返回消息，客户端使用输入流获取）OutputStream out = socket.getOutputStream();InputStream in = socket.getInputStream();//进行消息的发送与接收,可以使用死循环，在循环使用特殊字符串之类的东西退出while(true)&#123; //flag; //发送和接受&#125;//关闭输入输出流out.close();in.close();//关闭套接字socket.close(); 参考源码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax异步处理]]></title>
    <url>%2F2017%2F12%2F16%2Fajax%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[AJAX 异步处理AJAX异步处理基本操作,参考教程w3school AJAX是什么AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX可以在页面不刷新的情况更新局部页面，也可以在页面加载过程中先加载重要部分在加载不那么重要的部分，提高页面加载速度 AJAX工作流程AJAX基本对象 XMLHttpRequest是AJAX的基础，XMLHttpRequest 用于在后台与服务器交换数据 1. XMLHttpRequest的创建现代浏览器内置XMLHttpRequest对象使用如下方式创建 1xmlhttp = new XMLHttpRequest(); 老版本的IE浏览器不支持XMLHttpRequest对象，使用ActiveXObject对象创建: 1xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); 根据浏览器的不同使用不同的方式创建对象 123456var xmlhttp = null;if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();&#125;else&#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")&#125; 2. 使用AJAX发送请求使用的方法如下: 123456789open(method,url,async) 规定请求类型，URL，是否异步处理请求 method:请求类型;GET/POST url:要请求的连接;如www.google.com async:是否同步;true(异步)/false(同步)send(String) 发送请求到服务器 string:仅用于post请求setRequestHeader(header,value) 向请求添加HTTP头 header:规定头的名称 value:规定头的值 3. 获取响应涉及属性如下: responseText 获得字符串形式的相应数据 responseXML 获得XML形式的响应数据 4. onreadystatechange事件onreadystatechange是当AJAX请求发送到服务器时，根据服务器的处理进度进行反馈的标志 12345678910readyState 属性 存储XMLHttpRequest的状态，从0到4变化 0：请求为初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪status 200：“ok” 404：paga not foundonreadystatechange 存储函数名，在每次readyState变化时调用存储的函数 一个基本的请求相映模板12345678910111213141516function loadXMLDoc()&#123; var xmlhttp = null; if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest(); &#125;else&#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP") &#125; xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.state == 200 &amp;&amp; xmlhttp.readeyState == 4)&#123; //获取响应数据 var responseT = xmlhttp.responseText; &#125; &#125;; xmlhttp.open("GET","www.baidu.com",true); xmlhttp.send(null);&#125; 一个使用ajax发送到服务器，服务器使用spring-mvc返回JSON数据并在页面显示的实例源码]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fjson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[JSON是什么JSON：JavaScript 对象表示法（JavaScript Object Notation）。JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。参考w3school JSON实例{ &quot;employees&quot;: [ { &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; }, { &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; }, { &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; } ] } 使用python表示JSON实例one = {&quot;firstName&quot;:&quot;Bill&quot;,&quot;lastName&quot;:&quot;Gates&quot;} two = {&quot;firstName&quot;:&quot;George&quot;,&quot;lastName&quot;:&quot;Bush&quot;} three = {&quot;firstName&quot;:&quot;Thomas&quot;,&quot;lastName&quot;:&quot;Carter&quot;} employees = [one,two,three] o = {&quot;employess&quot;:employees} 使用java表示JSON实例Map&lt;String,String&gt; one = new HashMap&lt;&gt;(); Map&lt;String,String&gt; two = new HashMap&lt;&gt;(); Map&lt;String,String&gt; three = new HashMap&lt;&gt;(); one.put(&quot;firstName&quot;,&quot;Bill&quot;); one.put(&quot;lastName&quot;,&quot;Gates&quot;); two.put(&quot;firstName&quot;,&quot;George&quot;); two.put(&quot;lastName&quot;,&quot;Bush&quot;); three.put(&quot;firstName&quot;,&quot;Thomas&quot;); three.put(&quot;lastName&quot;,&quot;Carter&quot;); List&lt;Map&lt;String,String&gt;&gt; employees = new LinkedList&lt;&gt;(Arrays.asList(one,two,three)); Map&lt;String,List&lt;Map&lt;String,String&gt;&gt;&gt; o = new HashMap&lt;&gt;(); o.put(&quot;employees&quot;,employees); 可以发现JSON并没有什么神奇的地方，只不过是一群人定义的字符床规范格式而已，用的人多了就成了标准 将JSON转换为javascript对象 javascript 可以使用内置eval()函数将JSON数据生成原生的javascript对象var obj = eval(“(“ + JSON + “)”); JSON值有以下几种 数字(整数或浮点数)字符串(双引号中)逻辑值(true或false)数组(在方括号中)对象(在花括号中)null 使用本地JSON构建javascript对象实例可以在w3school找到，这里给出一个使用java:spring-mvc返回json对象并转换成javascript对象的实例spring-mvc返回JSOn数据参考源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-mvc返回json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fspring-mvc%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在使用spring-mvc过程中遇到很多问题，记录下来方便查看 开发环境如下: eclipse Oxygen Release (4.7.0) java1.8 spring 4.3.3 freemarker 2.3.26(这个不是必须的) maven依赖包如下：&lt;!-- spring mvc返回json所需依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- freemarker 引擎，有了这个就不需要使用jstl了，只需要使用freemarker表达式就行了 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring bean 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; web.xml 配置:&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动顺序，让这个Servlet随Servletp容器一起启动。 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!--会拦截URL中带“/”的请求。 --&gt; &lt;/servlet-mapping&gt; spring-mvc配置:&lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=&quot;canxing.web&quot; /&gt; spring-mvc配置freemarker:&lt;!-- freemarker 配置文件 --&gt; &lt;!-- freemarker config --&gt; &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/freemarker/&quot; /&gt; &lt;/bean&gt; &lt;!-- View resolvers can also be configured with ResourceBundles or XML files. If you need different view resolving based on Locale, you have to use the resource bundle resolver. --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; &lt;/bean&gt; JSONController.java:@Controller public class JSONController { @RequestMapping(path=&quot;/json&quot;,produces=&quot;application/json&quot;) public @ResponseBody User index() {//使用@RespnseBody将返回的对象转化为JSON数据 System.out.println(&quot;index start&quot;); User user = new User(); user.setUsername(&quot;canxing&quot;); user.setPassword(&quot;123&quot;); System.out.println(&quot;index end&quot;); return user; } @RequestMapping(path=&quot;/&quot;) public String test() { return &quot;test&quot;; } } User.java：//类不需要进行处理，只是一个普通的pojo类 public class User{ private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; } } test.flt:12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt; &lt;head&gt; &lt;title&gt;freemarker test &lt;/title&gt; &lt;script type="text/javascript"&gt; function loadXMLDoc() &#123; xmlhttp=null; if (window.XMLHttpRequest) &#123;// code for Firefox, Mozilla, IE7, etc. xmlhttp=new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; if (xmlhttp!=null) &#123; xmlhttp.onreadystatechange=state_Change; xmlhttp.open("GET","http://localhost:8080/spring_web_test/json",true); xmlhttp.send(null); &#125; else &#123; alert("Your browser does not support XMLHTTP."); &#125; &#125; function state_Change()&#123; var obj = eval("(" + xmlhttp.responseText + ")"); document.getElementById("username").innerHTML=obj.username document.getElementById("password").innerHTML=obj.password &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;freemarker test&lt;/h1&gt; username : &lt;span id='username'&gt;&lt;/span&gt;&lt;br&gt; password : &lt;span id='password'&gt;&lt;/span&gt;&lt;br&gt; &lt;button type='button' onclick="loadXMLDoc()"&gt;adfads&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; spring-mvc返回JSOn数据参考源码 寻找答案中遇到的问题 依赖问题，spring 默认的对象转化为 json 的 jar 包依赖，网上多是直接使用并没有说明依赖 还是依赖问题，spring 和 jackson 之间版本的兼容性太差，稍微更改以下 jackson 或者 spring 的版本就会导致 NoSuchMethodError 错误，据说这里可以看见版本支持，但是看不懂]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>java</tag>
        <tag>json</tag>
        <tag>spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述二-栈]]></title>
    <url>%2F2017%2F12%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%8C-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈又称堆栈，仅允许在表的一端进行插入和删除操作的线性表，该位置位于表尾，称为栈顶(Top)，相对地，另一端称为栈底。由于栈的插入和删除运算只能在栈顶一端进行，后进栈元素必定先出栈，所以把栈称为后进先出表(last in first out 简称 LIFO) 这里使用链表实现栈 栈的定义12345678910111213141516171819//头文件中的函数定义struct Node;typedef struct Node *PtrToNode;typedef PtrToNode Stack;typedef int ElementType;int IsEmpty(Stack S);//判断栈是否为空Stack CreateStack(void);//创建一个空栈void MakeEmpty(Stack S);//删除栈中的所有数据void Push(ElementType X,Stack S);//将数据压入栈栈有两种实现方式，一种使用顺序表，另一种使用链表方式实现ElementType Top(Stack S);//返回栈顶的数据void Pop(Stack S);//弹出栈顶的元素void printStack(Stack S);//遍历栈//具体实现文件中栈节点的定义，使用int类型typedef int ElementType;struct Node&#123; ElementType Element; PtrToNode Next;//因为是使用链表，所以这个执行下一个节点地址&#125;; 栈的实现栈的主要操作集中在Push和Pop操作，前者向栈中压入一个数据，后者从栈中弹出一个数据 Push功能实现12345678void Push(ElementType X,Stack S)&#123; PtrToNode Node; Node = (PtrToNode)malloc(sizeof(struct Node)); if(Node == NULL) return; Node-&gt;Element = X; Node-&gt;Next = S-&gt;Next; S-&gt;Next = Node;&#125; Pop功能实现1234567void Pop(Stack S)&#123; if(IsEmpty(S)) return; PtrToNode temp = S-&gt;Next; S-&gt;Next = temp-&gt;Next; temp-&gt;Next = NULL; free(temp);&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述一-链表]]></title>
    <url>%2F2017%2F12%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%80-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表由一系列不必在内存中相连的结构组成，每一个结构单元均含有表元素和指向包含该元素后继元素的结构的指针 如图所示 链表可以有两种表现形式，一种是带有头节点的链表(如上图所示)，另一种是不带有头节点的链表，一般来说带有头节点的链表很多时候处理起来比不带头节点的方便，因此这里选择带有头节点的链表展示 链表定义如下: 123456789101112131415161718192021222324252627//头文件中定义struct Node;typedef struct Node *PtrToNode;typedef PtrToNode List;typedef PtrToNode Position;typedef struct ElementType ElementType;List MakeEmpty(List L);int IsEmpty(List L);int IsLast(Position P,List L);Position Find(ElementType X,List L);void Delete(ElementType X,List L);Position FindPrevious(ElementType X,List L);void Insert(ElementType X,List L,Position P);void DeleteList(List L);Position Header(List L);Position First(List L);void printList(List L);//在具体的实现文件中定义每个节点中的数据，这里选择int类型的数据struct ElementType&#123; int data;&#125;;struct Node&#123; ElementType Element; Position Next;&#125;; 主要功能实现链表中稍微复杂的功能主要集中在删除和插入操作，删除和插入功能主要涉及到链表指针的移动以及内存的分配和释放 当链表删除时，就需要调整指针，将删除节点的前驱节点的后继指针指向删除节点的后继节点，并释放删除节点所占用的内存空间 当链表插入元素时，需要分配内存空间，创建一个新的节点，并将指定节点的后继指针指向新增节点，再把新增节点的后继指针指向原来指定节点的后继节点 链表插入操作实现代码12345678void Insert(ElementType X,List L,Position P)&#123; Position ptr ; ptr = (Position)malloc(sizeof(struct Node)); if(ptr == NULL) exit(0); ptr-&gt;Element = X; ptr-&gt;Next = P-&gt;Next; P-&gt;Next = ptr;&#125; 链表删除操作实现代码12345678910111213void DeleteList(List L)&#123; if(L == NULL || L-&gt;Next == NULL) return; Position ptr = NULL; Position temp = NULL; ptr = L-&gt;Next; L-&gt;Next = NULL; while(ptr != NULL)&#123; temp = ptr; ptr = ptr-&gt;Next; temp-&gt;Next = NULL; free(temp); &#125;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下gpg的基本使用]]></title>
    <url>%2F2017%2F12%2F10%2Fubuntu%E4%B8%8Bgpg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是gpg 课程实验需要使用pgp对文件进行加密解密操作，pgp是一套用于消息加密、验证的应用程序，采用IDEA的散列算法作为加密与验证之用,但是pgp是商业软件不能自由使用，所以有自由软件基金会开发一个pgp的替代品，取名GnuPG，这就是gpg。 安装gpg 在ubuntu16.04下gpg已经安装好了，可以使用如下命令gpg -h如果输出有gpg的帮助文档，那么就有gpg，如果没有可以前往 gnupg官网 页面下载 gpg 基本使用 1.生成密钥 输入以下命令开始生成密钥对 gpg --gen-key *选择密钥种类，默认选择1,使用RSA and RSA算法，表示加密和签名都使用RSA算法然后选择要使用的密钥长度默认为2048,密钥长度越长，越安全，由于是课程实验，所以使用默认值选择密钥的有效期，由于是课程实验，所以选择永不过期，如果是要上传到服务器上，按情况自行选择有效期系统确认输入真实姓名电子邮箱注释然后生成用户标识然后系统最后确认接着系统让你设置一个私钥密钥，用来保护私钥接着系统生成密钥，需要大量的随机字节，按系统提示等一下就会生成密钥 2.检查密钥 查看本机密钥 gpg --list-keys 3.输出密钥 输出公钥 gpg -a -o public-key.txt --export [用户标识(可以是密钥id，就是使用gpg --list-key 查看到的密钥id)] 输出私钥 gpg -a -o private-key.txt --export-secret-keys ##4.上出公钥 由于是课程实验，所以并没有上传（其实是不知道什么原因，无法上传到服务器) 5.导入密钥 gpg --import [密钥文件] 也可以到公钥服务器上寻找(未验证) gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户id] 注意： 使用手动导入公钥会出现无法认证的问题，可以使用 gpg --fingerpring 打印指纹，指纹是每对密钥生成的时候生成的，查看指纹后可以通过电话或者其他方式到提供者验证指纹 然后使用以下命令 gpg --sign-key [公钥id] 或者使用如下命令删除 gpg --delete-keys [公钥id] 6.公钥加密 gpg -r [用户id] -o [输出文件] -e [加密文件] -r 接受者的公钥的id，可以是邮箱 -o 输出加密后的文件名 -e 要执行加密操作的数据 7.解密 gpg [解密文件] gpg 有一个默认选择 -d 默认使用你的私钥解密别人使用你的公钥解密传送过来的数据 8.数字签名 gpg -s [文件名] 生成一份签名 gpg --clearsign [文件名] 生成一份明文签名 gpg -a -b [文件名] 生成一份分离的明文签名(去掉-a就是二进制签名) 9.验证签名 gpg --verify [被签名的文件] 参考文章 http://www.ruanyifeng.com/blog/2013/07/gpg.html http://www.williamlong.info/archives/3439.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pgp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github+hexo的个人博客]]></title>
    <url>%2F2017%2F12%2F09%2F%E5%9F%BA%E4%BA%8Egithub-hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基于github+hexo的个人博客1. 本地环境配置 操作系统为 ubuntu16.04 1. git 使用 sudo apt install git下载git 2. node.js 安装命令 wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh nvm install stable 3. hexo npm install -g hexo-cli 安装hexo hexo安装 2. github 配置 前往github主页新建一个仓库，仓库名为 xxx.github.io(到时候通过xxx.github.io就可以访问个人博客，xxx最好是和github账户名相同，不同不知道是否可以) 3.创建本地文件资源 在/home/canxing/目录下创建保存博客资源文件夹 makir myblog 使用hexo初始化 hexo init ~/myblog 进入myblog文件夹 生成hexo所需要的文件目录 npm install 使用 hexo s 命令开启hexo服务，并通过localhost:4000 就可以访问一个初始的模板 4. 配置hexo hexo文件夹根目录下的_config.yml 文件为hexo的配置文件官方配置参数参考配置说明 部分参数说明如下 title:网站主标题 subtitle: 子标题 description: 网站描述 author: 作者 language: zh_CN timezone: 时区，没有设置为本地时区设置 url: 你的网站域名 root: 根路径 permalink:生成的链接的格式 theme:生成的博客系统样式，就是视图表示，可以前往hexo样式选择喜欢的样式然后使用git clone到本地 deploy: 部署选项，包括部署类型，仓库url，分支等 type: git repo: 仓库url branch: 一般是master 5. hexo预览和部署 hexo s开启hexo服务器，在网页中可以输入localhost:4000可以查看预览 hexo g生成新的文件资源 hexo d部署到github上，部署路径为_config.yml文件中的deploy的选项]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
