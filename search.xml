<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring-Cloud-一-开始]]></title>
    <url>%2F2019%2F05%2F05%2Fspring-cloud-%E4%B8%80-%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[Spring Cloud 开始]]></content>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell基础]]></title>
    <url>%2F2018%2F11%2F28%2Fshell%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Shell 基础 Shell 脚本的第一行用于指定该脚本用什么解释器执行。通过命令 cat /etb/shells 可以查看当前系统安装了哪些解释器，然后在脚本第一行输入 #! /bin/bash 指定解释器，/bin/bash 是通过查看 /etc/shells 文件得到的，不同的机器上可能有不同的脚本 变量 定义变量 使用变量 只读变量 删除变量 变量类型 字符串变量 获取字符串长度 提取子字符串 数组变量 传递参数 运算符 算数运算符 关系运算符 布尔运算符 逻辑运算符 字符串运算符 文件测试运算符 控制流 if-else for while until 函数 变量定义变量在 Shell 中定义变量，不需要指定变量类型，也不需要修饰变量。直接使用 变量名=值 的形式即可对变量进行赋值。 1your_name="canxinglook.cn" 和其他编程语言不同的是，Shell 定义变量时，= 左右两边不能有空格 使用变量要使用一个定义过的变量，只要在变量前加 $ 即可。 1234567echo $your_nameecho "i am $your_name"echo i am $your_nameecho $&#123;your_name&#125;echo i am $&#123;your_name&#125;echo "i am$&#123;your_name&#125;" 变量名称外可以加花括号，加不加都行，但是在某些情况下，需要加花括号对变量边界加以限制 为了保持统一，建议使用变量都加上花括号 只读变量Shell 提供了 readonly 关键字将一个变量声明为只读变量，声明之后的变量值将不能在改变。 删除变量Shell 使用 unset 关键字删除一个变量，unset 关键字不能删除只读变量。删除之后的变量可以重新赋值。 123456your_name="canxinglook.cn"echo $your_nameunset your_nameecho $&#123;your_name&#125;your_name="tom"echo $&#123;your_name&#125; 变量类型运行 Shell 时，会存在三种变量: 局部变量: 在脚本或命令中定义，仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问 环境变量: 所有程序，包括 Shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。 Shell 变量: Shell 变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行。 字符串变量字符串是 Shell 编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。虽然单引号和双引号都可以表示一个字符串，但是在使用上还存在一些不同。 单引号的限制: 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 在字符串定义上，尽量使用双引号不要使用单引号。 获取字符串长度使用 1$&#123;#&lt;string&gt;&#125; 即可获取字符串长度，其中 &lt;string&gt; 为字符串。 123your_name='abcdefg'len=$&#123;#your_name&#125;echo $&#123;len&#125; 提取子字符串提取子字符串使用 ${&lt;string&gt;:&lt;startIndex&gt;:&lt;offset&gt;} 从 string 的 startIndex 位置开始提取 offset 个字符返回。其中 &lt;string&gt; 为被提取的字符串;&lt;startIndex&gt; 为提取开始位置，字符串的第一个字符下标为 0; &lt;offset&gt; 为提取个数，包括开始位置的那个字符串。 123your_name='abcdefg'subStr=$&#123;your_name:1:2&#125;echo $&#123;subStr&#125; 数组变量Shell 中定义一个数组可以使用下面三种方式。 12345678910111213array_name=("abc" "defg" "1234")array_name=("111""222""333")array_name=()array_name[0]="aaaaa"array_name[1]="bbbbbb"array_name[2]="ccccc"array_name[3]="ddddddd" Shell 使用一对括号 () 来定义一个数组，数组中的每个元素使用空格分割。数组元素下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或表达式，其值应该大于或等于 0。 获取数组元素使用 {&lt;array-name&gt;[&lt;index&gt;]}，其中 &lt;array-name&gt; 为一个数组变量，&lt;index&gt; 表示数组下标。 123array_name=("aaaaaa", "bbbbb" "cccccc" "ddddddddd")echo $&#123;array_name[0]&#125;echo $&#123;array_name[2]&#125; 获取数组中的所有元素使用 {&lt;array-name&gt;[@]} 或者 {&lt;array-name&gt;[*]} 123array_name=("aaaaaa", "bbbbb" "cccccc" "ddddddddd")echo $&#123;array_name[@]&#125;echo $&#123;array_name[*]&#125; 获取数组长度获取数组长度使用 12$&#123;#&lt;array-name&gt;[@]&#125;$&#123;#&lt;array-name&gt;[*]&#125; 其中 &lt;array-name&gt; 为数组变量 12345array_name=("aaaaaa", "bbbbb" "cccccc" "ddddddddd")length=$&#123;#array_name[@]&#125;len=$&#123;#array_name[*]&#125;echo $&#123;length&#125;echo $&#123;len&#125; 传递参数在执行 Shell 脚本时，可以向脚本传递参数，脚本内获取参数的方式为 $n，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，0 为执行脚本的名称。 1234echo "执行脚本的名称为 $0"echo "执行脚本的第一个参数为 $1"echo "执行脚本的第二个参数为 $2"echo "执行脚本的第三个参数为 $3" 执行脚本命令 ./test 1 2 3 输出为 1234执行脚本的名称为 ./test.sh执行脚本的第一个参数为 1执行脚本的第二个参数为 2执行脚本的第三个参数为 3 另外 Shell 还有几个特殊字符用来处理参数 参数说明 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程 ID $! 后台运行的最后一个进程的 ID $@ 与 $* 相同，但是使用时加引号，并在引号中返回每个参数。 $- 现实 Shell 使用的当前选项，与 set 命令相同 $? 显示最后命令的退出状态，0 表示没有错误，其他任何值表示有错误。 运算符算数运算符Shell 不支持原生的数学运算，但是可以通过其他命令来实现，最常用的就是 expr 运算符 说明 expr $a + $b 加法运算 expr $a - $b 减法运算 expr $a \* $b 乘法运算 expr $a / $b 除法运算 expr $a % %b 取余运算 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字 运算符 说明 实例 -eq 相等返回 true，不相等返回 false [ $a -eq $b ] -ne 不相等返回 true，相等返回 false [ $a -ne $b ] -gt 大于返回 true，不大于返回 false [ $a -gt $b ] -lt 小于返回 true，不小于返回 false [ $a -lt $b ] -ge 大于等于返回 true，小于返回 false [ $a -ge $b ] -le 小于等于返回 true，大于返回 false [ $a -le $b ] 布尔运算符 运算符 说明 实例 ! 非运算 [ !false ] -o 或运算 [ $a -lt 200 -o $b -ge 10 ] -a 与运算 [ $a -lt 200 -a $b -ge 10 ] 逻辑运算符 运算符 说明 实例 &amp;&amp; and [[ $a -lt 200 &amp;&amp; $b -ge 10 ]] _ _ or `[[ $a -lt 200 $b -ge 10 ]]` 字符串运算符 运算符 说明 实例 = 相等返回 true，不相等返回 false [ $a = $b ] != 不相等返回 true，相等返回 false [ $a != $b ] -z 字符串长度为 0 返回 true，不为 0 返回 false [ -z $a ] -n 字符串长度不为 0 返回 true，为 0 返回 false [ -n $a ] str 字符串不为空返回 true [ $a ] 文件测试运算符 操作符 说明 举例 -b 如果文件是块设备文件，返回 true。 [ -b $file ] 返回 false。 -c 如果文件是字符设备文件，返回 true。 [ -c $file ] 返回 false。 -d 如果文件是目录，返回 true。 [ -d $file ] 返回 false。 -f 如果文件是普通文件，返回 true。 [ -f $file ] 返回 true。 -g 如果文件设置了SGID 位，返回 true。 ` [ -g $file ]` 返回 false。 -k 如果文件设置了粘着位，返回 true。 [ -k $file ] 返回 false。 -p 如果文件是有名管道，返回 true。 [ -p $file ] 返回 false。 -u 如果文件设置了 SUID 位，返回 true。 [ -u $file ] 返回 false。 -r 如果文件可读，返回 true。 [ -r $file ] 返回 true。 -w 如果文件可写，则返回 true。 [ -w $file ] 返回 true。 -x 如果文件可执行，返回 true。 [ -x $file ] 返回 true。 -s 如果文件不为空，返回 true。 [ -s $file ] 返回 true。 -e 如果文件（包括目录）存在，返回 true。 [ -e $file ] 返回 true。 控制流 和其他编程语言一样可以使用 break 和 continue 来跳出循环 if-elseif 语句语法如下: 12345678910111213if condition1then command1elif condition2then command2elif condition3then command3...else command4fi if 语句以 if condition1; then 开始，fi 结束，elif 和 else 都是可选的。 forfor 语句语法如下: 1234for &lt;var&gt; in item1 item2 item3 ... itemndo commanddone 遍历一个数组需要使用 ${array[@]} 获取所有数组元素 12345array=('111' '222' '333')for item in $&#123;array[@]&#125;do echo $&#123;item&#125;done whilewhile 语句语句如下: 1234while conditiondo commanddone 实例如下 123456i=1while [[ $i -le 5 ]]do echo $i i=`expr $i + 1`done untiluntil 语句执行一些语句直到条件为 true 时停止 until 语法如下: 1234until conditiondo commanddone casecase 语句为多选择语句，类似其他语句中的 switch 语句。case 语句语法如下: 123456789101112131415case &lt;val&gt; in &lt;val1&gt;) command1 ;; &lt;val2&gt;) command2 ;; &lt;val3&gt;) command3 ;; ... *) commandn ;;esac 函数定义函数的语法如下: 1234[function] funname [()] &#123; command [return value;]&#125; 其中带有 [] 都是可选的 要调用函数直接使用函数名称即可。 1234567891011function func () &#123; read num case $&#123;num&#125; in 1) echo "你选择了 1" ;; *) echo "$&#123;num&#125;" ;; esac&#125;func 如果要传递参数到函数中，只需要在函数名称后加上参数即可 1234function func () &#123; //command&#125;func 1 2 3 4 5 要从函数内部获取传入的参数，需要借助几个特殊字符。 参数说明 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程 ID $! 后台运行的最后一个进程的 ID $@ 与 $* 相同，但是使用时加引号，并在引号中返回每个参数。 $- 现实 Shell 使用的当前选项，与 set 命令相同 $? 显示最后命令的退出状态，0 表示没有错误，其他任何值表示有错误。]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 基本命令]]></title>
    <url>%2F2018%2F11%2F27%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[linux 基本命令参考资料: Linux 命令搜索，Linux man 指令 安装和登录命令 login shutdown halt reboot mount umount chsh 文件处理命令 file mkdir grep dd find mv ls diff cat ln 系统管理相关命令 df top free quota at lp adduser groupadd kill crontab tar unzip gunzip last 网络操作命令 ifconfig ip ping netstat ftp route rlogin rcp finger mail nslookup 系统安全相关命令 passwd su umask chgrp chmod chown chattr sudo ps who 安装和登录命令login作用: 登陆系统或切换用户身份 补充说明: login 命令 用于给出登录界面，可用于重新登录或者切换用户身份，也可通过它的功能随时更换登入身份。在 Slackware 发行版中 ，您可在命令后面附加欲登入的用户名称，它会直接询问密码，等待用户输入。当 /etc/nologin 文件存在时，系统只 root 帐号登入系统，其他用户一律不准登入。 语法: 123login [-p] [-h 主机] [用户名] [ENV=VAR...]login [-p] [-h 主机] [-f 名称]login [-p] -r 主机 选项: 1234567-f 不要执行认证，用户已经预认证过。 注意：此时，username 是强制的。-h 此登录的远程主机名。-p 保留环境。-r 为 rlogin (远程登录)执行 autologin (自动登录)协议。-r, -h and -f 只能用于 root 使用 login 时。 一般用于当前主机切换用户，远程连接使用 SSH 即可。 shutdown作用: 系统关机命令 补充说明: shutdown 以一种安全的方式关闭系统。所有登陆用户都可以看到关机信息提示，并且 login(1) 将被阻塞。可以指定立刻关机，也可以指定系统在一定的延时后关机。所有进程都将接收到 SIGTERM 信号。这可以使 vi(1) 等程序有时间将处于编辑状态的文件进行存储，邮件和新闻程序进程则可以将所有缓冲池内的数据进行适当的清除等等。 语法: 1shutdown [-t sec] [-arkhncfF] time [warning-message] 选项: 123456789-a 使用 /etc/shutdown.allow 来验证身份。-t sec 通知 init(8) 在转换到其它运行级别前，发送警告 (warning) 信号后延时 (sec) 秒数后再发送关闭 (kill) 信号。-k 并非真正关机，只向所有人显示警告信息。-r 重启。-h 停机。-n [DEPRECATED(不应再使用)] 不调用 init(8) 程序进行关机操作，而由自己进行。不建议用户使用这种关机方式，它的结果一般也不是你希望的那样。-f 重启时跳过磁盘检测。-F 重启时强制磁盘检测。-c 取消运行中的 shutdown 进程。不可能为此选项指定 time 参数，但你可以在命令行输入一条解释消息来向所有用户说明。(一般的shutdown指令可以用按“+”号来进行中断) 关机指令，在 11:50 关机 1shutdown -h 11:50 重启指令，在 11:50 关机 1shutdown -r 11:50 取消 shutdown 指令 1shutdown -c 更多指令请使用 man shutdown 查看 halt作用: 关机指令 补充说明: 作为兼容传统的命令存在 语法: 1halt [OPTINS...] 选项: 123456789--help 显示简短的帮助信息并退出。--halt 停机(关闭系统但是不切断电源)-p, --poweroff 关机(关闭系统并且切断电源)--reboot 重新启动-f, --force 强制立即停机/关机/重新启动， 而不与 init 进程通信。-w, --wtmp-only 仅向 wtmp 中写入一条关机记录， 而不实际执行关机动作。-d, --no-wtmp 不向 wtmp 中写入任何关机记录-n, --no-sync 在关机前不刷写磁盘缓存--no-wall 在关机前不发送警告信息 reboot作用: 重启指令 补充说明: 作为兼容传统的命令存在 语法: 1reboot [OPTINS...] 选项: 123456789--help 显示简短的帮助信息并退出。--halt 停机(关闭系统但是不切断电源)-p, --poweroff 关机(关闭系统并且切断电源)--reboot 重新启动-f, --force 强制立即停机/关机/重新启动， 而不与 init 进程通信。-w, --wtmp-only 仅向 wtmp 中写入一条关机记录， 而不实际执行关机动作。-d, --no-wtmp 不向 wtmp 中写入任何关机记录-n, --no-sync 在关机前不刷写磁盘缓存--no-wall 在关机前不发送警告信息 mount作用: 挂在文件系统 补充说明: 语法: 1234mount [-l|-h|-V]mount -a [-fFnrsvw] [-t fstype] [-O optlist]mount [-fnrsvw] [-o options] device|dirmount [-fnrsvw] [-t fstype] [-o options] device dir 选项: 12345678910111213141516171819202122232425-V：显示程序版本-h：显示辅助讯息-v：显示较讯息，通常和 -f 用来除错。-a：将 /etc/fstab 中定义的所有档案系统挂上。-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。-s-r：等于 -o ro-w：等于 -o rw-L：将含有特定标签的硬盘分割挂上。-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。-o sync：在同步模式下执行。-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。-o auto、-o noauto：打开/关闭自动挂上模式。-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.-o dev、-o nodev-o exec、-o noexec允许执行档被执行。-o suid、-o nosuid：允许执行档在 root 权限下执行。-o user、-o nouser：使用者可以执行 mount/umount 的动作。-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。-o ro：用唯读模式挂上。-o rw：用可读写模式挂上。-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 常用命令: 挂载一个文件系统 1mount /dev/sdc1 /media/store umount作用: 卸载文件系统 补充说明: umount 命令 用于卸载已经加载的文件系统。利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。 语法: 123umount [-hV]umount -a [-nrv] [-t vfstype]umount [-nrv] device | dir [...] 选项: 12345678-V 打印版本信息并退出。-h 显示帮助信息并退出。-v 以冗长模式运行。-n 在卸载后不将相应信息写入 /etc/mtab 文件。-r 如果卸载失败，试图以只读方式进行重新挂载。-a 卸载所有在 /etc/mtab 文件中描述的文件系统。（在 umount 版本或以后的版本中，不会卸载 proc 文件系统）-t vfstype 只卸载指定类型的文件系统。如果要一次指定多个文件系统， 可以用逗号分隔。如在指定文件系统前加 no ，则可卸载除些文件系统以外的其它文件系统。-f 强制卸载（比如不可达的 NFS ）。 （此选项须在高于 2.1.116 的版本上使用） 常用命令 通过设备名卸载 1umount /dev/sdc1 通过挂载点卸载 1umount /media/store 卸载并弹出 1eject /media/store chsh作用: 更改登录 shell 补充说明: chsh 命令 用来更换登录系统时使用的 shell。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。 语法: 1chsh [选项] [登录] 选项: 123-h, --help 现实帮助信息并退出。-R, --root CHROOT_DIR Apply changes in the CHROOT_DIR directory and use the configuration files from the CHROOT_DIR directory.-s, --shell SHELL 用户的新登录 shell 的名称。将此字段设置为空会让系统选择默认的登录 shell。 查看系统安装了哪些 shell 可以使用 cat /etc/shells 命令查看 文件处理命令file作用: 用来探测给定文件的类型。 补充说明: file 命令 用来探测给定文件的类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。 语法: 1file [ -bcnsvzL ] [ -f 命名文件 ] [ -m 幻数文件 ] file ... 选项: 123456789 -b 不输出文件名 (简要模式). -c 检查时打印输出幻数文件的解析结果.常与 -m 一起使用，用来在安装幻数文件之前调试它. -f 命名文件 从在参数表前的 命名文件 中读出将要检查的文件名(每行一个文件).要有 命名文件 ，或者至少有一个文件名参数; 如果要检查标准输入, 使用``-&apos;&apos;作为文件参数.-m list 指定包含幻数的文件列表.可以是单个文件，也可以是 用冒号分开的多个文件.-n 每检查完一个文件就强制刷新标准输出. 仅在检查一组文件时才有效. 一般在将文件类型输出到管道时才采用此选项.-v 打印程序版本并退出.-z 试图查看压缩文件内部信息.-L (在支持符号链接的系统上)选项显示符号链接文件的原文件, 就像 ls(1) 命令的like-named 选项.-s 通常, file 只是试图去检查在文件列表中那些 stat(2) 报告为正常文件的文件的类型.由于读特殊文件将可能导致 不可知后果，所以这样可以防止发生问题.使用 -s 选项时 file 命令也将去读文件列表中的块特殊文件和字符特殊文件. 一般用于从原始磁盘分区中获得文件系统类型，此文件为块 特殊文件. 这个选项也导致 file 命令忽略 stat(2) 报告的文件大小，因为在有些系统中原始磁盘分区的大小报告为0. mkdir作用: 创建目录 补充说明: 语法: 1mkdir [选项]... 目录列表... 选项: 1234567-m, --mode=模式 设置文件模式(类似chmod)，而不是 rwx 减 umask-p, --parents 如果目录已存在，不报错，且按需创建父目录-v, --verbose 为每一个已创建的目录打印信息-Z 将每个创建的目录的 SELinux 安全上下文设置为默认类型--context[=CTX] 类似 -Z，或者如果指定了上下文，则将 SELinux 或者 SMACK 安全上下文设置为指定类型--help 显示此帮助信息并退出--version 显示版本信息并退出 常用命令 创建目录指定权限 1mkdir -m 777 /opt/test 如果创建目录的上级目录不存在，先创建上级目录在创建指定目录 1mkdir -p /test/opt/test grep作用: 文件搜索工具 补充说明: grep （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。 语法: 12grep [options] PATTERN [FILE...]grep [options] [-e PATTERN | -f FILE] [FILE...] 选项: 1太多了，使用 man grep 查看 常用命令 一般 grep 配置 Linux 管道进行搜索 1cat test.txt | grep pattern 不输出匹配行，改为输出匹配的行数 1cat test.txt | grep -c pattern dd作用: 转换和拷贝文件 补充说明: dd 命令 用于复制文件并对原文件的内容进行转换和格式化处理。dd 命令功能很强大的，对于一些比较底层的问题，使用 dd 命令往往可以得到出人意料的效果。用的比较多的还是用 dd 来备份裸设备。但是不推荐，如果需要备份 oracle 裸设备，可以使用 rman 备份，或使用第三方软件备份，使用 dd 的话，管理起来不太方便。 语法: 1dd [--help] [--version] [if=file] [of=file] [ibs=bytes] [obs=bytes] [bs=bytes] [cbs=bytes] [skip=blocks] [seek=blocks] [count=blocks] [conv=&#123;ascii, ebcdic, ibm, block, unblock, lcase, ucase, swab, noerror, notrunc, sync&#125;] 选项: 12345678910111213141516171819202122if=file 从 file 中读而不是标准输入。of=file 写到 file 里去而不是标准输出。除非指定 conv=notrunc ，否则， dd 将把 file 截为O字节（或由 seek= 选项指定的大小）ibs=bytes 一次读 bytes 字节。默认是512。obs=bytes 一次写 bytes 字节。默认是512。bs=bytes 一次读和写 bytes 字节。这将覆盖 ibs 和 obs 设定的值（并且，设定 bs 不等于同时将 ibs 和 obs 设为同一个值，至少在 只使用 sync, noerror 或 notrunc 转换时是这样的。因为bs规定，每个输入块都应作为单独 的数据块拷贝到输出，而不把较短的块组合到一起）。cbs=bytes 为 block 转换和 unblock 转换指定转换块的大小。skip=blocks 在拷贝之前，跳过输入文件的前 blocks 块，每块大小为 ibs-byte 字节。seek=blocks 在拷贝之前，跳过输出文件的前 blocks 块，每块大小为 obs-byte 字节。count=blocks 只拷贝输入文件的前 blocks 块（每块的大小为 ibs-byte 字节），而不是全部内容，直到文件末尾。conv=转换&quot;[,&quot;转换&quot;]...&quot; 将文件按 转换 参数指定的方式转换（在“,”两边没有空格）。 转换方式包括： ascii 将 EBCDIC 转换成 ascii。 ebcdic 将 ascii 转换成 ebcdic。 ibm 将 ascii 转换成 alternative ebcdic。 block 每一行输入，无论长短，输出都是 cbs 字节，并且其中的“换行”（NEWLINE，即c中的&apos;0）用 空格替换。如有必要，行尾会填充空格。 unblock 用“换行”替换每个输入块（ cbs 字节大小）末尾的空格。 lcase 将大写字母转换成小写。 ucase 将小写字母转换成大写。 swab 交换每对输入字节。如果读入的字节数是奇数，最后 一个字节只是简单的复制到输出（因为没有能跟它交换的 字节了）（POSIX 1003.26，PASC翻译1003.2 3号和4号）。 noerror 发生读错误时，继续进行。 notrunc 不截断输出文件。 sync 用0填充到每个输入块的末尾，使其大小为 ibs 字节。 常用命令 制作 Linux 镜像 1dd if=/home/ubuntu.iso of=/mnt/usb_device find作用: 查找文件 补充说明: 用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法: 1find [path...] [expression] 选项: 1太多了，使用 man find 查看 常用命令 列出当前目录及子目录下的所有文件和文件夹 1find . 在 home 目录下查找以 .txt 结尾的文件名 1find /home -name "*.txt" 在 home 目录下查找以 .txt 结尾的文件名，但忽略大小写 1find /home -iname "*.txt" 在当前目录查找所有以 .txt 和 .pdf 结尾的文件 1find . -name "*.txt" -o -name "*.pdf" 更多参考命令点击这里。 mv作用: 移动文件 补充说明: mv 命令 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source 表示源文件或目录，target 表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。 语法: 123mv [选项]... 源文件 目标文件mv [选项]... 源文件... 目录mv [选项]... --target-directory=DIRECTORY SOURCE... 选项: 1234567891011121314151617--backup[=CONTROL] 为现有的每一个目标文件作一个备份-b 和--backup一样但是不接受参数-f, --force 覆盖前永不提示-i, --interactive 覆盖前提示--strip-trailing-slashes 删除任何“源文件”参数后面跟随的斜杠-S, --suffix=SUFFIX 省略一般的备份后缀--target-directory=DIRECTORY 移动全部“源文件”参数到“目录”中-u, --update 只移动更老的或者标记新的非目录-v, --verbose 说明完成了什么--help 显示帮助且退出程序 --version 输出版本信息且退出程序这是备份后缀 `~&apos;, 除非设定 --suffix 或 SIMPLE_BACKUP_SUFFIX。 这个版本管理方法可以选择通过 --backup 选项或通过VERSION_CONTROL 环境变量。这些值是： none, off 永不做备份 (即使用 --backup) numbered, t 做备份编号 existing, nil 编号，如果编号备份存在，用其它的简单方法 simple, never 总是做简单备份 mv 可以用作备份，但是总会有更好的选择 常用命令 覆盖文件提示 1mv -i test.txt /home/office 无条件覆盖已经存在的文件 1mv -f test.txt /home/office 重命名文件 1mv test.txt test.md mv 不仅可以操作文件，也可以操作目录，上述操作对目录同样起作用 ls作用: 列出目录内容 补充说明: ls 命令 用来显示目标列表，在 Linux 中是使用率较高的命令。ls 命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。 语法: 1ls [选项] [文件名...] 选项: 1太多了，使用 `man ls` 命令查看 常用命令 查看当前目录的非隐藏文件 1ls 查看当前目录的所有文件 1ls -a 单列查看但前目录的所有文件 1ls -1a 查看指定目录的文件 1ls /opt 递归输出指定目录下面的文件 1ls -R /opt 显示文件夹信息 1ls -ld /etc/ 更多参考命令点击这里查看 diff作用: 比较两个文件的不同 补充说明: diff 命令 在最简单的情况下，比较给定的两个文件的不同。如果使用“-”代替“文件”参数，则要比较的内容将来自标准输入。diff 命令是以逐行的方式，比较文本文件的异同处。如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。 语法: 1diff [选项] 源文件 目标文件 选项: 1太多了，使用 `man diff` 查看 常用命令 比较两个文件的不同 1diff test1.txt test2.txt 对于 diff 显示的结果有不明白的，可以参考这篇文章 cat作用: 连接文件并在标准输出上输出 补充说明: cat 命令 连接文件并打印到标准输出设备上，cat 经常用来显示文件的内容。对于大型文件应该使用 more 或者 less 命令分屏显示 语法: 1cat [选项]... [文件]... 选项: 123456789101112-A, --show-all 等价于 -vET-b, --number-nonblank 给非空输出行编号，使 -n 失效。-e 等价于 -vE -E, --show-ends 在每行结束显示 $-n, --number 给所有输出行编号-s, --squeeze-blank 将所有的连续的多个空行替换为一个空行-t 等价于 -vT-T, --show-tabs 把 TAB 字符显示为 ^I-u （被忽略的选项）-v, --show-nonprinting 除了 LFD 和 TAB 之外的不可打印字符，用 ^ 和 M- 标记方式显示--help 显示此帮助信息并退出--version 显示版本信息并退出 常用指令 输出一个文件到终端 1cat test1.txt 将两个文件输出到终端 1cat test1.txt test2.txt 输出文件内容到文件 1cat test1 &gt; newfile ln作用: 为文件创建连接 补充说明: ln 命令 用来为文件创件连接，连接类型分为硬连接和软链接两种，默认的连接类型是硬连接。如果要创建软链接必须使用 “-s” 选项。 关于硬链接和软链接的区别可以看这篇文章。简单的说，硬链接就是有多个指针指向同一个文件区域，删除任何一个指针并不会实际删除文件区域，因此不会影响其他指针的使用。软链接则不同，软链接创建的指针指向的不是文件区域，而是指向一个指向文件区域的指针，一旦指向的指针被删除，软链接就无法生效。 语法: 12ln [options] source [dest]ln [options] source...directory 选项 12345678910111213141516--backup[=CONTROL] 为每个已存在的目标文件创建备份文件-b 类似--backup，但不接受任何参数-d, -F, --directory 创建指向目录的硬链接(只适用于超级用户)-f, --force 强行删除任何已存在的目标文件-i, --interactive 覆盖既有文件之前先询问用户；-L, --logical 取消引用作为软链接的目标-n, --no-dereference 把软链接的目的目录视为一般文件；-P, --physical 直接将硬链接到软链接-r, --relative 创建相对于链接位置的软链接-s, --symbolic 对源文件建立软链接，而非硬连接；-S, --suffix=SUFFIX 用&quot;-b&quot;参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；-t, --target-directory=DIRECTORY 指定要在其中创建链接的DIRECTORY-T, --no-target-directory 将“LINK_NAME”视为常规文件-v, --verbose 打印每个链接文件的名称 --help 显示此帮助信息并退出 --version 显示版本信息并退出 常用命令 创建一个硬链接 1ln source newfile 创建一个软链接 1ln -s source newfile 系统管理相关命令df作用: 报告文件系统磁盘空间的使用情况 补充说明: df 命令 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法: 1df [OPTION]... [FILE]... 选项: 1234567891011121314151617-a, --all 列出包括BLOCK为0的文件系统--block-size=SIZE use SIZE-byte blocks 指定块的大小-h,--huma-readable&quot; 用常见的格式显示出大小(例如:1K 234M 2G)-H,--si&quot; 同上,但是这里的1k等于1000字节而不是1024字节-i, --inodes 用信息索引点代替块表示使用状况-k, --kilobytes 指定块大小等于1024字节来显示使用状况-l, --local 只显示本地文件系统使用状况-m, --megabytes 以指定块大小等于1048576字节(1M)来显示使用状况--no-sync 在取得使用信息前禁止调用同步 (default)-P, --portability 使用POSIX格式输出--sync 在取得使用信息前调用同步 -t, --type=TYPE 只显示指定类型(TYPE)的文件系统-T, --print-type 输出每个文件系统的类型-x, --exclude-type=TYPE 只显示指定类型(TYPE)之外的文件系统.-v (忽略) -- 输出该命令的帮助信息并退出--version 输出版本信息并退出 常用命令 友好的方式显示整个文件系统的磁盘使用情况 1df -h 查看指定文件系统的使用情况 1df -h / df 只能查看挂载点上使用情况 top作用: 显示 Linux 进程 补充说明: top 命令 可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过 top 命令所提供的互动式界面，用热键可以管理。 语法: 1top -hv|-bcHiOSs -d secs -n max -u|U user -p pid -o fld -w [cols] 选项: 12345678910-b：以批处理模式操作；-c：显示完整的治命令；-d：屏幕刷新间隔时间；-I：忽略失效过程；-s：保密模式；-S：累积模式；-i&lt;时间&gt;：设置间隔时间；-u&lt;用户名&gt;：指定用户名；-p&lt;进程号&gt;：指定进程；-n&lt;次数&gt;：循环显示的次数。 top 交互命令 在 top 命令执行过程中可以使用一些交互命令。这些命令都是单字母的，如果在命令行中使用 -s 选项，其中一些命令可能会被屏蔽 1234567891011121314151617h：显示帮助画面，给出一些简短的命令总结说明；k：终止一个进程；i：忽略闲置和僵死进程，这是一个开关式命令；q：退出程序；r：重新安排一个进程的优先级别；S：切换到累计模式；s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；f或者F：从当前显示中添加或者删除项目；o或者O：改变显示项目的顺序；l：切换显示平均负载和启动时间信息；m：切换显示内存信息；t：切换显示进程和CPU状态信息；c：切换显示命令名称和完整命令行；M：根据驻留内存大小进行排序；P：根据CPU使用百分比大小进行排序；T：根据时间/累计时间进行排序；w：将当前设置写入~/.toprc文件中。 free作用: 显示系统中已用和未用的内存空间总和 补充说明: free 命令 可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 语法: 1free [-b | -k | -m] [-o] [-s delay ] [-t] [-V] 选项: 12345-b 选项 以字节为单位 显示 内存总和; -k 选项 (缺省的) 以 KB 为单位 显示; -m 选项 以 MB 为单位.-t 选项 显示 一个 总计行.-o 选项 禁止 &quot;buffer adjusted&quot; 行的显示. 除非 指定 free 从 (相应的) 已用/未用的 内存 减去/加上 缓冲区内存.-s 使 free 以 delay 秒为间隔, 连续抽样显示. delay 可以设置成浮点数, 它用 usleep(3) 做 微秒级 延迟.-V 显示版本信息. 常用命令 以友好的方式显示内存使用情况 1free -h quota作用: 显示磁盘的使用和限额 补充说明: quota 命令 用于显示用户或者工作组的磁盘配额信息。输出信息包括磁盘使用和配额限制。 语法: 123quota [ -guv | q ]quota [ -uv | q ] userquota [ -gv | q ] group 选项: 1234-g 显示 用户所在组 的 组限额. 可选项(optional).-u 和 缺省情况 一样.-v 显示 文件系统上 的 限额, 即使 没有 占用 空间.-q 简洁的 信息, 只 显示 超出 限额 的 文件系统. at作用: 在指定时间执行一个任务 补充说明: at 命令 用于在指定时间执行命令。at 允许使用一套相当复杂的指定时间的方法。它能够接受在当天的 hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用 midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用 12 小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为 month day（月 日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。 上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units，now 就是当前时间，time-units 是时间单位，这里能够是 minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count 是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用 today（今天）、tomorrow（明天）来指定完成命令的时间。 语法: 1at [-V] [-q 队列] [-f 文件] [-mldbv] 时间 at -c 作业 [作业...] atq [-V] [-q 队列] [-v] 选项: 12345678910-V 在标准错误上输出版本号。-q queue 使用指定的队列。一个队列用一个字母标定，有效的的队列标定的 范围是从a到z和从A到Z。at 的缺省队列是 a,batch 的缺省队列是 b。队列的字母顺序越高，则队列运行时越谦让(运行级别越低)。 指定的队列 &quot;=&quot; 保留给当前运行的作业所在的队列。如果一个作业被提交到一个以大写字母标定的队列，则与提交到 batch 同样对待。如果给 atq 指定一个队列，则只显示在此指定 队列中的作业。-m 当作业完成时即使没有输出也给用户发邮件。-f file 从文件而不是标准输入中读取作业信息。-l 是 atq 的别名。-d 是 atrm 的别名。-v 对于 atq， 显示完整的在队列中未被删除的作业，对于其他 命令，显示作业将要执行的时间。显示的时间的格式类似于&quot;1997-02-20 14:50&quot;，但如果设置了 POSIXLY_CORRECT 环境变量之后，格式类似于&quot;Thu Feb 20 14:50:00 1996&quot;。-c 连接命令行中列出的作业并输出到标准输出。 lp作用: 打印文件或修改排队的打印任务 补充说明: lp 命令 用于打印文件，或者修改排队的打印任务。与 lpr 命令类似，lp 命令既支持文件输入也支持标准输入。它与 lpr 的不同之处在于它有一个不同（稍微复杂点）的参数选项设置。 语法: 12lp [ -E ] [ -U username ] [ -c ] [ -d destination[/instance] ] [ -h hostname[:port] ] [ -m ] [ -n num-copies ] [ -o option[=value] ] [ -q priority ] [ -s ] [ -t title ] [ -H handling ] [ -P page-list ] [ -- ] [ file(s) ]lp [ -E ] [ -U username ] [ -c ] [ -h hostname[:port] ] [ -i job-id ] [ -n num-copies ] [ -o option[=value] ] [ -q priority ] [ -t title ] [ -H handling ] [ -P page-list ] 选项: 123456789-E：与打印服务器连接时强制使用加密；-U：指定连接打印服务器时使用的用户名；-d：指定接收打印任务的目标打印机；-i：指定一个存在的打印任务号；-m：打印完成时发送E-mail；-n：指定打印的份数；-t：指定打印任务的名称；-H：指定打印任务开始的时间；-P：指定需要打印的页码。 adduser作用: 添加一个新成员到系统中 补充说明: 语法: 12345678910111213141516171819adduser [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID][--firstuid ID] [--lastuid ID] [--gecos GECOS] [--ingroup GROUP | --gid ID][--disabled-password] [--disabled-login] [--add_extra_groups] USER Add a normal useradduser --system [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID][--gecos GECOS] [--group | --ingroup GROUP | --gid ID] [--disabled-password][--disabled-login] [--add_extra_groups] USER Add a system useradduser --group [--gid ID] GROUPaddgroup [--gid ID] GROUP Add a user groupaddgroup --system [--gid ID] GROUP Add a system groupadduser USER GROUP Add an existing user to an existing group 选项: 123456--quiet | -q don&apos;t give process information to stdout--force-badname allow usernames which do not match the NAME_REGEX configuration variable--help | -h usage message--version | -v version number and copyright--conf | -c FILE use FILE as configuration file groupadd作用: 创建一个新组 补充说明: groupadd 命令 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。 语法: 1groupadd [选项] group 选项: 123456789-f, --force 如果组已经存在则成功退出 并且如果 GID 已经存在则取消 -g-g, --gid GID 为新组使用 GID-h, --help 显示此帮助信息并推出-K, --key KEY=VALUE 不使用 /etc/login.defs 中的默认值-o, --non-unique 允许创建有重复 GID 的组-p, --password PASSWORD 为新组使用此加密过的密码-r, --system 创建一个系统账户-R, --root CHROOT_DIR chroot 到的目录 kill作用: 终止进程 补充说明: kill 命令 用来删除执行中的程序或工作。kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15) ,可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 job 指令查看。 语法: 12kill[-ssignal|-p][-a]pid...kill -l [ signal ] 选项: 123456pid ... 给 kill 指定一个该发信号的进程列表. 每个 pid 可为下面四种之一. 进程名 在这种情况下,发信号给所命名的进程. n 这里的 n 大于 0. 将发信号给 pid 为 n 的进程. -1 在这种情况下, 只要发信号的用户能够控制那些进行, 将发信号给所 有从 MAX_INT 到 2 的进程. -n 这里的 n 大于 1, 在这种情况下, 发信号给属于进程组 n 的进程. 如果给定一个负的参数, 那么信号 必须 首先声明, 否则它会被当作信号发送出去.-s 指定发送的信号. 信号可以以信号名或数字的方式给定.-p 指定 kill 只打印命名进程的进程标识 (pid) , 而不应发送给它信号.-l 打印信号名的列表.这可以在 /usr/include/linux/signal.h 中找到. 常用命令 列出所有信号名称 1kill -l crontab作用: 提交和管理用户的需要周期性执行的任务 补充说明: crontab 命令 被用来提交和管理用户的需要周期性执行的任务，与 windows 下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 语法: 12crontab [ -u user ] filecrontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125; 选项: 1234-e (edit user&apos;s crontab)-l (list user&apos;s crontab)-r (delete user&apos;s crontab)-i (prompt before deleting user&apos;s crontab) crontab 传入的文件参数是指定格式 crontab 文件，关于 crontab 文件的详细信息点击这里查看 tar作用: 存储或提取 tar 文件的程序 补充说明: 利用 tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。 语法: 1tar &lt;操作参数&gt; [选项] 选项: 1太多了，使用 `man tar` 命令查看详细信息 常用命令 把一个目录打包并压缩 1tar -zcf test.tar.gz config install.sh local_install.sh 查看压缩包有哪些文件 1tar -ztvf test.tar.gz 只将压缩包内的部分文件解压 1tar -zxvf test.tar.gz config 解压的文件可以通过 tar -ztvf 查看 排除部分文件 1tar --exclude docker/latex -zcvf docker.tar.gz docker 压缩并保留权限 1tar --exclude docker/latex -zcvfp docker.tar.gz docker unzip作用: 解压有 zip 命令压缩的压缩包 补充说明: unzip 命令 用于解压缩由 zip 命令压缩的 “.zip” 压缩包。 语法: 1unzip [-Z] [-cflptTuvz[abjnoqsCDKLMUVWX$/:^]] file[.zip] [file(s) ...] [-x xfile(s) ...] [-d exdir] 选项: 123456789101112131415161718192021222324-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换；-f：更新现有的文件；-l：显示压缩文件内所包含的文件；-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；-t：检查压缩文件是否正确；-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；-v：执行时显示详细的信息；-z：仅显示压缩文件的备注文字；-a：对文本文件进行必要的字符转换；-b：不要对文本文件进行字符转换；-C：压缩文件中的文件名称区分大小写；-j：不处理压缩文件中原有的目录路径；-L：将压缩文件中的全部文件名改为小写；-M：将输出结果送到more程序处理；-n：解压缩时不要覆盖原有的文件；-o：不必先询问用户，unzip执行后覆盖原有的文件；-P&lt;密码&gt;：使用zip的密码选项；-q：执行时不显示任何信息；-s：将文件名中的空白字符转换为底线字符；-V：保留VMS的文件版本信息；-X：解压缩时同时回存文件原来的UID/GID；-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；-x&lt;文件&gt;：指定不要处理.zip压缩文件中的哪些文件；-Z：unzip-Z等于执行zipinfo指令。 常用命令 解压文件 1unzip test.zip 一般压缩文件使用 tar 来压缩，如果是 zip 压缩格式，很有可能是在 Windows 下进行压缩，在 Linux 下解压时可能出现乱码 gunzip作用: 压缩或解压文件 补充说明: 语法: 1gunzip [ -acfhlLnNrtvV ] [-S 后缀] [ 文件名 ... ] 选项: 1234567891011121314-a或——ascii：使用ASCII文字模式；-c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；-h或——help：在线帮助；-l或——list：列出压缩文件的相关信息；-L或——license：显示版本与版权信息；-n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；-N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；-q或——quiet：不显示警告信息；-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；-t或——test：测试压缩文件是否正确无误；-v或——verbose：显示指令执行过程；-V或——version：显示版本信息； last作用: 列出目前与过去登入系统的用户相关信息 补充说明: last 命令 用于显示用户最近登录信息。单独执行 last 命令，它会读取 /var/log/wtmp 的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。 语法: 1last [-R] [-num] [ -n num ] [-adiox] [ -f file ] [name...] [tty...] 选项: 12345678-num指定 last 要显示多少行。&quot;-n num&quot;等同 -num.-R不显示主机名列。-a在最后一列显示主机名. 和下一个选项合用时很有用-d对于非本地的登录，Linux 不仅保存远程主机名而且保存IP地址（IP number）。这个选项可以将IP地址（IP number）转换为主机名。-i这个选项类似于显示远程主机 IP 地址（IP number）的 -d 选项，只不过它用数字和点符号显示IP数-o读取一个旧格式的 wtmp 文件 (用linux-libc5应用程序写入的).-x显示系统关机记录和运行级别改变的日志。 网络操作相关命令ifconfig作用: 配置和显示Linux系统网卡的网络参数 补充说明: ifconfig 命令 被用于配置和显示 Linux 内核中网络接口的网络参数。用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 语法: 12ifconfig [接口]ifconfig 接口 [aftype] options | address ... 选项: 123456789101112131415161718add&lt;地址&gt;：设置网络设备IPv6的ip地址；del&lt;地址&gt;：删除网络设备IPv6的IP地址；down：关闭指定的网络设备；&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;：设置网络设备的类型与硬件地址；io_addr&lt;I/O地址&gt;：设置网络设备的I/O地址；irq&lt;IRQ地址&gt;：设置网络设备的IRQ；media&lt;网络媒介类型&gt;：设置网络设备的媒介类型；mem_start&lt;内存地址&gt;：设置网络设备在主内存所占用的起始地址；metric&lt;数目&gt;：指定在计算数据包的转送次数时，所要加上的数目；mtu&lt;字节&gt;：设置网络设备的MTU；netmask&lt;子网掩码&gt;：设置网络设备的子网掩码；tunnel&lt;地址&gt;：建立IPv4与IPv6之间的隧道通信地址；up：启动指定的网络设备；-broadcast&lt;地址&gt;：将要送往指定地址的数据包当成广播数据包来处理；-pointopoint&lt;地址&gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能；-promisc：关闭或启动指定网络设备的promiscuous模式；IP地址：指定网络设备的IP地址；网络设备：指定网络设备的名称。 常用命令 显示网络设备信息 1ifconfig 启动关闭指定网卡 12ifconfig eth0 upifconfig eth0 down ip作用: 显示或操作路由，设备，测路路由和通道 补充说明: 语法: 123456789101112Usage: ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125; ip [ -force ] -batch filenamewhere OBJECT := &#123; link | address | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm | netns | l2tp | fou | macsec | tcp_metrics | token | netconf | ila &#125; OPTIONS := &#123; -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] &#123; inet | inet6 | ipx | dnet | mpls | bridge | link &#125; | -4 | -6 | -I | -D | -B | -0 | -l[oops] &#123; maximum-addr-flush-attempts &#125; | -br[ief] | -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] | -rc[vbuf] [size] | -n[etns] name | -a[ll] | -c[olor]&#125; 选项: 常用命令 查看 ip 地址 1ip address ping作用: 向网络主机发送 ICMP 回显请求（ECHO_REQUEST）分组 补充说明: ping 命令 用来测试主机之间网络的连通性。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。 语法: 1ping [-aAbBdDfhLnOqrRUvV46] [-c count] [-F flowlabel] [-i interval] [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-w deadline] [-W timeout] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp option] [hop ...] destination 选项: 1234567891011121314151617181920212223-4 仅使用 IPv4。-6 仅使用 IPv6。-a Audible ping.-A 自适应 ping。-b 允许对一个广播地址进行 ping。-t ttl 仅进行ping。 设置 IP 的 TTL（Time to Live）。-T timestamp option 设置特殊的 IP 时间戳选项。 timestamp option 可以是 tsonly（仅时间戳）、 tsandaddr（时间戳和地址）或者 tsprespec host1 [host2 [host3 [host4]]]（预先指定跳数的时间戳）。-U 打印完整的用户到用户的延迟（旧行为）。通常情况下 ping 打印网络往返延时，它们可能不同，例如在 DNS 解析出现失败时。-v 输出详细信息。-V 显示版本并退出。-c count 在发送(和接收)了正好数量为 count 的回显应答分组后停止操作。在发送了 count 个分组后没有收到任何分组的特别情况是发送导致了终止(选程主机或网关不可达)。-d 在所用的套接字上使用 SO_DEBUG 选项。 实际上，这个套接字选项没有被 Linux 内核所使用。-D 在每行之前打印时间戳（UNIX 时间 + gettimeofday 中的毫秒）。-f 以高速（洪水）方式进行 ping。 以分组返回的速度来输出其它分组或每秒输出百次。当收到每个回显应答并打印一个退格符时，对每个回显请求都打印一个句点``.&apos;&apos;。这可以快速显示出丢弃了多少个分组，只有超级用户可以用这个选项。这（操作）对网络要求非常苛刻，应该慎重使用。-i wait 在发送每个分组时等待 wait 个秒数。缺省值为每个分组等待一秒。此选项与-f选项不能同时使用。-l preload 如果指定 preload ，那么 ping 程序在开始正常运行模式前尽可能快地发送分组。同样只有超级用户可以用这个选项。-n 只以数字形式输出信息。这样就不尝试去查找主机名了。-p pattern 可以指定最多16个填充字节用于保持分组长度为16的整数倍。在网络上诊断与数据相关问题时此选项很有用。例如``-p ff&apos;&apos;将使发出的分组都用全1填充数据区。-q 静态输出。在程序启动和结束时只显示摘要行。-R 记录路由。在回显请求分组中包含记录路由选项并在相应的分组返回时显示路由缓冲区。注意IP首部的容量只能存放9条这样的路由。很多主机 忽略或禁用此选项。-r 在所连接的网络上旁路正常的选路表，直接向主机发送分组。如果主机未处于直接相连的网络上，那么返回一个错误。此选项可用来通过无路由接口对一台主机进行检测(例如当接口已被 routed 程序丢弃后)。-s packetsize 指定要发送数据的字节量。缺省值为 56 ，这正好在添加了 8 字节的 ICMP 首部后组装成 64 字节的 ICMP 数据报。 -w waitsecs 在 waitsecs 秒后停止 ping 程序的执行。当试图检测不可达主机时此选项很有用。 常用命令 测试网络状态 1ping www.biying.com netstat作用: 显示网络连接，路由表，接口状态，伪装连接，网络链路信息和组播成员组。 补充说明: netstat 命令 用来打印 Linux 中网络系统的状态信息，可让你得知整个 Linux 系统的网络情况。 语法: 1234567891011netstat [address_family_options] [--tcp|-t] [--udp|-u] [--raw|-w] [--listening|-l] [--all|-a] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--symbolic|-N] [--extend|-e[--extend|-e]] [--timers|-o][--program|-p] [--verbose|-v] [--continuous|-c] [delay]netstat &#123;--route|-r&#125; [address_family_options] [--extend|-e[--extend|-e]] [--verbose|-v] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]netstat &#123;--interfaces|-i&#125; [iface] [--all|-a] [--extend|-e[--extend|-e]] [--verbose|-v] [--program|-p] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]netstat &#123;--groups|-g&#125; [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]netstat &#123;--masquerade|-M&#125; [--extend|-e] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]netstat &#123;--statistics|-s&#125; [--tcp|-t] [--udp|-u] [--raw|-w] [delay]netstat &#123;--version|-V&#125;netstat &#123;--help|-h&#125;address_family_options:[--protocol=&#123;inet,unix,ipx,ax25,netrom,ddp&#125;[,...]] [--unix|-x] [--inet|--ip] [--ax25] [--ipx] [--netrom] [--ddp] 选项: 12345678910111213141516--verbose , -v 详细模式运行。特别是打印一些关于未配置地址族的有用信息。--numeric , -n 显示数字形式地址而不是去解析主机、端口或用户名。--numeric-hosts 显示数字形式的主机但是不影响端口或用户名的解析。--numeric-ports 显示数字端口号，但是不影响主机或用户名的解析。--numeric-users 显示数字的用户ID，但是不影响主机和端口名的解析。--protocol=family , -A 指定要显示哪些连接的地址族(也许在底层协议中可以更好地描述)。 family 以逗号分隔的地址族列表，比如 inet, unix, ipx, ax25, netrom, 和 ddp。 这样和使用 --inet, --unix (-x), --ipx, --ax25, --netrom, 和 --ddp 选项效果相同。 地址族 inet 包括raw, udp 和tcp 协议套接字。-c, --continuous 将使 netstat 不断地每秒输出所选的信息。-e, --extend 显示附加信息。使用这个选项两次来获得所有细节。-o, --timers 包含与网络定时器有关的信息。-p, --program 显示套接字所属进程的PID和名称。-l, --listening 只显示正在侦听的套接字(这是默认的选项)-a, --all 显示所有正在或不在侦听的套接字。加上 --interfaces 选项将显示没有标记的接口。-F 显示FIB中的路由信息。(这是默认的选项)-C 显示路由缓冲中的路由信息。delay netstat将循环输出统计信息，每隔 delay 秒。 常用命令 列出所有处于监听状态的 Sockets 1234netstat -lnetstat -ltnetstat -lunetstat -lx 列出所有端口，包括监听和未监听的 123netstat -anetstat -atnetstat -au telnet作用: 登录远程主机和管理(测试ip端口是否连通) 补充说明: telnet 命令 用于登录远程主机，对远程主机进行管理。telnet 因为采用明文传送报文，安全性不好，很多 Linux 服务器都不开放 telnet 服务，而改用更安全的 ssh 方式了。 语法 1telnet [-468ELadr] [-S tos] [-b address] [-e escapechar] [-l user] [-n tracefile] [host [port]] 选项 123456789101112131415161718-8：允许使用8位字符资料，包括输入与输出；-a：尝试自动登入远端系统；-b&lt;主机别名&gt;：使用别名指定远端主机名称；-c：不读取用户专属目录里的.telnetrc文件；-d：启动排错模式；-e&lt;脱离字符&gt;：设置脱离字符；-E：滤除脱离字符；-f：此参数的效果和指定&quot;-F&quot;参数相同；-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；-K：不自动登入远端主机；-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；-L：允许输出8位字符资料；-n&lt;记录文件&gt;：指定文件记录相关信息；-r：使用类似rlogin指令的用户界面；-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息；-x：假设主机有支持数据加密的功能，就使用它；-X&lt;认证形态&gt;：关闭指定的认证形态。 常用命令 1telnet &lt;ip&gt; ftp作用: Internet 文件传输程序 (file transfer program) 补充说明: 用户通过 Ftp 这个程序来使用 Internet 上的标准文件传输协议 (File Transfer Protocol). 本程序允许用户向远端网站发送文件, 或从远端网站接收文件. 语法: 1ftp [-pinegvd] [host] pftp [-inegvd] [host] 选项 1234567-p 使用被动模式进行数据传输. 如果你本地网络有防火墙, 外部主机不能连接到你这个客户端, 这个选项就派上用场了. 本选项要求 ftp 服务器支持 PASV 命令. 如果使用 pftp 从命令行启动 ftp, 本选项是默认打开的.-i 进行多个文件传输时关掉交互式的确认提示.-n 一般，在启动 ftp 时, ftp 会试着进行自动登录. 本选项可以关掉这个功能. 如果 auto-login 功能被启用的话, ftp 会在用户 home 目录下的 .netrc (参阅 netrc(5)) 文件中查找远端主机上的用户帐号. 如果 .netrc 文件中用户帐号这一项不存在, ftp 会提示用户输入远端主机上的登录名 (缺省为用户在本地机器上的帐号), 如果需要, 还会提示你输入密码和用来登录的帐号. ??-e 如果被编译成了 ftp 可执行格式, 本选项会关掉命令编辑和历史命令功能; 否则什么也不做. ??-g 关掉文件名匹配功能.-v 显示详细信息. 本选项使得 ftp 显示远端服务器的所有响应, 并在数据传输完成后显示传输数据的统计信息.-d 打开 debug 模式. 常用命令 1ftp &lt;ip&gt; route作用: 显示 / 操作 IP 选路表 补充说明: route 程序对内核的IP选路表进行操作。它主要用于通过已用 ifconfig 程序配置好的接口来指定的主机或网络设置静态路由。 语法: 1234route [-CFvnee]route [-v] [-A family] add [-net|-host] target [netmask Nm] [gw Gw] [metric N] [mss M] [window W] [irtt I][reject] [mod] [dyn] [reinstate] [[dev] If]route [-v] [-A family] del [-net|-host] target [gw Gw][netmask Nm] [metric N] [[dev] If]route [-V] [--version] [-h] [--help] 常用命令 列出当前路由 1route 添加/设置网关 1route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0 #增加一条到达244.0.0.0的路由。 屏蔽一条路由： 1route add -net 224.0.0.0 netmask 240.0.0.0 reject #增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。 删除路由记录： 12route del -net 224.0.0.0 netmask 240.0.0.0route del -net 224.0.0.0 netmask 240.0.0.0 reject 删除和添加设置默认网关： 12route del default gw 192.168.120.240route add default gw 192.168.120.240 rlogin作用: 从当前终端登录到远程Linux主机 补充说明: 请用 SSH 语法: 1rlogin [-8EKLdx] [-e char] [-l username] host 选项: 12345678-8 -8 选项 允许 进行 8 位的 输入 数据 传送; 否则在 远程主机 未使用 与 ^S/^Q 不同的 控制 字符 之前, 所有的 奇偶 校验位 都会 被清除.-E -E 选项 阻塞(stops) 一些 被识别 为转意 字符 的字符. 当 使用了 -8 选项时, 这样 可以 提供 完全 透明的 连接.-K -K 选项 关闭 所有的 Kerberos 安全 鉴别.-L -L 选项 允许 rlogin 会话 以 ``litout&apos;&apos; 模式 运行(参见 tty(4))-d -d 选项 启动 套接字 调试(参见 setsockopt(2)) , 在 TCP 类型 的连接中, 套接字 用于 提供 与远程 主机的 通讯.-e -e 选项 允许 用户 指定 转意 字符, 缺省是 ``~&apos;&apos;. 可以 直接 使用 字符, 也可以 使用 八进制值 进行 指定, 八进制 格式为: \nnn.-k -k 选项 要求 rlogin 在从 远程 接受 许可证时, 使用 realm 中定义的 realm, 而不是 krb_realmofhost(3) 中定义的 realm.-x -x 选项 使通过 rlogin 会话 进行的 数据 传送 都要 采用 DES 加密. 这可能 会影响 响应 时间和 CPU 的利用, 但 提高了 安全性. rcp作用: 安装在两台主机之间通信 补充说明: rcp 似乎是 scp 的一个马甲，实际使用的 scp 命令。 语法: 1rcp [-pqrvBC1246] [-F ssh_config] [-S program] [-P port] [-c cipher] [-i identity_file] [-l limit] [-o ssh_option] [[user@]host1:]file1 [...] [[user@]host2:]file2 选项: 1234567891011121314151617-c cipher Selects the cipher to use for encrypting the data transfer. This option is directly passed to ssh(1).-i identity_file Selects the file from which the identity (private key) for RSA authentication is read. This option is directly passed to ssh(1).-l limit Limits the used bandwidth, specified in Kbit/s.-p Preserves modification times, access times, and modes from the original file.-r 递归复制整个目录。-v 详细模式。该选项使 scp 和 ssh(1) 打印出关于运行情况的调试信息。在进行调试连接、验证和配置问题时，这会很有用的-B 用批模式(避免重复询问口令)。-q Disables the progress meter.-C 允许压缩。向 ssh(1) 传递 -C 标志以允许压缩。-F ssh_config Specifies an alternative per-user configuration file for ssh. This option is directly passed to ssh(1).-P port Specifies the port to connect to on the remote host. Note that this option is written with a capital ‘P’, because -p is already reserved for preserving the times and modes of the file in rcp(1).-S program Name of program to use for the encrypted connection. The program must understand ssh(1) options.-o ssh_option Can be used to pass options to ssh in the format used in ssh_config(5). This is useful for specifying options for which there is no separate scp command-line flag.-1 Forces scp to use protocol 1.-2 Forces scp to use protocol 2.-4 Forces scp to use IPv4 addresses only.-6 Forces scp to use IPv6 addresses only. 常用命令 从本地复制到远程主机 1rcp /test root@&lt;ip&gt;:/home/test/ 从远程主机复制到本地 1rcp root@&lt;ip&gt;:/home/test test/ 从远程主机复到远程主机 1rcp root@&lt;ip&gt;:/home/test root@&lt;nwe-ip&gt;:/home/test/ finger作用: 用户信息查找程序 补充说明: finger 命令 用于查找并显示用户信息。包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行 finger 指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。 语法: 1finger [-lmsp] [user ...] [user@host ...] 选项: 12345678910-s Finger 显示用户的登录名, 真名, 终端名 以及写 状态(如果写被禁止，在终端名后显示一个``*&apos;&apos;), 空闲时间,登录时间,办公地点和电话等。 登录时间显示为月,天,小时和分钟，如果是超过6个月以前，则 显示年份，而不是小时和分钟。 不明设备以及不存在的空闲时间和登录时间显示为一个星号。-l 产生一个多行显示来描述信息 -s 关于用户家目录，家庭电话，登录脚本，邮件状态和文件的内容 “.plan” 和 “.project” 和 “.forward” 从用户的家目录. 11位数字电话号码显示为 ``+N-NNN-NNN-NNNN&apos;&apos;. 十位或七位数字可以显示为它的子集。 五位数字电话号码显示为 ``xN-NNNN&apos;&apos;. 四位数字电话号码显示为 ``xNNNN&apos;&apos;. 如果对设备写被禁止, 短语 ``(messages off)&apos;&apos; 被附加在有此设备的行后边. 每一个用户有一个条目，用 -l 选项; 如果一个用户多次登录, 终端信息 按每次登录重复显示。. 如果什么邮件都没有，邮件信息显示为``No Mail.&apos;&apos;, 如果当新邮件来后， 已经查看过信箱，为``Mail last read DDD MMM ## HH:MM YYYY (TZ)&apos;&apos; 如果有新邮件，则为 ``New mail received ...&apos;&apos;,`` Unread since ...&apos;&apos;-p 防止 finger -l 选项 显示 “.plan” 和 “.project” 文件的内容。-m 防止 user 名字的匹配. User 通常是一个登录名; 可是, 也会对用户的真实名字 进行匹配, 除非提供 -m 选项. 所有由 finger 进行的名字匹配是区分大小写的 常用命令 1finger mail作用: 发送和接受邮件 补充说明: mail 命令 是命令行的电子邮件发送和接收工具。操作的界面不像 elm 或 pine 那么容易使用，但功能非常完整。 语法: 1mail [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] to-addr... mail [-iInNv] -f [name] mail [-iInNv] [-u user] 选项 12345678910-b&lt;地址&gt;：指定密件副本的收信人地址；-c&lt;地址&gt;：指定副本的收信人地址；-f&lt;邮件文件&gt;：读取指定邮件文件中的邮件；-i：不显示终端发出的信息；-I：使用互动模式；-n：程序使用时，不使用mail.rc文件中的设置；-N：阅读邮件时，不显示邮件的标题；-s&lt;邮件主题&gt;：指定邮件的主题；-u&lt;用户帐号&gt;：读取指定用户的邮件；-v：执行时，显示详细的信息。 nslookup作用: 查询域名DNS信息的工具 补充说明: nslookup 命令 是常用域名查询工具，就是查 DNS 信息用的命令。 nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。 进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。 语法: 1nslookup [-option] [name | -] [server] 选项: 1-sil：不显示任何警告信息。 常用命令 1nslookup www.biying.com 系统安全相关命令passwd作用: 修改用户密码 补充说明: 命令用来更改用户账户的密码。普通用户通常只更改其自己账户的密码，而超级用户可以更改任何账户的密码。passwd 也更改账户或相关的密码有效期。 语法: 1passwd [选项] [登录] 选项: 1234567891011121314151617-a, --all 此选项只能和 -S 一起使用，来显示所有用户的状态。-d, --delete 删除用户密码(让它为空)。这是禁用一个用户密码的快速方法。它将设置给出名称的账户。-e, --expire 让一个账户的密码立即过期。这可以强制一个用户下次登录时更改密码。-h, --help 现实帮助信息并退出。-i, --inactive INACTIVE 此选项用于在密码过期一定天数之后禁用账户。一个用户账户密码已经过期 INACTIVE 天之后，用户将不能再登录进账户。-k, --keep-tokens 表示密码更改只应该因为认证口令(密码)过期更改。用户希望保持他们尚未过期的口令。-l, --lock 锁定指定账户的密码。此选项通过将密码更改为一个不可能与加密值匹配的值来禁用(它在密码开头添加一个“!”)。 注意，这并没有禁用此账户。用户仍然可以通过其它认证方式(如 SSH 密码)来登录。要禁用此账户，管理员需要使用 usermod --expiredate 1 (设置账户的过期时间为1970年1月2日)。 被锁定了密码的用户不允许更改密码。-n, --mindays MIN_DAYS 在密码更改之间的最小天数设置为 MIN_DAYS。此字段中的 0 值表示用户可以在任何时间更改其密码。-q, --quiet 安静模式。-r, --repository REPOSITORY 在 REPOSITORY 中更改密码-R, --root CHROOT_DIR Apply changes in the CHROOT_DIR directory and use the configuration files from the CHROOT_DIR directory.-S, --status 显示账户状态信息。状态信息包含 7 个字段。首个字段是用户的登录名，第二个字段表示用户账户是否已经锁定密码(L)、没有密码 (NP)或者密码可用(P)，第三个字段给出最后一次更改密码的日期。接下来的四个字段分别是密码的最小年龄、最大年龄、警告期和禁用期。这些年龄以天为单位计算。-u, --unlock 解锁指定用户的密码。此操作通过将密码改回先前值(改回使用 -l 之前的值)重新启用密码。-w, --warndays WARN_DAYS 设置在要求更改密码之前警告的天数。WARN_DAYS 选项是在密码过期之前提前警告的天数。-x, --maxdays MAX_DAYS 设置密码仍然有效的最大天数。MAX_DAYS 之后，密码会要求更改。 常用命令 用户修改自己的密码 1passwd 管理员创建用户之后，使用 passwd 为新用户创建密码，当然也可以任意修改用户的密码 1passwd &lt;new-user-name&gt; su作用: 用于切换当前用户身份到其他用户身份 补充说明: su 命令 用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。 语法: 1su [选项] [用户名] 选项: 1234-c, --command COMMAND 通过使用其 -c 选项，指定一个由 shell 运行的命令。-, -l, --login 提供一个类似于用户直接登录的环境，用户可能会希望这样。-s, --shell SHELL 将使用的 shell。-m, -p, --preserve-environment 保留当前环境，除非：.PP $PATH 常用命令 切换为 root 用户 1su 切换为其他用户 1su &lt;other-user&gt; umask作用: 用来设置限制新建文件权限的掩码 补充说明: umask 命令 用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask 命令都被执行， 并自动设置掩码 mode 来限制新文件的权限。用户可以通过再次执行 umask 命令来改变默认值，新的权限将会把旧的覆盖掉。 语法: 1umask [-p] [-S] [模式] 选项: 12-p：输出的权限掩码可直接作为指令来执行；-S：以符号方式输出权限掩码。 常用命令 设置掩码 1umask u=rwx,g=,o= 运行上述命令之后创建的文件，默认权限为 -rw——- chgrp作用: 修改文件或目录所属的群组 补充说明: chgrp 命令 用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的 id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户 (root) ，则不能改变该文件的组。 语法: 12chgrp [选项列表]... 组 文件...chgrp [选项列表]... --reference=参考文件 文件... 选项: 12345678910-R 递归式地改变指定目录及其下的所有子目录和文件的所属的组-c或——changes：效果类似“-v”参数，但仅回报更改的部分；-f或--quiet或——silent：不显示错误信息；-h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件；-H如果命令行参数是一个通到目录的符号链接，则遍历符号链接-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；-L遍历每一个遇到的通到目录的符号链接-P不遍历任何符号链接（默认）-v或——verbose：显示指令执行过程；--reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同； 常用命令 改变一个文件所属用户组 1chgrp canxing test 改变一个目录以及目录下所有文件所属用户组 1chgrp -R canxing test/ chown作用: 修改文件所有者和组别 补充说明: chown 修改每个由第一个非选项参数声明的给定 file(文件) 的用户和/或组的所有权.如下: 如果只给出了用户名(或者数字用户标识),那么该用户即成为每个指定 文件的所有者,而该文件的组别并不改变.如果用户名后面紧跟着冒号和组名(或者是数字组标识),并且它们之间没有空格,那么文件的组所有权 也随之改变. 语法: 1chown [options] user [:group] file... 选项: 1234567-c, --changes 详尽地描述每个 file 实际改变了哪些所有权.-f, --silent, --quiet 不打印文件所有权不能修改的报错信息.-h, --no-dereference 只作用于其本身的符号链接,而不修改它们所指向的文件. 这只在提供了 lchown 系统调用的情况下才可用.-v, --verbose 详尽地描述对每个 file 所执行的操作(或者无操作).-R, --recursive 递归地修改目录及其下面内容的所有权.--dereference 修改符号链接目标端的所有权,而非符号链接自身. (fileutils 4.0中实现的新功能.)--reference=rfile (fileutils 4.0中实现的新功能.) 修改 file 的所有权为 rfile 的所有权. 常用命令 改变文件的所有者 1chown canxing test 改变目录以及目录下所有文件的所有者 1chown -R canxing test/ chmod作用: 变更目录或文件权限 补充说明: chmod 命令 用来变更文件或目录的权限。在 UNIX 系统家族里，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。用户可以使用 chmod 指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。 语法: 1chmod [options] mode file... 选项 12345-c, --changes 只有在文件的权限确实改变时才进行详细的说明-f, --silent, --quiet 不输出权限不能改变的文件的错误信息-v, --verbose 详细说明权限的变化-R, --recursive 改变目录及其所有子目录的文件的权限--reference=rfile (更新在fileutils 4.0上) 改变文件的模式到rfile. 常用命令 使用数字修改文件或目录权限 12chmod 755 test chmod -R 755 test-dir/ 增加其他用户的执行权限 12chmod o+x testchmod -R o+x test-dir/ chattr作用: 用来改变文件属性 补充说明: chattr 命令 用来改变文件属性。这项指令可改变存放在 ext2 文件系统上的文件或目录属性，这些属性共有以下 8 种模式：12345678a：让文件或目录仅供附加用途；b：不更新文件或目录的最后存取时间；c：将文件或目录压缩后存放；d：将文件或目录排除在倾倒操作之外；i：不得任意更动文件或目录；s：保密性删除文件或目录；S：即时更新文件或目录；u：预防意外删除。 语法: 1chattr [ -RVf ] [ -v 版本 ] [ -p project ] [ mode ] files... 选项 123-R 递归地修改目录以及其下内容的属性. 如果在递归目录时遇到了符号链接,遍历将跳过.-V 详尽地给出chattr的输出信息并打印出程序的版本.-v version 设置文件系统的版本. sudo作用: 以其他用户的身份来执行命令 补充说明: sudo 命令 用来以其他身份来执行命令，预设的身份为 root。在 /etc/sudoers 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用 sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码。 语法: 1234sudo -h | -K | -k | -Vsudo -v [-AknS] [-a type] [-g group] [-h host] [-p prompt] [-u user]sudo -l [-AknS] [-a type] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]sudo [-AbEHnPS] [-a type] [-C num] [-c class] [-g group] [-h host] [-p prompt] [-r role] [-t type] [-u user] [VAR=value] [-i | -s] [command] 选项 12345678910-b：在后台执行指令；-h：显示帮助；-H：将HOME环境变量设为新身份的HOME环境变量；-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。-l：列出目前用户可执行与无法执行的指令；-p：改变询问密码的提示符号；-s&lt;shell&gt;：执行指定的shell；-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；-v：延长密码有效期限5分钟；-V ：显示版本信息。 没啥用 ps作用: 报告当前程序的状态 补充说明: 语法: 1ps [options] 选项 1太多，使用 `man ps` 查看 常用命令 1ps -ef 上述命令会输出所有当前运行进程的详细信息，再通过管道即可获取想要的信息 who作用: 显示已登录用户 补充说明: who 命令 是显示目前登录系统的用户信息。执行 who 命令可得知目前有那些用户登入系统，单独执行 who 命令会列出登入帐号，使用的终端机，登入时间以及从何处登入或正在使用哪个 X 显示器。 语法: 1who [选项]... [ 文件 | 参数1 参数2 ] 选项 12345678910111213141516171819-a, --all 等价于 -b -d --login -p -r -t -T -u-b, --boot 最近一次系统引导的时间-d, --dead 显示死进程-H, --heading 显示表格的表头--ips 显示 IP地址而不是主机名。加上 --lookup，则会尽可能基于已存储的 IP 规范化，而不是已存储的主机名-l, --login 显示系统登录进程--lookup 试图通过 DNS 规范主机名-m 仅显示和标准输入关联的主机名和用户-p, --process 显示由 init 生成的活跃进程-q, --count 所有登录名称与已登录用户数量-r, --runlevel 显示当前运行级别-s, --short 仅显示名称、线路与时间（默认）-t, --time 显示最近一次系统时钟更改-T, -w, --mesg 添加用户状态信息，如 +, - 或 ?-u, --users w列出已登陆用户--message 等价于 -T--writable 等价于 -T--help 显示此帮助信息并退出--version 显示版本信息并退出]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker基础]]></title>
    <url>%2F2018%2F11%2F26%2Fdocker%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Docker基础本文参考自 &lt;&lt;Docker--从入门到实践&gt;&gt;，该书github 地址，国内镜像 基本概念 镜像 获取镜像 查看本地镜像 运行镜像 停止容器 删除本地镜像 定制镜像 Dockerfile 指令 导入导出镜像 容器 启动容器 查看容器信息 终止容器 进入容器 删除容器 数据管理 数据卷 挂载主机目录 基本概念Docker 包含三个基本概念: 镜像，容器，仓库。镜像是模板，容器是根据镜像的定义生成的，仓库是存放镜像的地方。镜像在 VirtualBox 的概念相当于一个 OVA 文件，VirtualBox 可以导入这个 OVA 文件创建一个虚拟机，这个虚拟机就相当于容器的概念（并不是完全相似，容器在退出时会删除所有容器中的数据，每次启动容器就好像第一次启动，通过一些方法可以保存容器中的数据），存放 OVA 文件的地方就相当于一个仓库。 镜像Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序，库，资源，配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建之后也不会改变。 获取镜像从 Docker 镜像仓库获取镜像的命令是 docker pull。命令格式为: 1docker pull [选项] [Docker Registry 地址[:端口号] /][用户名/]仓库名[:标签] 其中大部分参数可以省略，一个最简单的 docker pull 命令如下: 1docker pull hello-world 如果没有指定镜像的地址，那么默认地址为 Docker Hub 的地址，如果没有指定标签，那么默认标签为 latest。执行上面命令，会默认从 Docker Hub 拉取 hello-world:latest 镜像。 查看本地镜像通过 docker imager ls 命令可以查看本地安装的镜像 在本地运行上述命令得到的结果如下： REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest 4ab4c602aa5e 7 weeks ago 1.84kB 上述命令会列出本地镜像的所有信息，包括镜像名称，镜像标签，镜像 ID，镜像创建时间和镜像大小。 运行镜像获取到一个镜像之后，就可以利用这个镜像为基础启动一个容器。 使用 docker run 命令可以运行一个容器。 1docker run hello-world 在执行 docker run 命令时，会首先检查本地镜像，如果本地没有指定的镜像，会从指定的仓库拉取指定镜像。 停止容器启动一个容器之后可以通过 docker container ls 命令来查看容器的运行状态。 如果想要终止容器，使用 docker container stop 命令终止。对于已经停止的容器可以使用 docker container start 来重新启动。此外 docker container restart 命令会将一个正在运行的容器终止，然后重新启动。 删除本地镜像删除本地镜像使用 docker image rm命令，其格式为： 1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 其中镜像可以是镜像短 ID，镜像长 ID，镜像名或者镜像摘要 定制镜像Docker Hub 提供了很多镜像可以直接使用，对于在 Docker Hub 或者其他 Docker 仓库没有找到合适的镜像时，可以依赖某个镜像来创建符合自己需要的镜像。 这里使用 Dockerfile 来定制镜像。 这里定制的镜像以 Ngxin 镜像来基础进行创建，修改的内容为改变 Nginx 的 index.html 页面。首先创建 mynginx 目录，在 mynginx 目录中创建 Dockerfile 文件，Dockerfile 文件内容如下: 12FROM nginxRUN echo "&lt;h1&gt;Hello, Docker!&lt;/h1&gt;" &gt; /usr/share/nginx/html/index.html 接着使用 docker build -t nginx:v3 . 命令来构建这个镜像，执行该命令输出如下： 123456789Sending build context to Docker daemon 2.048kBStep 1/2 : FROM nginx ---&gt; dbfc48660aebStep 2/2 : RUN echo "&lt;h1&gt;Hello, Docker!&lt;/h1&gt;" &gt; /usr/share/nginx/html/index.html ---&gt; Running in e0233dda1b82Removing intermediate container e0233dda1b82 ---&gt; 135ca948fc71Successfully built 135ca948fc71Successfully tagged nginx:v3 接着使用 docker image ls 命令来查看本地镜像，可以看见本地镜像中已经创建好了 nginx:v3 123456[canxing@debian docker] $ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEnginx v3 135ca948fc71 40 seconds ago 109MBnginx v2 03fa889452ca About an hour ago 109MBnginx latest dbfc48660aeb 2 weeks ago 109MBhello-world latest 4ab4c602aa5e 7 weeks ago 1.84kB 接着使用 docker run --name web3 -d -p 80:80 nginx:v3 命令来启动容器，在浏览器中输入 localhost 即可看见 Nginx 的 index.html 页面已经改变。 定制一个 Docker 镜像的关键在于 Dockerfile 文件，对于 Dockerfile 文件中的指令信息请看下面。 Dockerfile指令 指令 作用 语法 备注 FROM 声明制作的镜像是以哪个镜像为基础的 FROM &lt;仓库&gt;[:&lt;标签&gt;] 每个 Dockerfile 文件必须有一个 FROM 指令，并且该指令必须是第一条指令。如果只声明了仓库名没有声明标签，那么标签默认为 latest RUN 用来执行命令行的命令 RUN &lt;命令&gt; 或者 RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] COPY 选择本地文件复制到 Docker 镜像 COPY &lt;源路径&gt;... &lt;目标路径&gt; 或者 COPY [&quot;&lt;源路径1&gt;&quot;, ..., &quot;&lt;目标路径&gt;&quot;] 这里的源路径不是指本地路径，而是 Docker 构建的上下文路径 ADD 比 COPY 更高级的复制指令 同 COPY 可以使用 RUN 或者 COPY 代替 CMD 容器启动命令 CMD &lt;命令&gt; 或者 CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...] 在容器启动时执行的命令，和 RUN 不同，RUN 是在镜像构建过程执行的命令。CMD 命令在容器启动时可以输入新命令替代 ENTRYPOINT 定义容器的入口点，指定容器启动时执行的命令 ENTRYPOINT &lt;命令&gt; 或者 ENTRYPOINT [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...] 和 CMD 不同，定义了 ENTRYPOINT 指令后，CMD 指令接受的都是参数，并且都会传递给 ENTRYPOINT 作为参数执行 ENV 设置环境变量 ENV &lt;key&gt; &lt;value&gt; 或者 ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ... 定义好环境变量后，在 ADD, COPY, ENV, EXPOSE, LABEL, USER, WORKDIR, VOLUME, STOPSIGNAL, ONBUILD 指令中都可以展开 ARG 构建参数 ARG &lt;参数名&gt;[=&lt;默认值&gt;] 和 ENV 效果相同，设置环境变量，但是 ARG 设置的环境变量在容器启动时不存在 VOLUME 设置卷 VOLUME &lt;路径&gt; 或者 VOLUME [&quot;&lt;路径1&gt;, &lt;路径2&gt; ...&quot;] EXPOSE 声明运行时容器提供服务的端口 EXPOSE &lt;端口1&gt; [&lt;端口2&gt; ...] EXPOSE 只是声明容器打算使用的端口，并不会绑定宿主端口 WORKDIR 指定工作目录，以后各层的当前目录就被改为指定的目录，如果命令不存在，WORKDIR 就会创建 WORKDIR &lt;工作目录路径&gt; USER 指定用户 USER &lt;用户名&gt; 保证用户名存在 HEALTHCHECK 告诉 Docker 应该如何进行判断容器的状态是否正常 HEALTHCHECK [选项] CMD &lt;命令&gt; 如果基础镜像有健康检查可以使用 HEALTHCHECK NONE 屏蔽。HEALTHCHECK 是 Docker 1.12 引入的新指令 ONBUILD 当以当前镜像为基础，构建下一层镜像时才会被执行 ONBUILD &lt;其他指令&gt; 导入导出镜像Docker 镜像可以本地导出再分享。导出命令如下 1docker image save -o &lt;source&gt; &lt;仓库&gt;:&lt;标签&gt; 比如导出一个 ubuntu:base 镜像使用 1docker image save -o ~/ubuntu_base.tar ubuntu:base 导入一个镜像使用 docker image load 1docker image load -i ~/ubuntu_base.tar 容器镜像是静态的，容器是动态的。容器是基于镜像创建的，每个容器包含两层，底层是基于镜像的基础层，顶层是当前容器的容器存储层，容器运行于自己独立的命名空间，容器存储层的生命周期和容器的一样，当容器消亡时，容器存储层也随之消亡。下次启动的容器又会创建新的空间和容器存储层，因此不应该向容器存储层写入任何数据，存储数据应该使用数据卷或者宿主目录。 启动容器启动一个容器使用 docker run 命令，docker run 命令可以带很多参数，有几个常用的参数 -i 打开容器的标准输入 -t 让 Docker 分配一个伪终端到容器的标准输入上 -d 保持容器后台运行 -p 指定宿主和容器之间的端口映射 –name 指定容器运行的名称 也可以使用 docker container start 命令启动一个已经终止了的容器。 查看容器信息使用 docker container ls 可以查看运行的容器信息，docker container ls -a 可以查看所有容器信息，包括终止的。 终止容器终止容器使用 docker container stop 命令。 进入容器如果在启动容器时使用了 -d 参数，那么容器会进入后台，在某些时候需要进入后台容器时，可以使用 docker attach 或者 docker exec 命令。 使用 docker attach 进入容器后退出会导致容器停止，而 docker exec 不会。建议使用 docker exec，停止容器使用 docker container stop。 docker exec 需要知道容器的 id，可以通过 docker container ls 命令查看，然后通过 docker exec -i -t &lt;id&gt; 命令进入容器。 更多参数可以通过 docker exec --help 查看 删除容器删除容器使用 docker container rm 命令。同样需要知道容器的 id，如果需要删除正在运行的容器，需要加参数 -f 数据管理容器运行与独立的空间，一个容器消亡时其容器存储层存储的数据也会丢失，对于容器中的数据管理只要有两种方式：数据卷和挂载主机目录 数据卷数据卷是一个可供一个或多个容器使用的特殊目录，数据卷可以在容器之间共享和重用，对数据卷的修改会立马生效，对数据卷的更新不影响镜像，数据卷默认一直存在，即使容器被删除。 数据卷是一个特殊的目录，他的特殊之处在于这个目录完全由 Docker 进行管理。 创建一个数据卷 1$ docker volume create my_vol 查看数据卷 123$ docker volume lsDRIVER VOLUME NAMElocal my_vol 查看数据卷详细信息 123456789101112$ docker volume inspect my_vol[ &#123; "CreatedAt": "2018-10-31T17:21:01+08:00", "Driver": "local", "Labels": &#123;&#125;, "Mountpoint": "/var/lib/docker/volumes/my_vol/_data", "Name": "my_vol", "Options": &#123;&#125;, "Scope": "local" &#125;] 数据卷的位置不能自定义，数据卷存放在 Docker 目录下的 volumes 文件夹中。Docker 目录下存放了 Docker 镜像，数据卷等，可以通过修改 Docker 目录的方式转移数据卷的位置。 在 /etc/docker/daemon.json 文件夹中写入下面内容 123&#123; "graph": "/home/canxing/.docker/registry"&#125; graph 对应的路径就是 Docker 目录对应的路径，可以修改为实际路径。修改之后，使用 systemctl restart docker 重启 Docker。 删除数据卷 1234$ docker volume rm my_volmy_vol$ docker volume lsDRIVER VOLUME NAME 挂载数据卷 12$ docker volume create my-vol$ docker run -it --mount source=my-vol,target=/opt ubuntu:base 可以在容器的 /opt 目录下添加文件，然后在数据卷本地位置上查看。 挂载主机目录Docker 允许挂载一个普通的主机目录到容器，因为这个主机目录不归 Docker 管理，因此主机目录的位置可以随意放置，但是这也会在某些情况导致该目录读取存在权限拒绝的情况。 在用户目录下创建一个目录，然后挂在到容器中。 12$ make vol$ docker run -it --mount type=bind,source=/root/vol,target=/opt ubuntu:base 挂在主机目录时，需要使用绝对路径，因此需要将 /root/vol 改为自己主机上的绝对路径]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_基本类型]]></title>
    <url>%2F2018%2F10%2F10%2FJava-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本类型 引用类型 在 Java 中，每一个变量属于一种类型。在声明变量时，变量所属的类型位于变量名之前。 Java 的类型包括：基本类型和引用类型。基本类型和引用类型的区别在于，基本类型存储在栈上，而引用类型存储在堆上，并且基本类型没有方法。 基本类型其中基本类型包括 byte, char, short, int, long, float, double, boolean。 基本类型的定义初始化如下： 12345678byte b = 0;char c = 'a';short s = 1;int i = 2;long l = 3l;float f = 1.0f;double d = 1.0;boolean bool = true; 所有基本类型在使用时必须先初始化后才能使用，否则会出现错误。 如果基本类型在类中方法之外定义但是没有初始化，那么类在创建时会对基本类型自动初始化。 123456789101112131415161718192021public class BasicTypeInit &#123; byte b; char c ; short s; int i; long l; float f; double d; boolean bool; public static void main(String[] args) &#123; BasicTypeInit bti = new BasicTypeInit(); System.out.println(bti.b); System.out.println(bti.c); System.out.println(bti.s); System.out.println(bti.i); System.out.println(bti.l); System.out.println(bti.f); System.out.println(bti.d); System.out.println(bti.bool); &#125;&#125; 输出如下： 1234567800000.00.0false 不同类型的变量初始化的值不同，byte, short, int, long 都会初始化为 0, float 和 double 初始化为 0.0，boolean 初始化为 false， char 初始化为空字符 “”。 不同类型所占用的存储空间不同 基本类型 大小 byte 1 字节 char 2 字节 short 2 字节 int 4 字节 long 8 字节 float 4 字节 double 8 字节 Java 是一门面向对象的语言，但是基本类型是一个特例，在 Java SE5 中为基本类型提供了包装功能，将基本类型对应的引用类型称为包装器类型。可以将基本类型转换为对应的包装器类型，也可以在某些时候自动的将包装器类型转换为基本类型。基本类型和其对应的包装器类型对应如下： 基本类型 包装器类型 boolean Boolean byte Byte char Character short Short int Integer long Long float Float double Double void Void 包装器对象可以进行和基本类型一样的操作，这是因为 Java SE5 的自动装箱和拆包机制，在需要的时候会将一个包装器对象转换为基本类型或者将一个基本类型封装成包装器对象。如下所示 123456789101112public class BasicAndWrapper &#123; public static void main(String[] args) &#123; int i1 = 1; Integer i2 = new Integer(1); Integer i3 = new Integer(1); float f1 = 1.2f; System.out.println(i1 == i2); System.out.println(i3 == i2); System.out.println(i1 + i2); System.out.println(f1 + i2); &#125;&#125; 输出 1234truefalse22.2 可以看见包装器对象可以和基本类型进行算数运算和比较运算，但是有趣的是，就算创建两个完全相同的包装器对象，对它们使用 == 运算的结果也为 false。这是因为包装器对象和基本类型 == 运算时，会将包装器对象拆包成基本类型，这样比较的时候就相当于比较两个数值之间的比较，而两个类对象之间的 == 运算，比较的是两个类对象的地址，也就是查看两个类对象是否指向同一个区域。 引用类型引用类型有五种：类，接口，数组，枚举，注解。 引用类型和基本类型不同，引用类型创建的变量称为引用，引用的值为对象，对象通过类创建。类是构造对象的模板或蓝图。由类构造对象的过程称为创建类的实例。 类可以是 Java 预定义的类，也可以是自定义的类。 12345public class MyClass &#123; public void main(String[] args) &#123; MyClass myClass = new MyClass(); &#125;&#125; 上述代码创建了一个简单的类，通过该类可以定义了一个引用，指向由该类创建的对象。 创建它们的语法格式如下 1MyClass myClass = new MyClass(); 通过持有对象的引用，可以访问该对象的方法或者域。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 自定义模块]]></title>
    <url>%2F2018%2F08%2F23%2Fngxin-customize-module%2F</url>
    <content type="text"><![CDATA[Nginx 有核心模块和第三方模块，我们也可以自定义模块来使用。Nginx 就像一个小型的编程语言，要添加自定义模块就要满足一些 Nginx 的编写要求，就像 C 语言必须有一个 main 函数一样。 这里大部分的内容來自于《Nginx 开发从入门到精通》，只不过整理了一下以满足我自己的思考方式，更详细的内容可以访问 《Nginx 开发从入门到精通》。ngx_http_hello_module.c 为主要模块，config 是添加自定义模块到 Nginx 时使用的。 模块所有代码在这里 配置指令Nginx 都是以指令的形式进行配置的，所以我们的自定义模块也需要自定义指令来实现功能。自定义指令需要借助于 ngx_command_t 结构体。ngx_command_t 结构体定义在 src/core/ngx_conf_file.h 文件中。 12345678struct ngx_command_s &#123; ngx_str_t name; ngx_uint_t type; char *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); ngx_uint_t conf; ngx_uint_t offset; void *post;&#125;; 在 src/core/ngx_core.h 文件中将使用 ngx_command_t 来表示 struct ngx_command_s。 1typedef struct ngx_command_s ngx_command_t; 这是关于自定义指令的描述。 12345678910111213141516171819static ngx_command_t ngx_http_hello_commands[] = &#123; &#123; ngx_string("hello_string"), NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1, ngx_http_hello_string, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_hello_loc_conf_t, hello_string), NULL &#125;, &#123; ngx_string("hello_counter"), NGX_HTTP_LOC_CONF|NGX_CONF_FLAG, ngx_http_hello_counter, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_hello_loc_conf_t, hello_counter), NULL &#125;, ngx_null_command&#125;; name 表示指令的名称，定义好后在 Nginx 配置文件中就可以直接使用该名称作为指令，比如在配置文件中可以使用 hello_string 来配置。 type 为指令接受参数的条件。条件由两部分构成：位置和参数个数。 位置由以下参数表示 名称 描述 NGX_DIRECT_CONF 可以出现在配置文件中最外层。例如已经提供的配置指令 daemon, master_process 等。 NGX_MAIN_CONF http, mail, events, error_log 等。 NGX_ANY_CONF 该配置指令可以出现在任意配置级别上。 NGX_HTTP_MAIN_CONF 可以直接出现在 http 配置指令里。 NGX_HTTP_SRV_CONF 可以出现在 http 里面的 server 配置指令里。 NGX_HTTP_LOC_CONF 可以出现在 http server 块里面的 location 配置指令里。 NGX_HTTP_UPS_CONF 可以出现在 http 里面的 upstream 配置指令里。 NGX_HTTP_SIF_CONF 可以出现在 http 里面的 server 配置指令里的 if 语句所在的 block 中。 NGX_HTTP_LMT_CONF 可以出现在 http 里面的 limit_except 指令的 block 中。 NGX_HTTP_LIF_CONF 可以出现在 http server 块里面的 location 配置指令里的 if 语句所在 block 中。 参数个数由以下参数表示 名称 描述 NGX_CONF_NOARGS 配置指令不接受任何参数。 NGX_CONF_TAKE1 配置指令接受 1 个参数。 NGX_CONF_TAKE2 配置指令接受 2 个参数。 NGX_CONF_TAKE3 配置指令接受 3 个参数。 NGX_CONF_TAKE4 配置指令接受 4 个参数。 NGX_CONF_TAKE5 配置指令接受 5 个参数。 NGX_CONF_TAKE6 配置指令接受 6 个参数。 NGX_CONF_TAKE7 配置指令接受 7 个参数。 NGX_CONF_MULTI 配置指令接受多个参数，即个数不定。 NGX_CONF_BLOCK 配置指令可以接受的值是一个配置信息。也就是一对大括号扩起来的内容。里面可以再包括很多个配置指令。比如常见的 server 指令就是这个属性。 NGX_CONF_FLAG 配置指令可以接受的值是 on 或者 off，最终会被转成 bool 值。 NGX_CONF_ANY 配置指令可以接受的任意的参数值 上面这些参数可以使用 | 进行组合，比如上面配置中 NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1 就表示定义在 http server 块中的 location 配置指令中，接受 0 个或者 1 个参数。 set 是一个函数指针，为该指令的处理函数，因为指令如何处理只有定义这个指令的人最清楚。 函数处理成功时返回 NGX_OK，否则返回 NGX_CONF_ERROR 或者一个自定义的错误信息的字符串。 函数调用时会传入三个参数： cf: 该参数里面保存从配置文件读取到的原始字符串以及相关的一些信息。特别注意的是这个参数的 args 字段是一个 ngx_str_t 类型的数组，该数组的首个元素是这个配置指令本身，第二个元素是指令的第一个参数，第三个元素是第二个参数，依次类推。 cmd: 这个配置指令对应的 ngx_command_t 结构。 conf: 就是定义的存储这个配置值的结构体。 为了方便对配置指令参数的读取，Nginx 默认提供了一些对标准类型的参数进行读取的函数，可以直接复制给 set 字段使用。 函数名称 作用 ngx_conf_set_flag_slot 读取 NGX_CONF_FLAG 类型的参数。 ngx_conf_set_str_slot 读取字符串类型的参数。 ngx_conf_set_str_array_slot 读取字符串数组类型的参数。 ngx_conf_set_keyval_slot 读取键值对类型的参数。 ngx_conf_set_num_slot 读取整数类型（有符号）的参数 ngx_conf_set_size_slot 读取 size_t 类型的参数，也就是无符号数。 ngx_conf_set_off_slot 读取 off_t 类型的参数。 ngx_conf_set_msec_slot 读取毫秒值类型的参数。 ngx_conf_set_sec_slot 读取秒值类型的参数。 ngx_conf_set_bufs_slot 读取的参数值是 2 个，一个是 buf 的个数，一个是 buf 的大小。 ngx_conf_set_enum_slot 读取枚举类型的参数，将其转换成 ngx_uint_t 类型。 ngx_conf_set_bitmask_slot 读取参数的值，并将这些参数以 bit 位的形式存储。 下面是对 hello_string 进行处理的代码。 123456789static char *ngx_http_hello_counter(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_hello_loc_conf_t* local_conf; local_conf = conf; char* rv = NULL; rv = ngx_conf_set_flag_slot(cf, cmd, conf); ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "hello_counter:%d", local_conf-&gt;hello_counter); return rv;&#125; 该函数返回的是指令接收的参数，使用 ntx_http_hello_loc_conf_t 只是为了打印一下输出。 ngx_http_hello_loc_conf_t 的定义如下。在传入 set 函数指针时，conf 指向的就是这个结构体。 1234typedef struct &#123; ngx_str_t hello_string; ngx_int_t hello_counter;&#125;ngx_http_hello_loc_conf_t; conf 该字段被NGX_HTTP_MODULE类型模块所用 (我们编写的基本上都是NGX_HTTP_MOUDLE，只有一些nginx核心模块是非NGX_HTTP_MODULE)，该字段指定当前配置项存储的内存位置。实际上是使用哪个内存池的问题。因为http模块对所有http模块所要保存的配置信息，划分了main, server和location三个地方进行存储，每个地方都有一个内存池用来分配存储这些信息的内存。这里可能的值为 NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET或NGX_HTTP_LOC_CONF_OFFSET。当然也可以直接置为0，就是NGX_HTTP_MAIN_CONF_OFFSET。 offset: 指定该配置项值的精确存放位置，一般指定为某一个结构体变量的字段偏移。因为对于配置信息的存储，一般我们都是定义个结构体来存储的。那么比如我们定义了一个结构体A，该项配置的值需要存储到该结构体的b字段。那么在这里就可以填写为offsetof(A, b)。 该字段存储一个指针。可以指向任何一个在读取配置过程中需要的数据，以便于进行配置读取的处理。大多数时候，都不需要，所以简单地设为0即可。 需要注意的是，就是在ngx_http_hello_commands这个数组定义的最后，都要加一个ngx_null_command作为结尾。 模块上下文模块上下文和 ngx_http_module_t 有关，这个结构体的定义在 src/http/ngx_http_config.h 文件。 12345678910111213typedef struct &#123; ngx_int_t (*preconfiguration)(ngx_conf_t *cf); ngx_int_t (*postconfiguration)(ngx_conf_t *cf); void *(*create_main_conf)(ngx_conf_t *cf); char *(*init_main_conf)(ngx_conf_t *cf, void *conf); void *(*create_srv_conf)(ngx_conf_t *cf); char *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf); void *(*create_loc_conf)(ngx_conf_t *cf); char *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);&#125; ngx_http_module_t; 这个变量实际上是提供一组回调函数指针，这些函数有在创建存储配置信息的对象的函数，也有在创建前和创建后会调用的函数。这些函数都将被nginx在合适的时间进行调用。 参数名称 作用 preconfiguration 在创建和读取该模块的配置信息之前被调用。 postconfiguration 在创建和读取该模块的配置信息之后被调用。 create_main_conf 调用该函数创建本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。 init_main_conf 调用该函数初始化本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串 create_srv_conf 调用该函数创建本模块位于 http server block 的配置信息存储结构，每个 server block 会创建一个。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。 merge_srv_conf 因为有些配置指令既可以出现在 http block，也可以出现在 http server block 中。那么遇到这种情况，每个 server都会有自己存储结构来存储该 server 的配置，但是在这种情况下 http block 中的配置与 server block 中的配置信息发生冲突的时候，就需要调用此函数进行合并，该函数并非必须提供，当预计到绝对不会发生需要合并的情况的时候，就无需提供。当然为了安全起见还是建议提供。该函数执行成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。 create_loc_conf 调用该函数创建本模块位于 location block 的配置信息存储结构。每个在配置中指明的 location 创建一个。该函数执行成功，返回创建的配置对象。失败的话，返回 NULL。 merge_loc_conf 与 merge_srv_conf 类似，这个也是进行配置值合并的地方。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。 Nginx 里面的配置信息都是上下一层层的嵌套的，对于具体某个 location 的话，对于同一个配置，如果当前层次没有定义，那么就使用上层的配置，否则使用当前层次的配置。 下面为该自定义模块的上下文定义 12345678910111213static ngx_http_module_t ngx_http_hello_module_ctx = &#123; NULL, ngx_http_hello_init, NULL, NULL, NULL, NULL, ngx_http_hello_create_loc_conf, NULL,&#125;; 上述配置说明了在创建和读取该模块的配置信息之后调用初始化函数，并且在 location 块中配配置信息存储结构。 ngx_http_hello_init 函数定义如下: 123456789101112131415static ngx_int_tngx_http_hello_init(ngx_conf_t *cf) &#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_hello_handler; return NGX_OK;&#125; ngx_http_hello_handler 函数定义如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static ngx_int_tngx_http_hello_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_buf_t *b; ngx_chain_t out; ngx_http_hello_loc_conf_t* my_conf; u_char ngx_hello_string[1024] = &#123;0&#125;; ngx_uint_t content_length = 0; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "ngx_http_hello_handler is called!"); my_conf = ngx_http_get_module_loc_conf(r, ngx_http_hello_module); if (my_conf-&gt;hello_string.len == 0) &#123; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "hello string is empty!"); return NGX_DECLINED; &#125; if (my_conf-&gt;hello_counter == NGX_CONF_UNSET || my_conf-&gt;hello_counter == 0) &#123; ngx_sprintf(ngx_hello_string, "%s", my_conf-&gt;hello_string.data); &#125; else &#123; ngx_sprintf(ngx_hello_string, "%s Visited Times:%d", my_conf-&gt;hello_string.data, ++ngx_hello_visited_times); &#125; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, 0, "hello_string:%s", ngx_hello_string); content_length = ngx_strlen(ngx_hello_string); if (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) &#123; return NGX_HTTP_NOT_ALLOWED; &#125; rc = ngx_http_discard_request_body(r); if (rc != NGX_OK) &#123; return rc; &#125; ngx_str_set(&amp;r-&gt;headers_out.content_type, "text/html"); if (r-&gt;method == NGX_HTTP_HEAD) &#123; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = content_length; return ngx_http_send_header(r); &#125; b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t)); if (b == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; out.buf = b; out.next = NULL; b-&gt;pos = ngx_hello_string; b-&gt;last = ngx_hello_string + content_length; b-&gt;memory = 1; b-&gt;last_buf = 1; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.content_length_n = content_length; rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) &#123; return rc; &#125; return ngx_http_output_filter(r, &amp;out);&#125; 模块的定义上面分别说了指令的配置以及模块的上下文定义，关于模块本身的定义说的不多。 对于开发一个模块来说，我们都需要定义一个 ngx_module_t 类型的变量来说明这个模块本身的信息，从某种意义上来说，这是这个模块最重要的一个信息，它告诉了 Nginx 这个模块的一些信息，上面定义的配置信息，还有模块上下文信息，都是通过这个结构来告诉 Nginx 系统的，也就是加载模块的上层代码，都需要通过定义的这个结构，来获取这些信息。 ngx_module_t 的定义在 src/core/ngx_module.h 文件 1234567891011121314151617181920212223242526272829303132333435363738394041struct ngx_module_s &#123; ngx_uint_t ctx_index; ngx_uint_t index; char *name; ngx_uint_t spare0; ngx_uint_t spare1; ngx_uint_t version; const char *signature; void *ctx; ngx_command_t *commands; ngx_uint_t type; ngx_int_t (*init_master)(ngx_log_t *log); ngx_int_t (*init_module)(ngx_cycle_t *cycle); ngx_int_t (*init_process)(ngx_cycle_t *cycle); ngx_int_t (*init_thread)(ngx_cycle_t *cycle); void (*exit_thread)(ngx_cycle_t *cycle); void (*exit_process)(ngx_cycle_t *cycle); void (*exit_master)(ngx_cycle_t *cycle); uintptr_t spare_hook0; uintptr_t spare_hook1; uintptr_t spare_hook2; uintptr_t spare_hook3; uintptr_t spare_hook4; uintptr_t spare_hook5; uintptr_t spare_hook6; uintptr_t spare_hook7;&#125;;#define NGX_MODULE_V1 \ NGX_MODULE_UNSET_INDEX, NGX_MODULE_UNSET_INDEX, \ NULL, 0, 0, nginx_version, NGX_MODULE_SIGNATURE#define NGX_MODULE_V1_PADDING 0, 0, 0, 0, 0, 0, 0, 0 在 src/core/ngx_core.h 中有如下定义: 1typedef struct ngx_module_s ngx_module_t; Nginx 为了简化配置，将前面 7 个配置使用 NGX_MODULE_V1 宏来表示，后 8 个配置使用 NGX_MODULE_V1_PADDING 宏来表示。因此只需要配置 10 个参数就行了。 1234567891011121314ngx_module_t ngx_http_hello_module = &#123; NGX_MODULE_V1, &amp;ngx_http_hello_module_ctx, //该模块的上下文 ngx_http_hello_commands, //该模块的指令集合 NGX_HTTP_MODULE, //该模块的种类 NULL, //在 master 初始化的函数 NULL, //模块初始化函数 NULL, //初始化工作进程 NULL, //初始化线程 NULL, //离开线程 NULL, //离开工作进程 NULL, //离开 master NGX_MODULE_V1_PADDING&#125;; 模块挂载定义好一个模块之后还需要把模块挂载到相应的请求处理阶段上，Nginx 有 11 个请求处理阶段，其中有 4 个阶段不能配置，剩下 7 个可以进行挂载。在 ngx_http_hello_module_ctx 中传入的指针函数 ngx_http_hello_init 就是用来挂载到相应模块上的。 123456789101112131415static ngx_int_tngx_http_hello_init(ngx_conf_t *cf) &#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_hello_handler; return NGX_OK;&#125; 其中 ngx_http_conf_get_module_main_conf 根据 conf 结构和模块得到主配置，然后使用 ngx_array_push 在 NGX_HTTP_CONTENT_PHASE 阶段进行挂载。 总结一个模块可以有多个指令，Nginx 使用 ngx_command_t 来描述一个指令，比如指令名称，指令所在位置，指令参数，指令处理函数，指令存储空间以及指令参数在哪个结构体的哪个属性等。 为了将指令的参数在回调函数中可以被明白的解析，需要定义一个结构体来存储传入的参数，这里使用的结构体是 ngx_http_hello_loc_conf_t，其中 hello_string 指令的参数通过 offsetof(ngx_http_hello_loc_conf_t, hello_string) 传入 ngx_http_hello_loc_conf_t 的 hello_string 属性。封装好后 Nginx 会将 ngx_http_hello_loc_conf_t 传入处理回调函数，因为 C 语言的原因，所以传入的指针为 void* 类型的指针，在处理函数中需要进行转换。hello_string 指令的处理函数为 ngx_http_hello_string，hello_counter 指令的处理函数为 ngx_http_hello_counter。 指令在不同阶段可能进行各种初始化工作，Nginx 定义了 ngx_http_module_t 结构体来描述一个指令的上下文环境。可以根据情况来进行上下文的初始化。 最后需要使用 ngx_module_t 结构体来描述该模块本身的信息，模块本身的信息需要传入模块上下文，模块的指令，模块的类型，以及各种钩子函数等。值得注意的是，Nginx 提供了两个宏来减少配置操作，分别时 NGX_MODULE_V1 和 NGX_MODULE_V1_PADDING。 hello 模块在模块上下文定义中，在配置读取和创建结束之后传入了 ngx_http_hello_init 函数，该函数会将模块挂载到 NGX_HTTP_CONTENT_PHASE，并且将 ngx_hettp_hello_handler 函数作为主要的处理函数。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM 配置]]></title>
    <url>%2F2018%2F08%2F12%2FVIM-config%2F</url>
    <content type="text"><![CDATA[VIM 配置 这个配置比较简单，只有有限的几个插件，涉及少数几个 VIM 命令，不同于其他 VIM 成熟的配置，如果你需要的是一个成熟的 VIM 配置，那么你应该去别的地方找找，如果你只需要一份简单的配置以便与后续的自定义，这个说不定就是你想要的。 VIM 显示界面 上述 VIM 样式是终端 VIM，对于 GUI VIM 也有一定的效果，但是不一定完全一样。 VIM 配置包括两部分，一部分是 VIM 插件，一部分 VIM 配置文件。 VIM 插件集中在 bundle 目录下，bundle 应该放在 ~/.vim/ 目录下，对于 windows 用户需要自行搜索插件存放目录。 VIM 配置文件 .vimrc 应该放在用户的根目录下，用于启动 VIM 时加载。 VIM 配置使用了以下几个插件 Vundle 用于管理其他插件的插件 nerdtree 用于在 VIM 中显示目录树的插件 gruvbox VIM 的主题插件 tabular 和 vim-markdown 是让 VIM 可以支持 Markdonw 的插件 插件和配置文件可以在这里找到]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb-学习记录]]></title>
    <url>%2F2018%2F07%2F24%2Fmongodb-note%2F</url>
    <content type="text"><![CDATA[MongoDB 学习记录 什么是 MongoDB MongoDB 的组织形式 MongoDB 有几种数据结构 如何创建数据库 那么怎么样才可以创建集合 如何删除集合和数据库 如何查看帮助文档 如何插入文档 插入一条数据 插入多条数据 如何查询插入的数据 查询全部数据 如何仅查询需要的字段 如何根据条件进行查询 如何查询 stars 大于 50 的数据 如何多条件查询 如何查询满足其中一个条件的数据 如何按照 stars 从大到小，从小到大排序 如何实现分页 如何实现分组 如何删除数据 如何删除一条数据 如何删除多条数据 如何更新数据 如何更新一条数据 如何更新多条数据 如何更新数据中的文档数据 如何删除文档类型数据中的域 如何在文档类型数据中插入新的数据 如何更新数组中的数据 如何往数组中插入新的数据 如何删除数组中的数据 如何向数组中插入另一个数组的内容 如何向数组中插入不重复数据 如何删除数组中的多个元素 如何创建索引 创建升序索引 创建降序索引 如何查看创建索引 如何删除创建的索引 什么是MongoDBMongoDB 是一个 NoSQL 数据库，和 MySQL 等关系型数据库不一样 MongoDB 更简单易用。MongoDB 是 NoSQL 的一种。 MongoDB的组织形式MongoDB 中可以有多个数据库，每个数据库中可以有多个集合，每个集合有多个文档（文档就相当于 MySQL 中的表，但是表中的数据都有相同的域，文档中的每一条数据不一定有相同的域），每个文档都有域，这些域可能存在也可能不存在，在实际使用中每个文档应该有相同的域。 MongoDB 的组织形式图解: MongoDB 和 MySQL 的对对比： MongoDB有几种数据结构MongoDB 中以下几种数据结构： 数字 字符串 布尔 日期 数组 文档（JavaScript 中的对象） 如何创建数据库MongoDB 中的数据库不用手动创建，只需要使用 use &lt;collection&gt; 就可以选择数据库，如何没有这个数据库，在创建一个集合的同时也会创建数据库 那么怎么样才可以创建集合使用以下命令就可以创建一个集合 1db.createCollection("collectionName") 如何删除集合和数据库使用以下命令可以删除一个集合，其中 &lt;collection&gt; 表示选中的集合 1db.&lt;collection&gt;.drop() 删除数据库可以使用以下命令删除，注意，这个 db 是由 use &lt;database&gt; 选中的数据库 1db.dropDatabase() 如何查看帮助文档在 Mongo shell 中直接使用 help 命令可以查看在线帮助文档 使用 db.help() 可以查看数据库相关的帮助文档 使用 db.&lt;collectionname&gt;.help() 可以查看数据库集合的相关帮助文档 如何插入文档查看 db.&lt;collectionname&gt;.help() 可以看见 MongoDB 定义了三种方式来插入文档，有 insert,insertOne,insertMany，其中 insert 用处最多，具备有 insertOne 和 insertMany 的功能。 insertOne 用于向数据库中插入单条数据的情况，insertMany 用于一条命令向数据库中插入多条数据。 插入一条数据12345678db.blog.insert(&#123; title: 'mongodb 的使用', author: 'canxing', publishDate: new Date(2018,7,16,17,31), content : 'mongodb 插入语句的实现', stars : 10, comment : []&#125;) 插入多条数据123456789101112131415161718db.blog.insert([&#123; title: 'mongodb 插入多条数据的使用', author: 'canxing', publishDate : new Date(2018,7,16,17,33), content : "mongodb 插入多条数据的实现", stars: 12, comment : []&#125;,&#123; title: 'mongodb 插入多条数据的使用2', author:'canxing', publishDate: new Date(2018, 7, 16, 17, 34), content: "mongodb 插入多条数据的实现2", stars: 2, comment : []&#125;]) 如何查询插入的数据首先保证数据库中已经插入了下面这些数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647db.blog.insert([ &#123; title: 'mongodb 数据库的创建', author: &#123; firstName: 'liu', lastName: 'xin' &#125;, publishDate: new Date(2018, 7, 20, 9, 12), content: 'mongodb 数据库的创建', stars: 30, comment:[ 'aaaa', 'bbbb', 'cccc' ] &#125;, &#123; title: "走两步", author: &#123; firstName: "tom", lastName: "jerry" &#125;, publishDate: new Date(2018, 7, 21, 8, 23), content: "随便走两步", stars: 32, comment: [ 'dddd', 'eeee', 'ffff' ] &#125;, &#123; title: "葫芦娃救爷爷", author: &#123; firstName: "忘了", lastName: "忘了" &#125;, publishDate: new Date(2018, 7, 22, 10, 23), content: "7个葫芦娃轮流救爷爷，结果都被抓了", stars: 11000, comment: [ 'gggggggggg', 'hhhhhhhhhhh', 'iiiiiiiiiii' ] &#125;]) 查询全部数据 要想查询的结果可读性更强，可以试试 pretty 方法 db.blog.find().pretty() 1db.blog.find() 如何仅查询需要的字段1db.blog.find(&#123;&#125;, &#123;title:1, author:1, publishDate:1, _id:1&#125;) 查询的第一个参数是筛选条件，{} 表示不过滤直接查询，也就是查询所有的数据，第二个参数设置需要显示的域，要显示的设置为 1, 不显示的设置为 0, _id 域默认显示，不想显示需要手动指定。 如何根据条件进行查询123db.blog.find(&#123;title: "mongodb 数据库的创建"&#125;) //根据博客名称进行查询db.blog.find(&#123;author: &#123;firstName: "liu", lastName: "xin"&#125;&#125;) //根据作者进行查询db.blog.find(&#123;comment: 'dddd'&#125;) //根据评论进行查询 上面展示了三种根据条件进行查询的方式，这种方式类似于 MySQL 中的 where 字句但是也有不同。 第一条查询语句使用 {title: &quot;mongodb 数据库的创建&quot;} 来筛选，返回所有数据中满足 title 域对应的值等于 mongodb 数据库的创建 的语句。 第二条查询语句使用 {author: {firstName: &quot;liu&quot;, lastName: &quot;xin&quot;}} 来筛选，注意，这个 author 是一个文档类型，查询的时候需要该文档类型中的所有域都相等。 第三条查询语句使用 {comment: &#39;dddd&#39;} 来筛选，comment 是一个数组类型，查询时可以使用这种方式，表示查询的数组中含有 dddd 元素的数据，也可以使用 db.blog.find({comment: [&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;]}) 来查询，使用后一种方式时要使用匹配该数组中的所有元素才行。 如何查询stars大于 50 的数据1db.blog.find(&#123;stars: &#123;$gt: 50&#125;&#125;) 在 MongoDB 中 &gt;,&lt;, 都不能使用，要使用特殊符号来表示这些。符号如下: 含义 表示 大于 $gt 小于 $lt 不等于 $ne 大于等于 $gte 小于等于 $lte 用法和示例类似 如何多条件查询1db.blog.find(&#123;stars: 32, title: "走两步"&#125;) 要查询同时满足多个条件的数据，只需要如示例添加条件就行了。 如何查询满足其中一个条件的数据如果要求返回匹配多个条件中的一个条件的数据，需要使用关键字 $or，相当于 or 语句。 1db.blog.find(&#123;$or: [&#123;stars: 32&#125;, &#123;stars: 30&#125;]&#125;) 如何按照stars从大到小从小到大排序12db.blog.find(&#123;&#125;).sort(&#123;stars:1&#125;) //升序db.blog.find(&#123;&#125;).sort(&#123;stars:-1&#125;) //降序 如何实现分页MongoDB 中也有 limit 方法，但是这个 limit 和 MySQL 中的 limit 不同，这个 limit 只会返回指定条数的数据，不能指定从什么位置开始读取。要实现和 MySQL 中的 limit 相同的功能，需要同时使用 skip 和 limit。 1db.blog.find(&#123;&#125;).skip(1).limit(1) skip 表示跳过多条数据，limit 表示只读取多条数据，这里跳过第一条，只读取一条，那么就会读取所有数据的第二条。 如何实现分组在 MySQL 中，分组首先要有一个字段，按照这个字段的不同分成不同的组。MongoDB 中也是一样，需要某一个域作为参数，返回这个参数的不同的值。 分组要 aggregate 方法和 $group 操作符，在 $group 操作符中，使用 _id 来说明分组的 key 。 1db.blog.aggregate([&#123;$group: &#123;_id:'$stars'&#125;&#125;]) //按照 stars 字段进行分组 如何删除数据删除数据可以使用 remove,deleteOne 和 deleteMany 中的某一个。 如何删除一条数据如果只想删除一条数据，使用 deleteOne，它会删除满足条件的第一条语句。 1db.blog.deleteOne(&#123;title: "mongodb 数据库的创建"&#125;) 如何删除多条数据删除多条数据使用 deleteMany 是很不错的。 1db.blog.deleteMany(&#123;stars: &#123;$gt: 30&#125;&#125;) 删除单条数据使用 deleteOne，删除多条数据使用 deleteMany，至于 remove 一般情况下不需要使用，毕竟 deleteMany 既可以删除一条也可以删除多条。 如何更新数据更新数据使用 update,updateOne 和 updateMany。 如何更新一条数据更新一条数据使用 updateOne 方法，updateOne 方法会更新第一个匹配的数据。 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$set: &#123;stars: 50&#125;&#125;) updateOne 接收两个参数，第一个参数是要修改数据的查询条件，和查询时使用的条件一样，第二个参数表示要更新的数据。 注意 ：如果没有使用 $set 那么这条数据就只有一个域那就是 {stars:50}，使用 $set 之后才会修改指定的域，不然就是覆盖整条数据。 如何更新多条数据更新多条数据使用 updateMany，使用 update 也可以，可是使用 update 需要额外添加 {multi: true}，有些时候会忘记添加，忘记添加就相当于使用 updateOne。 1db.blog.updateMany(&#123;$or: [&#123;title: "mongodb 数据库的创建"&#125;, &#123;title: "走两步"&#125;]&#125;, &#123;$set: &#123;stars: 1000&#125;&#125;) 如何更新数据中的文档数据在我们插入的数据中有 author 域，该域是一个文档类型，和普通数据类型不同，如何修改，删除，添加里面的数据 如何删除文档类型数据中的域1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$unset: &#123;'author.lastName': 1&#125;&#125;) 这里使用了 $unset，这个操作会删除一个域，&#39;author.lastName&#39; 表示 author 文档的 lastName 属性，1 表示删除。$unset 不仅可以删除一个文档中的域，也可以删除一个域。 如何在文档类型数据中插入新的数据1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$set: &#123;'author.lastName': 'xin'&#125;&#125;) 上述操作不仅可以插入新的数据，也可以用来更新数据 如何更新数组中的数据和数组有关的操作符看这里 如何往数组中插入新的数据往数组中插入新的数据使用 $push 操作符 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$push: &#123;comment: 'zzzzzzzzzz'&#125;&#125;) 如何删除数组中的数据删除数组中的数据使用 $pop 操作符和 $pull 操作符。$pop 操作符用于删除并返回数组中的第一个或最后一个元素。$pull 操作符用于精确删除数组中匹配的数据。 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$pop:&#123;comment:1&#125;&#125;) 其中 {comment: 1} 中的 1 表示弹出并删除最后一个元素 1db.blog.updateOne(&#123;title:"mongodb 数据库的创建"&#125;, &#123;$pull: &#123;comment: 'bbbb'&#125;&#125;) 如何向数组中插入另一个数组的内容如果直接使用 $push 向数组中插入一个数组的话，都将数组作为一个元素插入，而不是将数组中的所有元素依次插入。 为了将一个数组中的所有元素都插入到数组中，需要使用 $each 关键字。 1db.blog.updateOne(&#123;title:"mongodb 数据库的创建"&#125;, &#123;$push: &#123;comment: &#123;$each: [1, 2, 3, 4, 5]&#125;&#125;&#125;); 如何向数组中插入不重复数据mongodb 没有提供编程语言中集合类型相似的数据结构，只有数组，为了不插入重复数据，可以使用 $addToSet 关键字，或者在输出的时候去重。 1db.log.updateOne(&#123;title: &quot;mongodb 数据库的创建&quot;&#125;, &#123;$addToPush: &#123;comment: &#123;$each: [7, 7, 7, 7]&#125;&#125;&#125;); 如何删除数组中的多个元素只使用 $pusll 关键字无法删除数组中的多个元素，只能删除一个元素，要删除多个使用 $in 关键字。 1db.blog.updateOne(&#123;titile: "mongodb 数据库的创建"&#125;, &#123;$pull : &#123;comment: &#123;$in: [1, 2, 3, 4, 5]&#125;&#125;&#125;); 如何创建索引使用文档中某个域创建索引，使用该域进行查询时可以加快查询速度 创建升序索引1db.blog.createIndex(&#123;title:1&#125;) 创建降序索引1db.blog.createIndex(&#123;title:-1&#125;) 如何查看创建索引1db.blog.getIndexes() 如何删除创建的索引删除对应索引，删除索引时的名称不是创建索引时的名称，而是使用 getIndexes 查看的 name 属性的名称 1db.blog.dropIndex('title_1')]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-简单爬虫]]></title>
    <url>%2F2018%2F06%2F30%2Fpython-reptile%2F</url>
    <content type="text"><![CDATA[python 简单爬虫 这不是一篇完整的爬虫教程，这是一篇使用python完成简单爬虫的使用过程记录。使用 python3 以及第三方库 requests 和 lxml 以及 xpath 技术来爬取一些网页数据这里只是用了 GET 请求，没有使用 POST 请求 第三方库和技术介绍requests: 这里使用 requests 来请求一个网页，并将响应结果封装在一个对象中返回 lxml: 使用 lxml 中的 etree 库对响应的 HTML 页面进行解析 xpath: 一种解析 xml 文档的技术，也可以解析 HTML 页面。在w3c可以找到文档 过程介绍 使用 requests.get 函数请求对应的URL 如果请求正常并有返回，将返回结果通过etree.HTML处理 使用xpath技术对etree.HTML处理过的对象进行解析，获取对应的数据 数据存储 请求页面请求头使用requests.get(url)方式可以请求对应的url内容，并将响应结果封装在一个对象中返回，但是直接使用这种方式的请求头中包含这个&quot;User-Agent&quot;:&quot;python-requests/2.19.1&quot;有些服务器会通过这个请求头得知这是一个python爬虫请求从而拒绝响应。为了正常访问，需要传入一个请求头来覆盖这个属性，从而骗过请求服务器。 在firefox浏览器中通过请求http://httpbin.org/get可以获得本机的请求头，下面是我请求的该链接的部分内容 将请求中的User-Agent对应的属性作为键值对形式传入requests.get()的headers参数，如下 12header = &#123;"User-Agent":"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"&#125;response = requests.get(url, headers=header) 请求参数如果你想要传入查询参数，只需要以键值对的形式传入requests.get中的params，下面的查询键为’user’，对应的值为’tom’ 123456789data = &#123;"user":"tom"&#125;response = requests.get(url, params=data)```python如果你有多个查询值也可以添加多个键值对```pythondata = &#123;"user":"tom","pwd":"jerry"&#125;response = requests.get(url, params=data) 请求超时设置对requests.get函数的timeout参数传入一个数字可以设置请求的最长时间 1response = requests.get(url, timeout=0.1) 响应处理使用response = requests.get()之后就获取了响应结果，这时可以对响应做一些处理 响应码response.status_code返回请求的响应码，正常情况下返回200 字符设置响应返回的结果不一定可以正常显示，对response.encoding属性进行赋值可以修改返回的字符集，一般设置为utf-8 1response.encoding = 'utf-8' 返回结果response.text将数据以文本形式返回，文本形式的字符集和字符设置有关，如果没有设置则返回响应数据设置的字符集 response.content将数据以字节形式返回，使用这种方式返回就不用担心返回的数据出现乱码问题 一个完整的请求实例请求一个url并将响应结果以文本的形式返回 123456789101112131415user_agent = "User-Agent"my_user_agent = "Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"header = &#123;user_agent: my_user_agent&#125;def getPage(url, data=None) : '''根据url请求一个html页面并返回''' try : r = requests.get(url, headers=header, params=data) r.encoding = 'utf-8' if r.status_code == 200: return r.text else : raise Exception("返回页面信息失败") except : raise Exception("请求链接失败") xpath处理使用lxml中的etree库中的HTML函数可以将一个HTML页面转换为一个对象，对该对象使用xpath语法即可获取对应的数据。有关更多的xpath技术点击这里 123from lxml import etreehtml = etree.HTML(html)html.xpath(xpath) 对于使用xpath语法来获取数据，在firefox浏览器中使用这个插件，可以在线使用xpath语法来匹配 注意:使用xpath语法返回的数据都是以列表形式返回 一个完整的可以爬取腾讯社招技术类的所有招聘信息的爬虫程序]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>reptile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA社区版使用maven搭建web开发环境]]></title>
    <url>%2F2018%2F04%2F17%2FIntelljJ-IDEA-Community-Edition-maven-webapp%2F</url>
    <content type="text"><![CDATA[IDEA社区版是不支持web应用程序开发，但是IDEA支持Maven，在Maven配置文件中可以添加tomcat插件，因此可以使用IDEA进行web应用程序开发 一 新建Maven项目在选择新项目时选择maven项目，勾选 Create from archetype，在下方选择maven-archetype-webapp，点击Next 输入GroupId和ArtifactId 选择Maven位置，如果Maven已经添加到环境变量，那么可以自动找到，如果没有配置，那么需要手动添加User setting file为你的Maven配置文件，如果不是默认路径需要手动添加Local repository为你的Maven仓库，如果不是默认路径需要手动添加 最后输入工程名称和工程位置 首次使用Maven会下载一些东西需要一些时间 二 配置tomcat 首先在tomcat中添加tomcat插件 123456789101112&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;hostName&gt;localhost&lt;/hostName&gt; &lt;!-- Default: localhost --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 启动端口 Default:8080 --&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;!-- uri编码 Default: ISO-8859-1 --&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 这里使用的tomcat7 配置tomcat7 单击菜单栏 Run，选择Edit Configurations…，进入如下界面 默认只有一个Defaults，Maven是我配置好了的 选择+-&gt;Maven 输入Tomcat7，在Command line输入tomcat7:run完成配置 点击Run开始运行，打开浏览器查看结果如下]]></content>
      <categories>
        <category>ide</category>
      </categories>
      <tags>
        <tag>configure</tag>
        <tag>ide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述九-插入排序和希尔排序]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B9%9D-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序插入排序基于这样一种情况，待插入的数组是顺序的(升序或降序)，此时将插入数据从数组从后向前比较，满足条件就插入，不满足就依次向后移动 插入排序就好象玩扑克时一张一张的拿牌，大的在左边，小的在右边，每拿一张牌就从右到左一次比较，在第一张大于的牌的右边插入新的扑克 插入算法1234567891011121314typedef int ElementType;void insertSort(ElementType* array,int len)&#123; int arrayMaxIndex = len - 1; int arrayMinIndex = 0; int index = 0; int j = 0; for(index = arrayMinIndex + 1;index &lt;= arrayMaxIndex;index++)&#123; int insertValue = array[index]; for(j = index - 1;j &gt;= 0 &amp;&amp; array[j] &gt; insertValue;j--)&#123; array[j + 1] = array[j]; &#125; array[j + 1] = insertValue; &#125;&#125; 希尔排序希尔排序通过比较相距一定间隔的元素来工作，将比较的元素按照大小排列到比较元素的位置，然后通过减小间隔再次比较，最后间隔为1时所有比较完成 最上面数据为未排序数据，由上往下增量依次为 5,3,1 希尔排序算法12345678910111213141516171819202122typedef int ElementType;void shellSort(ElementType* array,int increment,int len)&#123; int arrayMinIndex = 0; int arrayMaxIndex = len - 1; int sortTime = 0; int j = 0; int insertValue = 0; //当一趟的增量大于排序数组长度时进行的处理 if(increment &gt; len)&#123; shellSort(array,1,len); &#125; for(;sortTime &lt; increment;sortTime++)&#123; //插入排序的变形 for(int i = sortTime + increment;i &lt; len;i += increment)&#123; insertValue = array[i]; for(j = i - increment;j &gt;= arrayMinIndex &amp;&amp; array[j] &gt;= insertValue;j -= increment)&#123; array[j + increment] = array[j]; &#125; array[j + increment] = insertValue; &#125; &#125;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述八-再散列]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AB-%E5%86%8D%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么是再散列再散列也是散列表的一种，不同的是再散列可以动态的扩充表长，再搭配好的散列函数解决冲突 再散列在散列表到达某一临界点时扩充原来表长的容量，再将原来散列表中的数据重新散列移动到新的散列表的过程 类型声明1234567891011121314151617181920212223242526typedef unsigned int Index;typedef Index Position;struct HashTbl;typedef struct HashTbl* HashTable;typedef int ElementType;HashTable InitializeTable(int TableSize,float Facotr);void DestroyTable(HashTable H);Position Find(ElementType key,HashTable H);HashTable Insert(ElementType key,HashTable H);void Delete(ElementType key,HashTable H);HashTable Rehash(HashTable H);static Index Hash(const int key,int TableSize);enum KindOfEntry&#123;Legitimate,Emtry,Deleted&#125;;struct HashEntry&#123; ElementType Element; enum KindOfEntry Info;&#125;;typedef struct HashEntry Cell;struct HashTbl&#123; int TableSize; int Capacity; float LocalFacotr;//装填因子 int MaxCapacity;//散列表所能容纳的最大容量，超过该容量后就要扩容 Cell* TheCells;&#125;; 这里采用当散列表容量达到指定的装填因子时进行再散列，采用的默认散列因子是 0.75，TableSize 表示散列表的长度，Capacity 表示散列表容乃数据的大小，MaxCapacity 表示散列表可以容纳的最大容量，由 TableSize × LocalFacotr 得出 散列表的插入123456789101112131415HashTable Insert(ElementType key,HashTable H)&#123; if(H == NULL) return NULL ; if(H-&gt;Capacity &gt;= H-&gt;MaxCapacity)&#123; H = Rehash(H); &#125; int index = Hash(key,H-&gt;TableSize); //如果已经在相同下标的散列表上有值，那就不管了 if(H-&gt;TheCells[index].Info != Emtry)&#123; return H; &#125; H-&gt;Capacity++; H-&gt;TheCells[index].Element = key; H-&gt;TheCells[index].Info = Legitimate; return H;&#125; 当散列表的容量超过最大容量是就要使用再散列方法 12345678910HashTable Rehash(HashTable H)&#123; if(H == NULL) return NULL; HashTable T = InitializeTable(H-&gt;TableSize &lt;&lt; 1,H-&gt;LocalFacotr); for(int i = 0;i &lt; H-&gt;TableSize;i++)&#123; if(H-&gt;TheCells[i].Element != 0) Insert(H-&gt;TheCells[i].Element,T); &#125; DestroyTable(H); return T;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述七-开放定址散列表]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%83-%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是开放定址法开放定址法是另一种不用链表解决散列表冲突问题的方法，在开放定址散列算法系统中，如果发生冲突，那么就要尝试选择另外的单元，直到找出空的单元为止 冲突解决的方法 线性探测法 平方探测法 双散列 这里使用平方探测法进行示例，平方探测法在第一次冲突时将第一次哈希值的结果加上 F(i)，如果还是冲突，那么 i 加 1 ,再次使用第一次哈希值加上 F(i) 以此循环; F(i) = i * i(i = 1) 类型声明12345678910111213141516171819202122typedef unsigned int Index;typedef Index Position;struct HashTbl;typedef struct HashTbl* HashTable;typedef int ElementType;HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(ElementType key,HashTable H);HashTable Insert(ElementType key,HashTable H);static Index Hash(const int key,int TableSize);enum KindOfEntry&#123;Legitimate,Empty,Deleted&#125;;struct HashEntry&#123; ElementType Element; enum KindOfEntry Info;&#125;;typedef struct HashEntry Cell;struct HashTbl&#123; int TableSize; int Capacity; Cell* TheCells;&#125;; 在哈希表中，保存有哈希表的表长，当前表的容量，以及存储单元，每个存储单元保存实际存储的值，以及存储单元的信息，包括已经存储，没有存储和原来有存储现在被删除三种信息 哈希表的插入1234567891011121314151617181920HashTable Insert(ElementType key,HashTable H)&#123; if(H == NULL) return NULL ; int index = Hash(key,H-&gt;TableSize); int number = 0; //检查表容量 if(H-&gt;Capacity &gt;= H-&gt;TableSize) &#123; return H; &#125; //查找可以可以插入的点 while(H-&gt;TheCells[index].Info == Legitimate)&#123; index = index + 2 * (++number) + 1; if(index &gt;= H-&gt;TableSize) index = index - H-&gt;TableSize; &#125; //插入数据，重置单元信息，表容量加1 H-&gt;TheCells[index].Element = key; H-&gt;TheCells[index].Info = Legitimate; H-&gt;Capacity++; return H;&#125; 哈希表的查找查找操作也是和插入操作差不多的，不同的是如果查找的单元为空，则说明查找不成功 123456789101112131415Position Find(ElementType key,HashTable H)&#123; if(H == 0) return -1; int index = Hash(key,H-&gt;TableSize); int number = 0; while(1)&#123; if(H-&gt;TheCells[index].Info == Empty)&#123; return -1; &#125; if(H-&gt;TheCells[index].Element == key) return index; index += 2 * (++number) + 1; if(index &gt;= H-&gt;TableSize) index = index - H-&gt;TableSize; &#125; return -1;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述六-分离链接散列表]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AD-%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是分离链接散列表分离链接散列表是散列表解决冲突的一种方法，其做法是将散列到同一个值的所有元素保留到一个表中。为方便起见，这些表都有表头 分离链接散列表的定义 123456789101112131415161718192021struct ListNode;typedef struct ListNode* Position;struct HashTbl;typedef struct HashTbl* HashTable;typedef int ElementType;HashTable InitializeTable(int TableSize);void DestroyTable(HashTable H);Position Find(ElementType key,HashTable H);void Insert(ElementType key,HashTable H);ElementType Retrieve(Position P);static int Hash(const int key,int TableSize);struct ListNode&#123; ElementType Element; Position Next;&#125;;typedef Position List;struct HashTbl&#123; int TableSize; List* TheList;&#125;; 分离链接散列表的初始化分离链接散列表在数组的每个位置保存有冲突元素组成链表的表头 123456789101112HashTable InitializeTable(int TableSize)&#123; HashTable H = NULL; H = (HashTable)malloc(sizeof(struct HashTbl)); if(H == NULL) return NULL; H-&gt;TableSize = TableSize; H-&gt;TheList = (List*)malloc(sizeof(struct ListNode) * TableSize); for(int i = 0;i &lt; TableSize;i++)&#123; H-&gt;TheList[i] = (List)malloc(sizeof(struct ListNode)); H-&gt;TheList[i]-&gt;Next = NULL; &#125; return H;&#125; 分离链接散列表的插入插入时先计算Hash值，然后将值作为对应表头的第一个元素，这里就相当与链表的头插法 12345678910void Insert(ElementType key,HashTable H)&#123; if(H == NULL) return ; int index = Hash(key,H-&gt;TableSize); Position ptr = H-&gt;TheList[index]; Position temp = (List)malloc(sizeof(struct ListNode)); if(temp == NULL) return ; temp-&gt;Element = key; temp-&gt;Next = ptr-&gt;Next; ptr-&gt;Next = temp;&#125; 分离链接散列表的查找查找时首先计算要查找值的Hash值，然后返回对应的表头，遍历链表，找到就返回 123456789101112Position Find(ElementType key,HashTable H)&#123; if(H == NULL) return NULL; int index = Hash(key,H-&gt;TableSize); Position ptr = H-&gt;TheList[index]; ptr = ptr-&gt;Next; while(ptr != NULL)&#123; if(ptr-&gt;Element == key) return ptr; ptr = ptr-&gt;Next; &#125; return NULL;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述五-伸展树]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%94-%E4%BC%B8%E5%B1%95%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是伸展树伸展树保证了从空树开始任意连续 M 次对树的操作最多话费 O(M log N) 时间，伸展树是二叉搜索树的一种变形，不同于 AVL 树，伸展树不需要维护节点的高度，相对 AVL 树来说比较容易实现 当一个节点被访问时它就有可能在不久之后被再次访问，因此，伸展树的基本思想是：当一个节点被访问，它就经过一系列 AVL 树的旋转操作将该节点放到根上 将某个节点经过一系列的变形移动到树根上的操作称之为伸展(Splay)，伸展操作主要进行六个形态的转变，再将伸展节点伸展之后会再次检查伸展节点的位置，如果伸展节点是根结点则返回，否则继续伸展 伸展树声明12345678910111213141516171819202122SplayTree MakeEmpty(SplayTree T);Position Find(ElementType X,SplayTree T);Position FindMin(SplayTree T); Position FindMax(SplayTree T);SplayTree Insert(ElementType X,SplayTree T); SplayTree Delete(ElementType X,SplayTree T);ElementType Retrieve(Position P);Position FindPositionUp(SplayTree T,ElementType X);void printTree(SplayTree T);static Position SingleRotaleWithLeft(Position T);static Position SingleRotaleWithRight(Position T);static Position ContinuRotaleWithLeft(Position T);static Position ContinuRotaleWithRight(Position T);static Position DoubleRotaleWithLeft(Position T);static Position DoubleRotaleWithRight(Position T);static Position Splay(ElementType X,SplayTree T);struct TreeNode&#123; ElementType Element; SplayTree Left; SplayTree Right;&#125;; 伸展功能伸展功能依赖于 6 个函数分别时左旋转，右旋转，连续左旋转，连续右旋转，左双旋转，右双旋转，分别对应 6 中变形 12345678910111213141516171819202122232425262728293031323334//左旋转static Position SingleRotaleWithLeft(Position T)&#123; Position ptr = T-&gt;Left; T-&gt;Left = ptr-&gt;Right; ptr-&gt;Right = T; return ptr;&#125;//右旋转static Position SingleRotaleWithRight(Position T)&#123; Position ptr = T-&gt;Right; T-&gt;Right = ptr-&gt;Left; ptr-&gt;Left = T; return ptr;&#125;//连续左旋转static Position ContinuRotaleWithLeft(Position T)&#123; Position ptr = SingleRotaleWithLeft(T); return SingleRotaleWithLeft(ptr);&#125;//左双旋转static Position DoubleRotaleWithLeft(Position T)&#123; T-&gt;Right = SingleRotaleWithLeft(T-&gt;Right); return SingleRotaleWithRight(T);&#125;//连续右旋转static Position ContinuRotaleWithRight(Position T)&#123; Position ptr = SingleRotaleWithRight(T); return SingleRotaleWithRight(ptr);&#125;//右双旋转static Position DoubleRotaleWithRight(Position T)&#123; T-&gt;Left = SingleRotaleWithRight(T-&gt;Left); return SingleRotaleWithLeft(T);&#125; 伸展树的伸展流程如下: 伸展节点为根节点，不做任何改变，并返回 伸展节点是根结点的左儿子，将伸展节点向左旋转 伸展节点是根结点的右儿子，将伸展节点向左旋转 伸展节点不属于上述三种情况，将伸展节点称为X,X的父结点称为F，F的父结点称为G，G节点就是X节点的’祖父’节点4.1. 如果G的左儿子是F，并且F的左儿子是X，进行连续左旋转4.2. 如果G的右儿子是F，并且F的右儿子是X，进行连续右旋转4.3. 如果G的左儿子是F，并且F的右儿子是X，进行左双旋转4.4. 如果G的右儿子是F，并且F的左儿子是X，进行有双旋转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static Position Splay(ElementType X,SplayTree T)&#123; if(T == NULL || T-&gt;Element == X) return T; //查找伸展节点的父结点 Position fatherNode = FindPositionUp(T,X); if(fatherNode == T)&#123; if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123; //伸展节点属于根结点的左儿子 return SingleRotaleWithLeft(fatherNode); &#125;else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123; //伸展节点属于根结点的右儿子 return SingleRotaleWithRight(fatherNode); &#125; &#125;else&#123; Position grandNode = FindPositionUp(T,fatherNode-&gt;Element); Position grandGrandNode = FindPositionUp(T,grandNode-&gt;Element); Position temp = NULL; int level = -1; //判断伸展节点，父结点和祖父节点的关系 if(grandNode-&gt;Left != NULL &amp;&amp; grandNode-&gt;Left == fatherNode)&#123; if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123; level = 1; &#125;else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123; level = 2; &#125; &#125;else if(grandNode-&gt;Right != NULL &amp;&amp; grandNode-&gt;Right == fatherNode)&#123; if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123; level = 3; &#125;else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123; level = 4; &#125; &#125; switch(level)&#123; case 1://左左 temp = ContinuRotaleWithLeft(grandNode); break; case 2://左右 temp = DoubleRotaleWithRight(grandNode); break; case 3://右左 temp = DoubleRotaleWithLeft(grandNode); break; case 4://右右 temp = ContinuRotaleWithRight(grandNode); break; &#125; if(grandNode == T) return temp; else if(grandGrandNode-&gt;Left == grandNode) grandGrandNode-&gt;Left = temp; else if(grandGrandNode-&gt;Right == grandNode) grandGrandNode-&gt;Right = temp; return Splay(X,T); &#125;&#125; 查询操作查询操作先要确定树中含有要查询的节点，如果没有则直接返回，否则将查询到的节点进行伸展移动到根结点然后返回 12345678910111213Position Find(ElementType X,SplayTree T)&#123; if(T-&gt;Element == X) return T; Position dst = T; while(dst != NULL &amp;&amp; X != dst-&gt;Element)&#123; if(X &lt; dst-&gt;Element) dst = dst-&gt;Left; else if(X &gt; dst-&gt;Element) dst = dst-&gt;Right; &#125; if(dst != NULL) return Splay(X,T); return T;&#125; 插入操作插入操作先将元素按照二叉搜索树的性质插入树中，然后在将插入的节点伸展到根结点 12345678910111213141516171819202122232425262728293031SplayTree Insert(ElementType X,SplayTree T)&#123; Position temp = NULL; temp = (SplayTree)malloc(sizeof(struct TreeNode)); if(temp == NULL)&#123; printf("初始化树失败\n"); return NULL; &#125; temp-&gt;Element = X; temp-&gt;Left = temp-&gt;Right = NULL; if(T == NULL)&#123; T = temp; return T; &#125; Position ptr = T; //按照二叉搜索树的性质插入节点 while(1)&#123; if(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left != NULL)&#123; ptr = ptr-&gt;Left; &#125;else if(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right != NULL)&#123; ptr = ptr-&gt;Right; &#125;else if(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left == NULL)&#123; ptr-&gt;Left = temp; break; &#125;else if(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right == NULL)&#123; ptr-&gt;Right = temp; break; &#125; &#125; return Splay(X,T);&#125; 删除操作删除操作先将删除节点伸展到根结点，此时，根结点的左子树元素都小于根节点，右子树元素都大于根结点，删除根结点，然后将左子树的最大元素进行伸展，此时左子树根结点是左子树中的最大元素，没有右儿子，然后再将左子树的右指针指向右子树，删除完成 1234567891011121314SplayTree Delete(ElementType X,SplayTree T)&#123; if(T == NULL) return NULL; if(X == T-&gt;Element)&#123; if(T-&gt;Left == NULL) return T-&gt;Right; else if(T-&gt;Right == NULL) return T-&gt;Left; //再查找最大元素的同时就对最大元素进行了伸展操作 Position left = FindMax(T-&gt;Left); left-&gt;Right = T-&gt;Right; free(T); return left; &#125; T = Splay(X,T); return Delete(X,T);&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述四-AVL树]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%9B%9B-AVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AVL 树是带有平衡条件的二叉查找树，所谓平衡条件就是:任何节点的深度均不得过深，如下图所示的二叉查找树是不应该出现的 一颗 AVL 树是其每个节点的左子树和右子树的高度最多差1的二叉查找树（空树的高度定义为-1），这是一颗 AVL 树，树的高度为 3 AVL树的定义123456789101112131415161718192021//头文件中的函数定义struct AvlNode;typedef struct AvlNode* Position;typedef struct AvlNode* AvlTree;typedef int ElementType ;AvlTree MakeEmpty(AvlTree T);Position Find(ElementType X,AvlTree T);Position FindMin(AvlTree T);Position FindMax(AvlTree T);AvlTree Insert(ElementType X,AvlTree T);AvlTree Delete(ElementType X,AvlTree T);ElementType Retrieve(Position P);//具体实现文件中的树节点定义，这里的树节点元素使用int类型struct AvlNode&#123; ElementType Element; AvlTree Left; AvlTree Right; int Height;&#125;; 可以看见，AVL 树和二叉查找树的定义没有什么区别，在节点定义上多了一个变量用来存储树的高度 AVL树的实现AVL 树的不同主要体现在插入和删除时的不同，在插入和删除时都有可能破坏 AVL 树的平衡，此时就需要对 AVL 树进行平衡修复 AVL树的插入实现图摘自维基百科 进行插入操作时，有四种情况可能破坏AVL树的平衡，我们把被破坏的平衡的节点称为root 对 root 左儿子的左子树进行一次插入，对应上图的左左情况 对 root 右儿子的右子树进行一次插入，对应上图的右右情况 对 root 左儿子的右子树进行一次插入，对应上图的左右情况 对 root 右儿子的左子树进行一次哈入，对应上图的右左情况 对于 1，2 情况，插入节点相对于 root 节点的’外侧’，这时只需要对 root 节点和 root 节点的左儿子或者右儿子进行一次右旋转或者左旋转就可以了; 3，4 情况相对于 root 节点的’内侧’，这是需要实行两次的旋转达到平衡 注意，无论是一次旋转还是两次旋转，都是为了满足二叉查找树的性质和平衡条件 下图演示了依次将 3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9 插入 AVL 树的过程，带箭头的表示插入时使用了旋转操作 上图演示了从1到7顺序插入AVL树的过程，这里都是1和2的情况 插入代码实现123456789101112131415161718192021222324252627AvlTree Insert(ElementType X,AvlTree T)&#123; if(T == NULL)&#123; T = (AvlTree)malloc(sizeof(struct AvlNode)); if(T == NULL) return NULL; T-&gt;Left = T-&gt;Right = NULL; T-&gt;Element = X; T-&gt;Height = 0; &#125;else&#123; if(X &gt; T-&gt;Element)&#123; T-&gt;Right = Insert(X,T-&gt;Right); if(Height(T-&gt;Right) - Height(T-&gt;Left) == 2) if(X &gt; T-&gt;Right-&gt;Element) T = SingleRotaleWithRight(T); else T = DoubleRotaleWithRight(T); &#125;else&#123; T-&gt;Left = Insert(X,T-&gt;Left); if(Height(T-&gt;Left) - Height(T-&gt;Right) == 2) if(X &lt; T-&gt;Left-&gt;Element) T = SingleRotaleWithLeft(T); else T = DoubleRotaleWithLeft(T); &#125; &#125; T-&gt;Height = max(Height(T-&gt;Left),Height(T-&gt;Right)) + 1; return T;&#125; AVL树的删除实现AVL树的删除实现比起插入实现要复杂 基本想法是删除成功时，修正删除路径上节点高度，然后判断删除路径上的节点的平衡，然后进行旋转 删除失败时，不改变任何东西 由于删除功能是按照本人自己的想法实现，实现过程较长，这里不进行展示，如有兴趣可以查看参考源码 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述三-二叉查找树]]></title>
    <url>%2F2018%2F03%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%89-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树是二叉树的特殊形式，主要性质是，对于树中的每个节点X，它的左子树中所有值小于X的值，而它的右子树中所有值大于X的值 因此，二叉查找树可以用某种统一的方式排序 根据这一性质，可以对二叉查找树有如下的函数定义 12345678910111213141516171819202122//头文件中的函数定义struct TreeNode;typedef struct TreeNode* Position;typedef struct TreeNode* SearchTree;typedef int ElementType;SearchTree MakeEmpty(SearchTree T);Position Find(ElementType X,SearchTree T);Position FindMin(SearchTree T);Position FindMax(SearchTree T);SearchTree Insert(ElementType X,SearchTree T);SearchTree Delete(ElementType X,SearchTree T);ElementType Retrieve(Position P);Position FindPositionUp(SearchTree T,ElementType X);//具体实现文件中树节点的定义，这里将树节点元素类型定义为int类型typedef int ElementType;struct TreeNode&#123; ElementType Element; SearchTree Left; SearchTree Right;&#125;; 函数实现 二叉查找树中最主要的两个功能就是插入数据和删除数据，在插入和删除数据之后需要保持整个二叉查找树任然具备二叉查找树的性质，这是很关键的 插入功能的实现根据二叉查找树的性质，那么要插入的数据是出入叶子节点实现算法如下: 判断插入元素与根节点元素的大小: 如果被插入的树是空树，那么分配内存空间并将新节点插入空树中; 如果插入元素大于根节点元素，使用递归的方式将插入元素插入到根节点的右子树上; 如果插入元素小于根节点元素，使用递归的方式将插入元素插入根节点的左子树上; 如果插入元素等于根节点元素，什么也不做 代码实现如下 12345678910111213141516SearchTree Insert(ElementType X,SearchTree T)&#123; if(T == NULL)&#123; T = (SearchTree)malloc(sizeof(struct TreeNode)); if(T == NULL) &#123; printf("初始化树失败\n"); return NULL; &#125; T-&gt;Element = X; T-&gt;Left = T-&gt;Right = NULL; &#125;else if(X &lt; T-&gt;Element)&#123; T-&gt;Left = Insert(X,T-&gt;Left); &#125;else if(X &gt; T-&gt;Element)&#123; T-&gt;Right = Insert(X,T-&gt;Right); &#125; return T;&#125; 删除功能的实现删除功能相比于插入功能要困难， 如果删除的节点是叶子节点直接删除就行了， 如果删除的节点不是叶子节点，那么就需要找到一个节点来代替这个删除节点继续维持性质 删除功能算法如下: 如果删除元素小于根节点元素，就去根节点的左子树删除该元素 如果删除元素大于根节点元素，就去根节点的右子树删除该元素 如果删除元素等于根节点元素，并且这个根节点还有两个子节点，先找到根节点右子树的最小值(或者根节点左子树的最大值)，将根节点的值修改为右子树的最小值(或者左子树的最大值)，然后去根节点的右子树删除最小值(或者去根节点的左子树删除最大值)。这里实际上把删除一个根节点改变为删除一个叶子节点 如果删除元素等于根节点，并且这个根节点只有一个或者没有子节点4.1 如果根节点只有右节点，将根节点变为右节点4.2 如果根节点只有左节点，将根节点变为左节点4.3 如果根节点没有子节点，参照4.1 代码实现如下 1234567891011121314151617181920212223SearchTree Delete(ElementType X,SearchTree T)&#123; Position ptr = T; if(T == NULL) return T; else if(X &lt; T-&gt;Element) T-&gt;Left = Delete(X,T-&gt;Left); else if(X &gt; T-&gt;Element) T-&gt;Right = Delete(X,T-&gt;Right); else if(T-&gt;Left != NULL &amp;&amp; T-&gt;Right != NULL)&#123; //找到根节点右子树的最小值 ptr = FindMin(T-&gt;Right); //将右子树的最小值赋给根节点 T-&gt;Element = ptr-&gt;Element; //前往右子树删除最小值 T-&gt;Right = Delete(T-&gt;Element,T-&gt;Right); &#125;else&#123; ptr = T; if(T-&gt;Left == NULL)&#123; T = T-&gt;Right; &#125;else if(T-&gt;Right == NULL)&#123; T = T-&gt;Left; &#125; free(ptr); &#125; return T;&#125; 二叉查找树可以方便的查找，但是在某些情况下，如果在二叉查找树中依次插入 1,2,3,4,5,6，那么得到的二叉查找树图如下: 这样的情况不是我们想看见的，在这种情况下使用平衡二叉树可以改善这个问题 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-collect方法]]></title>
    <url>%2F2018%2F01%2F13%2Fjava8-collect%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[collect方法collect 方法是 Stream 中一个很重要的方法，通过这个方法可以将流中的数据格式转换为需要的形式，如，List，Set，Map，求流数据的总数，流中数据某条属性的平均值或者其他值，将流中的字符串拼接为一条字符串等。 收集器是 Stream 用于收集某种形式的数据信息，基本上所有的 Stream 的终端操作都可以使用 collect 方法来实现 collect的定义collect 方法有两种形式 123456方法原型1&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);方法原型2&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 这里主要使用方法原型 2,这个方法原型接收一个实现了 Collector 接口的对象，Collector 接口有五个抽象方法，幸运的是 java8 封装了一些常用的方法供我们使用，这些常用方法封装在 java.util.stream.Collectors 对象中，这个对象含有多个静态方法，用来返回 Collector 对象 collect 方法示例Apple.java 1234567891011public class Apple &#123; private int weight; private String color; public Apple(int weight, String color) &#123; super(); this.weight = weight; this.color = color; &#125; //getter //setter&#125; Main.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Main &#123; public static void main(String[] args) &#123; List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,"green"), new Apple(20,"red"), new Apple(12,"red"), new Apple(12,"red"), new Apple(25,"green")); //返回重量最重的苹果 System.out.println("-------------------返回重量最重的苹果----------------"); Optional&lt;Apple&gt; heaviestApple = inventory.stream().collect(Collectors.maxBy(Comparator.comparing(Apple::getWeight))); System.out.println(heaviestApple); //返回重量最轻的苹果 System.out.println("-------------------返回重量最轻的苹果----------------"); Optional&lt;Apple&gt; lightestApple = inventory.stream().collect(Collectors.minBy(Comparator.comparing(Apple::getWeight))); System.out.println(lightestApple); //返回苹果的总重量 System.out.println("-------------------返回苹果的总重量----------------"); int sumInt = inventory.stream().collect(Collectors.summingInt(Apple::getWeight)); System.out.println(sumInt); //使用Collectors.averagingInt方法求苹果的平均重量 System.out.println("-------------------求苹果的平均重量-----------------"); double averageWeight = inventory.stream().collect(Collectors.averagingDouble(Apple::getWeight)); System.out.println(averageWeight); //返回苹果的重量的各个数据 System.out.println("-------------------返回苹果重量的各个数据属性-----------------"); IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); System.out.println(intSummartStatistics); //将所有苹果颜色拼接为一个字符串 System.out.println("-------------------将所有苹果颜色拼接为一个字符串-----------------"); //joining会自动将流中的数据拼接为字符串，在处理时需要保证流中的数据都是字符串 String appleColors = inventory.stream() .map(Apple::getColor) //将流中的apple转换为apple的颜色 .collect(Collectors.joining(/*将每一个颜色后面加上一个空格*/" ")); System.out.println(appleColors); //返回苹果数量 System.out.println("-------------------返回苹果的总数量-----------------"); Long count = inventory.stream().collect(Collectors.counting()); System.out.println(count); //分组 System.out.println("-------------------将苹果按照苹果颜色进行分组----------------"); Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); System.out.println(appleColorMap); System.out.println("-------------------将苹果按照苹果颜色和重量进行分组 ----------------"); System.out.println(inventory.stream().collect(Collectors.groupingBy(Apple::getColor, Collectors.groupingBy(apple -&gt; &#123; if(apple.getWeight() &gt; 10 &amp;&amp; apple.getWeight() &lt; 20) return "一般"; else if(apple.getWeight() &gt;= 20 ) return "很重"; else return "轻"; &#125;)))); //收集每个颜色的苹果有多少个 System.out.println("-------------------收集每个颜色的苹果有多少个----------------"); Map&lt;String, Long&gt; colorCount = inventory.stream().collect(Collectors.groupingBy(Apple::getColor,Collectors.counting())); System.out.println(colorCount); //分区 System.out.println("-------------------根据苹果颜色进行分区----------------"); Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals("red"))); System.out.println(colorPartition); //归约 System.out.println("-------------------归约操作----------------"); System.out.println(inventory.stream().collect(Collectors.reducing(0,Apple::getWeight,(a,b) -&gt; a + b))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing((a,b) -&gt; &#123; if(a &gt; b) return a; else return b; &#125;))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing(100,(a,b) -&gt; &#123; if(a &gt; b) return a; else return b; &#125;))); &#125;&#125; 上面代码使用了大多数 Collectors 的方法，还有一些类型的方法,如: averagingDouble,averagingInt,averagingLong 都是相同的。 Collectors 中的方法大致分为分组，分区，容器（返回list，set，map），简单的数值计算和其他 其中分组和分区是有区别的，分区可以看做是分组的特殊形式，分区只会有两个区别满足条件的（true）和不满足条件的（false），不管是分区还是分组，都可以再分,分组是根据返回的条件进行分组 1Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); 这里就是根据苹果的颜色进行分组，map 中只会有两个主键，red 或者 green。如果将条件改为 Apple::getWeight，那么主键就会有 10,20,12,25，因为有两个重量为 12 的苹果，这两个苹果就会分在一组 1Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals("red"))); 这里根据苹果颜色是不是红色进行分区，只会有两个主键，true 或者 false，true 分区里的苹果都是红色的，false 分区里的值都不是红色的，但是 partitioningBy 里面可以传第二个参数，可以对分区里面再进行收集（collect方法）操作 容器可以为三种，List，Set，Map 容器，只需要调用 Collectors.toXxxx() 方法就可以将流最后组装成一个容易 简单的数值计算可以直接通过流计算得出，例如 Stream.max() 方法和 Stream.collect(Collectors.maxBy()) 方法是相同的，在某些方面，如 1IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); 可以返回多种数据的不同运算结果，还是很方便的 collect 方法接收一个 Collector 对象，而大多数的 Collector 对象都可以通过 Collectors 对象的静态工厂方法获取，如果有需要可以查阅手册]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-使用流]]></title>
    <url>%2F2018%2F01%2F12%2Fjava8-%E4%BD%BF%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[流介绍流是java API的新成员，他允许你以声明的方式处理数据集合（通过查询语句，而不是临时编写一个实现） 使用流集合是流最容易上手的方式，Java8 中的集合支持一个新的stream方法，他会放回一个流对象（接口定义在java.util.stream.Stream）中 使用流可以完成什么事？他可以让我们以一种流水线的方法处理集合数据 像我们前面处理苹果集合时那样，可以实现一个方法来收集或处理某些数据，比如过滤颜色不是红色的苹果，收集苹果的重量列表，但是每一次都需要调用一个方法，流为我们处理这种“一系列”数据提供了一些方法，可以像工厂流水线的方法对流数据进行处理 比如要收集颜色是红色苹果的重量集合，可以想这样写 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).map(Apple::getWeight).forEach(System.out::println); 这里先通过方法stream()生成一个流对象，再使用filter方法过滤掉颜色不是红色的苹果，接着通过map将所有颜色是红色的苹果的重量返回成一个数值流也就是剩下苹果重量的集合，接着调用forEach方法打印剩下苹果的重量。可以读作先过滤掉颜色不是红色的苹果，接着返回所有苹果重量的集合，然后打印如果使用上一节自定义方法实现这些操作书写格式如下: inventory = filter(inventory,apple -&gt; apple.getColor().equals(&quot;red&quot;)); List&lt;Integer&gt; weights = map(inventory,Apple::getWeight); forEach(weights, System.out::println); 可以看见流的可读性以及书写性都要高于自定义实现 流方法流的方法分为两类，一类是中间操作，一类是终端操作，中间操作是对流完成操作之后还会返回一个流对象，而终端操作的返回结果是任何不是流的值，前面的filter，map就是中间操作，forEach就是终端操作 使用流方法对苹果库存进行操作 使用forEach打印数据 inventory.stream().forEach(System.out::println); 筛选颜色为红色的苹果 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).forEach(System.out::println); 对苹果颜色进行排序，如果个颜色相同，根据重量大小由小到大排序 Comparator&lt;Apple&gt; colorSort = (a1,a2) -&gt; a1.getColor().compareTo(a2.getColor()); Comparator&lt;Apple&gt; weightSort = (a1,a2) -&gt; a1.getWeight() - a2.getWeight(); inventory.stream().sorted(colorSort.thenComparing(weightSort)).forEach(System.out::println); 去除颜色和重量相同的苹果 inventory.stream().distinct().forEach(System.out::println); 只获取前三个苹果 inventory.stream().limit(3).forEach(System.out::println); 跳过前面两个苹果，只获取后面三个 inventory.stream().skip(2).forEach(System.out::println); 不要第一个苹果也不要最后一个苹果 inventory.stream().skip(1).limit(inventory.size() - 2).forEach(System.out::println); 将所有苹果的重量加10 inventory.stream().peek(apple -&gt; apple.setWeight(apple.getWeight() + 10)).forEach(System.out::println); 查看有没有重量是20,颜色是红色的苹果 System.out.println(inventory.stream().anyMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是所有苹果的重量是20,颜色是红色 System.out.println(inventory.stream().allMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是没有苹果是红色的 System.out.println(inventory.stream().noneMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看第一个苹果 System.out.println(inventory.stream().findFirst()); 返回苹果的总重量 System.out.println(inventory.stream().map(Apple::getWeight).reduce(0, (a,b) -&gt; (a + b))); 返回苹果的最小重量 System.out.println(inventory.stream().map(Apple::getWeight).min((n1,n2) -&gt; n1 - n2)); 返回苹果的最大重量 System.out.println(inventory.stream().map(Apple::getWeight).max((n1,n2) -&gt; n1 - n2)); 流的终端操作 方法 作用 boolean allMatch(Predicate&lt;? super T&gt; predicate) 如果流对象都可以匹配谓词，返回true，否则返回false boolean anyMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中有一个或多个匹配谓词，返回true，否则返回false boolean noneMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中任何一个都没有匹配谓词，返回true，否则返回false Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最大值 Oprional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最小值 Optional&lt;T&gt; findAny() 未知 Optional&lt;T&gt; findFirst() 返回流对象中的第一个值 long count() 返回流中数据的个数 &lt;R,A&gt; R collect(Collecotr&lt;? super T,A,R&gt; collector) 未知 &lt;R&gt; R collecot(Supplier&lt;R&gt; supplier,BiConsumer&lt;R,? super T&gt; accumulator,BiConsumer&lt;R,R&gt; combiner) 未知 void forEach(Consumer&lt;? super T&gt; action) 未知 void forEachOrDered(Consumer&lt;? super T&gt; action) 未知 Oprional&lt;T&gt; reduce&lt;T identity,BinaryOperator&lt;T&gt; accumulator) 未知 &lt;U&gt; U reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner) 未知 Object[] toArray() 未知 &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) 未知 流的中间操作 方法 作用 distinct() 去重，流中的对象需要实现equlas方法 filter(Predicate&lt;? super T&gt; predicate) 按照规则过滤，满足规则的留下，不满足的去掉 limit(long maxSize) 返回数据的最大个数，10表示返回10个数据，5表示返回5个 map(Function&lt;? super T,? extends R&gt; mapper) 将每个流对象作为函数的参数，并且将返回值填充流对象 flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 将每个流对象作为函数的参数，但是只返回一个流对象 peek(Consumer&lt;? super T&gt; action) 可以在流处理时对每个流数据进行操作，并返回Stream对象 skip(long n) 跳过n个数据，n等于10,表示跳过前面10个数据，和limit方法一起使用效果更好 sorted() 默认排序，排序类需要实现默认排序接口 sorted(Comparator&lt;? super T&gt; comparator) 使用自定义排序对流数据进行排序 值得注意的是flatMap方法，这个方法和map方法不同，map方法会将每一个流对象都作用于Function&lt;? super T,? extends R&gt;返回一个R对象，flatMap方法也会将所有的流对象作用于Function的方法，但是只会返回一个`流对象`，这个方法可以用作一个流中的对象的属性是集合，并且需要将所有流对象为集合的属性收集起来的情况，比如收集几个字符串中所有不重复的字符。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-复合lambda表达式]]></title>
    <url>%2F2018%2F01%2F11%2Fjava8-%E5%A4%8D%E5%90%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java8中的函数式借口提供了允许你进行复合的方法，可以把多个lambda表达式复合成更复杂的表达式,就好像与操作(and)，或操作(or)，非操作(not)，以及组合操作 Predicate系列的组合操作接口 相关方法 Predicate&lt;T&gt; Predicate&lt;T&gt; negate() Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) DoublePredicate negate() DoublePredicate DoublePredicate and(DoublePredicate other) DoublePredicate or(DoublePredicate other) IntPredicate negate() IntPredicate IntPredicate and(IntPredicate other) IntPredicate or(IntPredicate other) LongPredicate negate() LongPredicate LongPredicate and(LongPredicate other) LongPredicate or(LongPredicate other) BiPredicate&lt;T,U&gt; negate() BiPredicate&lt;T,U&gt; BiPredicate&lt;T,U&gt; and(BiPredicate&lt;? super T,? super U&gt; other) BiPredicate&lt;T,U&gt; or(BiPredicate&lt;? super T,? super U&gt; other) Predicate系列的每个借口都含有and,or,not操作，可以和其他相同的借口进行组合对于苹果类，根据苹果的颜色和重量筛选符合要求的苹果可以有 //筛选颜色为红色的苹果 Predicate&lt;Apple&gt; redApple = (Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;); //筛选苹果重量大于15的苹果 Predicate&lt;Apple&gt; weightApple = apple -&gt; apple.getWeight() &gt; 15; //对苹果的颜色和重量筛选进行复合，筛选出即是红色重量有大于15的苹果 List&lt;Apple&gt; filterApples = filter(inventory,redApple.and(weightApple)); //筛选出是红色或者重量大于15的苹果 filterApples = filter(inventory,redApple.or(weightApple)); //筛选出既不是颜色既不是红色重量也不大于15的苹果 filterApples = filter(inventory,redApple.negate().or(weightApple.negate())); Function系列的组合操作接口 相关方法 Function&lt;T,R&gt; Function&lt;T,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before) BiFunction&lt;T,U,R&gt; BiFunction&lt;T,U,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function系列的接口只有Function和BiFunction可以进行复合操作 Function的意思是函数，作为函数，具有参数和返回值，类似于f(x) = x + 1, 那么Function的addThen方法可以理解为将我的返回值作为别的函数的参数，在别的函数中进行函数运算。 如果说有两个函数 f(x) = x + 1 和 g(y) = y + 2，那么addThen可以将f(x)的返回值作为g(x)的参数传递进去，类似于g(f(x)) = f(x) + 2 = (x + 1) + 2这种 同样compose方法可以将别的函数的返回值作为自己的参数进行函数运算 BiFunction和Function不同的是，他具有三个泛型参数，以及他的addThen方法接收的是一个Function&lt;? super V,? extends T&gt;对象 同样也是将BiFunction的运算结果作为Function的参数，返回Function的运算结果 使用Function接口实现为苹果的重量加20，并返回一个列表 //获取苹果的重量 Function&lt;Apple,Integer&gt; getWeight = Apple::getWeight; //将一个数字加上20,在这里这个数字表示重量 Function&lt;Integer,Integer&gt; addWeight = weight -&gt; weight + 20; //使用Function的addThen方法将所有苹果的重量加上20并返回一个列表 List&lt;Integer&gt; weights = map(inventory,getWeight.andThen(addWeight)); //使用Function的compose方法将所有苹果的重量加上20并返回一个列表 weights = map(inventory,addWeight.compose(getWeight)); Consumer系列接口接口 相关方法 Consumer&lt;T&gt; Consumer&lt;T&gt; addThen(Consumer&lt;? super T&gt; after) DoubleConsumer DoubleConsumer addThen(DoubleConsumer after) IntConsumer IntConsumer addThen(IntConsumer after) LongConsuemr LongConsumer addThen(LongConsumer after) BiConsumer&lt;T,U&gt; BiConsumer&lt;T,U&gt; addThen(BiConsumer&lt;? super T,? super U&gt; after) Consumer系列的接口只接收一个泛型参数的都可以使用addThen方法，接收两个参数的只有BiConsumer接口可以使用addThen方法 关于addThen方法，很显然，在经过当前的Consumer对象的处理之后，可以继续被某个Consumer对象处理 使用Consumer将苹果的重量在原有的基础上乘2再加上10 //将苹果的重量乘2 Consumer&lt;Apple&gt; two = apple -&gt; apple.setWeight(apple.getWeight() * 2); //将苹果的重量加10 Consumer&lt;Apple&gt; add = apple -&gt; apple.setWeight(apple.getWeight() + 10); //使用组合将苹果的重量先乘2再加10 forEach(inventory,two.andThen(add));]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian-环境搭建]]></title>
    <url>%2F2018%2F01%2F08%2Fdebian-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用usb installer创建debian启动盘选择系统类型时，选择debian系统无法正确的创建启动盘，要选择其他linux系统类型才能正常创建 安装系统三个挂载目录，/,/home，/opt，其中/home和/opt是原来使用的挂载目录，没有改变，只覆盖了/目录debian桌面环境选择xfce桌面，核心功能模块 联网安装完系统后，第一步就是联网，正常连接校园网，免去了回退ubuntu的烦恼 设置镜像源debian在中国有两个主镜像源 123456deb http://security.debian.org/debian-security stretch/updates main contribdeb-src http://security.debian.org/debian-security stretch/updates main contribdeb http://ftp2.cn.debian.org/debian/ stretch main contrib non-freedeb-src http://ftp2.cn.debian.org/debian/ stretch main contrib non-freedeb http://ftp2.cn.debian.org/debian/ stretch-updates main contrib non-freedeb-src http://ftp2.cn.debian.org/debian/ stretch-updates main contrib non-free debian的主镜像源在国内也可以正常访问在/etc/apt/source.list文件中添加以下类似的源 安装vim切换管理员用户 12suapt-get install vim-gnome 安装中文输入法linux下的中文输入法有很多，这里选择fcitx，其他的ibus和搜狗输入法都与各种原因没有安装上，很遗憾没有体验一次切换管理员用户 1234suapt install fcitxapt install im-configapt install fcitx-sunpinyin 这个中文输入可以自行更换，不一定只能是这个 然后输入im-config进行配置，将下载的输入法添加到fcitx中就行了 如果 im-config 命令提示缺少什么就需要下载什么 设置完成之后无法显示输入法的提示框，先删除 ~/.config/fcitx 目录，然后卸载已将安装的 fcitx 重新安装 安装无线网卡驱动debian 不会自动安装无线网卡驱动，如果需要手动安装 12apt install firmware-iwlwifimodprobe -r iwlwifi ; modprobe iwlwifi 配置java环境原来的java文件夹位于/opt/jdk下，因为没有覆盖/opt，所以不用重新下载 修改.bashrc文件，在哪个用户目录下修改.bashrc就只会影响该用户 在最后添加 123export JAVA_HOME=/opt/jdkexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib 修改完成后，使用输入 12source ～/.basercjava -version 如果看见java信息说明安装成功 但是注销后进入发现运行的java不是sunjdk，而是openjdk，直接卸载openjdk，发现由于依赖关系，debian自动又下载了一个gcj-jdk，将依赖的libreoffice卸载后，sunjdk运行成功 配置maven环境同样修改.bashrc,在最后添加下面语句 1export PATH=$&#123;PATH&#125;:/opt/maven/bin 配置eclipseeclipse也是放在/opt目录下，没有修改，但是无法运行，报错缺少java运行时的环境。 解决方法，修改eclipse目录下的eclipse.ini文件，在最开始添加 12-vm/opt/jdk/bin 运行成功 安装mysql前往mysql下载页面根据版本下载mysql包 在mysql包下载目录下打开终端，输入 123dpkg -i mysql-apt-config_w.x.y-z_all.debapt-get updateapt-get install mysql-server 下载mysql server，中途会选择版本，输入管理员密码 修改mysql字符集，解决中文乱码问题编辑/etc/mysql/my.cnf，输入下面几句话 1234[client]default-character-set=utf8[mysqld]character-set-server=utf8 退出，使用service mysql stop 停止mysql 服务 然后在使用service mysql start 开启mysql服务 进入mysql 输入 1show variables like &quot;%char%&quot;; 查看字符集，如果都是utf8说明修改成功，如果失败，再去找找其他办法吧 下载msyql-workbench1apt install mysql-workbench 安装git1apt install git 安装visual studio code前往visual studio code官网，下载deb包 12dpkg -i codeXXXXX.debapt-get install -f 解决冲突问题 安装chrome下载文件包 1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 执行安装命令 1dpkg -i google-chrome-stableXXX.deb 解决依赖问题 1apt-get install -f 根据选择的架构不同，安装的chrome版本不同 安装hexonvm安装命令 1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装之后需要配置到用户环境变量 ~/.bashrc 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 下载最新的 Node 1nvm install stable hexo 安装命令 1npm install -g hexo-cli 安装pip3根据python版本，python2使用如下命令下载 1apt-get install python-pip python3 使用如下命令 1apt-get install python3-pip 安装jupyter notebookjupyter官方安装指南 更新 pip 1pip3 install --upgrade pip 下载 jupyter 1pip3 install jupyter 安装 jupyter 之后因该是可以直接启动，但是输入命令 jupyter notebook 无法正常启动，重启后输入命令 1jupyter notebook 可以正常启动 注意:如果在第 2 步安装 jupyter 时出错，无法导入 name 为 ‘main’ 可以尝试使用以下命令修复 1apt install --reinstall python3-requests 安装 idle31apt install idle3 安装 shadowsocks-qt5 客户端感谢网友提供的连接安装成功 安装 virtualbox[官方指南][https://www.virtualbox.org/wiki/Linux_Downloads] 先将virtualbox的源添加到主机，这里的mydist指的是你的系统名称 1deb https://download.virtualbox.org/virtualbox/debian `&lt;mydist&gt;` contrib 添加密钥到主机 12wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add - 更新源并下载virtualbox，并不是只能下载virtualbox5.2版本可以选择其他版本下载 12apt updateapt install virtualbox-5.2 安装 kazam1apt install kazam 安装 dia1apt install dia 安装dia有可能会遇到无法输入中文字符的问题，解决方法如下: 1231. 点击一个流程图下的图形2. 绘出图形3. 在图形上右键`-&gt;`Input Methods 选择X输入法 ssh如果是第一次使用ssh可以使用ssh-keygen生成密钥对 1ssh-keygen 然后使用ssh-copy-id 将公钥发送给远程主机 1ssh-copy-id username@ip-addr 然后在远程主机上将公钥文件名称修改为authorized_keys 接着使用ssh登陆远程主机，如果不行你也许还要做这一步 1ssh-add private-key 将你的私钥保存起来]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-方法引用]]></title>
    <url>%2F2018%2F01%2F07%2Fjava8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是方法引用方法引用是lambd表达式的一种特殊形式。看起来更易读更自然 如果想要对苹果的重量进行排序我们可以这样写: inventory.sort((a1,a2) -&gt; a1.getWeight() - a2.getWeight()); 使用方法引用之后是这样的 inventory.sort(Apple::getWeight); 方法引用的语法格式 指向静态方法的引用Class::staticMethod 指向现有对象的实例方法的方法引用object::instanceMethod 指向任意类型实例方法的方法引用Class::instanceMethod 语法简述指向静态方法的引用类的静态方法必须满足函数描述符，也就是Class.staticMethod的参数和返回值要和函数描述符一致 对于Function function = Class::staticMethod;Class的staticMethod的静态方法定义应该是: public static intstaticMethod(int number){ //一个返回int类型的代码块 } 对于Consumer consumer = Class:staticMethod;Class的staticMethod的静态方法定义应该是: public static void staticMethod(int number){ //没有返回值的代码块 } 对于Predicate pred = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static boolean staticMethod(int number){ //返回boolean类型的代码块 } 对于Supplier supplier = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static int staticMethod(){ //返回int类型的代码块 } 指向现有对象的实例方法的方法引用类的实例方法必须满足函数描述符，也就是对象调用的方法的参数和返回值要和函数描述法一致 对于Function function = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 如果是BiFunction function = object::instanceMethod;Class的实例方法定义应该是: public int instacneMethod(int number){ //返回int类型的代码块 } 下同 对于Consumer consumer = object::instanceMethod;Class的实例方法定义应该是: public void instacneMethod(int number){ //没有返回值的代码块 } 对于Predicate predicate = object::instanceMethod;Class的实例方法定义应该是: public boolean instanceMethod(){ //返回boolean类型的代码块 } 对于Suplier supplier = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 对于第三种格式，函数描述符至少含有一个参数，也就是说必须有一个参数用来调用方法 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(int number){ //返回int类型的代码块 } 对于Consumer consumer = Class::instanceMethod;Class的实例方法定义应该是: public void instanceMethod(){ //没有返回值的代码块 } 对于Comparator comparator = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(Class clazz){ //比较两个数大小的代码块，最后返回一个数用来表示大于，小于，等于 } 实例:使用方法引用来完成列表苹果的筛选，排序，输出，增加重量，返回对应的苹果重量列表 Apple.java public class Apple { private int weight; private String color; //getter setter } Main.java public class Main { public static void main(String[] args) { List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,&quot;green&quot;), new Apple(20,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(25,&quot;green&quot;)); List&lt;String&gt; strs = Arrays.asList( &quot;red&quot;,&quot;green&quot;,&quot;red&quot;,&quot;black&quot; ); //筛选 List&lt;Apple&gt; redApples = filter(inventory,Apple::getColor,&quot;red&quot;); forEach(redApples,System.out::println); List&lt;String&gt; red = filter(strs,String::toString,&quot;red&quot;); forEach(red,System.out::println); //将所有苹果的重量表示为一个列表 List&lt;Integer&gt; appleWeight = map(inventory,Apple::getWeight); forEach(appleWeight,System.out::println); //将所有苹果的重量加10 addWeight(inventory,Apple::getWeight,Apple::setWeight,10); forEach(inventory,System.out::println); //排序 inventory.sort(Comparator.comparing(Apple::getColor)); forEach(inventory,System.out::println); } public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } public static &lt;T&gt; void addWeight(List&lt;T&gt; inventory,ToIntFunction&lt;T&gt; func,ObjIntConsumer&lt;T&gt; consumer,int added) { for(T t : inventory) { consumer.accept(t,func.applyAsInt(t) + added); } } public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { result.add(func.apply(t)); } return result; } public static &lt;T,R&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Function&lt;T,R&gt; func,Object obj){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { if(func.apply(t).equals(obj)) { result.add(t); } } return result; } } 可以看见方法引用的可读性是要强于lanbda表达式的，如： List redApples = filter(inventory,Apple::getColor,”red”); 可以读作:筛选苹果库存中颜色为红色的苹果 inventory.sort(Comparator.comparing(Apple::getColor)); 可以读作:库存根据苹果的颜色进行排序但是方法引用在某些方面的比较复杂的，比如要将所有苹果的重量加10,需要使用两个方法引用 addWeight(inventory,Apple::getWeight,Apple::setWeight,10);]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-函数式接口]]></title>
    <url>%2F2018%2F01%2F05%2Fjava8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在上一次使用自定义的函数接口来使用lambda表达式，每一个lambda都要自定义一个已知的接口来实现，这样比较麻烦，如果可以使用通用的函数式接口，那么会方便很多。幸运的是java8中新增了一些通用的函数式接口供我们使用。下面就来看看吧。 函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口 —《java核心技术卷I基础知识第10版》一言蔽之，只有一个抽象方法的接口称为函数式接口 —《java8实战》 java8提供了一系列通用的函数式接口，位于java.util.function包中 可以看见这个包中只有含有接口，没有任何的抽象类，类，这些接口都需于函数接口，不要慌张，这些接口大部分表达的意思相同，只有少量的区别 函数描述符函数式接口的抽象方法的签名基本上就是lambda表达式的签名。我们将这种抽象方法叫做函数描述符lambda表达式的参数和返回值都要和函数式接口的签名对应，比如说函数式接口ApplePredicate的签名就是接收一个Apple类型的参数返回一个boolean类型的参数所以基本上满足接收一个Apple类型返回一个boolean类型的lambda表达式都可以看作是ApplePredicate的实现 下面来介绍几个函数式接口 Consumer翻译过来为消费者，接收一个参数没有返回值。源码接口如下： public interface Consumer&lt;T&gt; { void accept(T t); } 使用Consumer来实现一个List的遍厉public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } //使用forEach遍历列表 forEach(redApples,apple -&gt; System.out.println(apple)); 其他Consumer系列接口 接口 抽象方法 DoubleConsumer void accept(double value); IntConsumer void accept(int value); LongConsumer void accept(long value); ObjDoubleConsumer&lt;T&gt; void accept(T t,double value); ObjIntConsumer&lt;T&gt; void accept(T t,int value); ObjLongConsumer&lt;T&gt; void accept(T t,int long value); BiConsumer&lt;T,U&gt; void accept(T t,U u); Predicate谓词，用来描述或判断客体性质等(百度百科),这里用来表示判断 Predicate接口有5个方法，包括4个默认方法，1个抽象方法，默认方法以后再说，这里主要关注抽现方法 接口源码如下,接收一个泛型参数，返回一个boolean型数据，至于根据什么返回，怎么判断交给用户来实现 public interface Predicate&lt;T&gt;{ boolean test(T t); } 使用Predicate来实现过滤 public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Predicate&lt;T&gt; pred){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) if(pred.test(t)) result.add(t); return result; } 筛选红色苹果 List&lt;Apple&gt; redApples = filter(inventory,(Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;)); forEach(redApples,apple -&gt; System.out.println(apple)); 其他Predicate系列接口 接口 抽象方法 DoublePredicate boolean test(double value); IntPredicate boolean test(int value); LongPredicate boolean test(long value); BiPredicate&lt;T,U&gt; boolean test(T t,U u); DoublePredicate,LongPredicate,IntPredicate分别是用来判断double,long,int类型，由于double,long,int类型在使用泛型时会有一个自动装箱拆箱的过程，这是为了提高效率实现的三个类,使用上和Predicate没有什么区别 Function函数，接收一个参数返回一个值 public interface Function&lt;T,R&gt;{ R apply(T t); } 使用Function来实现遍历列表，并对列表进行某种操作，操作后返回一个值 public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) result.add(func.apply(t)); return result; } 使用map来将列表中的所有苹果的重量返回并用列表返回 List&lt;Integer&gt; weights = map(inventory,(Apple apple) -&gt; apple.getWeight()); 其他Function系列接口 接口 抽象方法 DoubleFunction&lt;R&gt; R apply(double value); IntFunction&lt;R&gt; R apply(int value); LongFunction&lt;R&gt; R apply(long value); ToDoubleFunction&lt;T&gt; double apply(T value); ToIntFunction&lt;T&gt; int apply(T value); ToLongFunction&lt;T&gt; long apply(T value); BiFunction&lt;T,U,R&gt; R apply(T t,U u); ToDoubleBiFunction&lt;T,U&gt; double apply(T t,U u); ToIntBiFunction&lt;T,U&gt; int apply(T t,U u); ToLongBuFunction&lt;T,U&gt; long apply(T t,U u); 可以看见大多数接口都是为了解决基本类型的封箱拆箱进行优化的接口 Supplier供应商，没有参数，只有返回值。少有使用，这里只提供接口 接口 抽象方法 Supplier&lt;T&gt; T get(); BooleanSupplier boolean get(); DoubleSupplier double get(); IntSupplier int get(); LongSupplier long get(); 其他函数式接口java.util.function包中还有几个使用Operator结尾的接口，现在还不太明白如何使用，以后再加。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-lambda表达式]]></title>
    <url>%2F2018%2F01%2F04%2Fjava8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[测试环境 JDK 10 ，JUnit4 如何使用 lambda 表达式 定义一个只含有一个抽象方法的接口 AbstractFuncOfSingle (只能是接口) 123public interface AbstractFuncOfSingle &#123; int print(int a, int b);&#125; 传入两个int类型的参数，返回一个类型的参数 定义一个方法，传入参数为 AbstractFuncOfSingle 1234public void callAbstractFuncOfSingle(AbstractFuncOfSingle singleFunc, int a, int b)&#123; int result = singleFunc.print(a, b); System.out.println(result * 2);&#125; 在方法中将方法参数 a，b 作为参数传入 AbstractFuncOfSingle.print() 方法，并使用 result 接收返回参数然后打印 调用上述方法 1234567@Testpublic void testAbstractFuncOfSingle()&#123; callAbstractFuncOfSingle((a, b)-&gt;&#123; System.out.println(a + b); return a + b; &#125;, 10, 23);&#125; 使用 lambda 表达式创建一个内部类，打印 a + b 的和并返回 a + b 和 如果接口的抽象方法具有多个参数，那么 lambda 的传入参数个数也要一一对应，如果抽象方法具有返回值，在 lambda 表达式中也要有返回值，否则可以省略 return 语句注意：lambda 表达式的参数类型和返回类型要和抽象方法的参数类型和返回类型相同 lambda 表达式和匿名内部类lambda 表达式是匿名内部类的一种简化形式，lambda 表达式只能书写于只有一个抽象方法的接口，匿名内部类可以书写具有多个抽象方法的接口和抽象类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-tcp套接字编程]]></title>
    <url>%2F2017%2F12%2F28%2Fjava-tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是套接字传送们维基百科java中的套接字屏蔽了许多细节，不需要关注更多的底层信息。在java中套接字服务器可以使用java.net.ServerSocket创建一个常用的构造方法如下: 1ServerSocket server = new ServerSocket(int port); port: 表示套接字服务器需要监听的本机的端口，常见的端口有 80 端口，3306 端口等，这个监听的端口不允许重复监听，建议使用靠后面的端口号然后可以使用 Socket client = server.accept() 等待客户端的连接并返回一个 Socket 对象，通过这个 Socket 对象可以和客户端进行通信: 12OutputStream out = client.getOutputStream();InputStream in = client.getInputStream(); out 可以向客户端输出消息，in 可以接受客户端的消息（消息的输入和输出都是相对于内存而言的，如果是写入内存中，那么就是输入，如果是从内存中读出，那么就是输出） 服务器一般都是长时间运行服务多个客户端，所以服务器一般不会关闭，在客户端和服务器中端连接时，只需要关闭输入输出流就行了。 套接字客户端的创建使用 Socket 创建，需要指定要连接的 ip 地址和端口，这个端口要和套接字服务器监听的端口号相同，ip 地址要和套接字服务器所在主机的 ip 地址相同，linux 下可以使用 ifconfig 命令查看 ip 地址，如果是在本机进行套接字编程，可以使用 127.0.0.1 或者 localhost 确定本机 ip 1Socket socket = new Socket(Stirng ipAddress,int port); 创建套接字之后就可以获取输入输出流和服务器交流，这里的输入输出流是相对于客户端的输入输出，客户端的输入是服务器端的输出。 客户端不同于服务器，客户端关闭时需要关闭 Socket，使用 socket.close() 关闭 一个简单的服务器 Socket： 123456789101112131415//创建套接字服务器ServerSocket server = new ServerSocket(int port);//套接字服务器一般不会关闭，所以使用死循环不同的获取连接，在获取客户端连接是一般要开线程while(true)&#123; //获取客户端连接 Socket socket = server.accept(); //获取输入输出流,按情况获取，如果即需要输入也需要输出那么两个都需要获取，io可以包装成Reader和Writer OutputStream out = socket.getOutputStream();//获取输出流 InputStream in = socket.getInputStream();//获取输入流 //进行消息的获取或发送 //... //关闭输入输出流 out.close(); in.close();&#125; 简单的客户端套接字: 123456789101112131415//创建客户端套接字Socket socket = new Socket(String serverIp,int port);//获取输入输出流（一般来说客户端都是会先获取输出流发送消息到服务器，服务器返回消息，客户端使用输入流获取）OutputStream out = socket.getOutputStream();InputStream in = socket.getInputStream();//进行消息的发送与接收,可以使用死循环，在循环使用特殊字符串之类的东西退出while(true)&#123; //flag; //发送和接受&#125;//关闭输入输出流out.close();in.close();//关闭套接字socket.close(); 参考源码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax异步处理]]></title>
    <url>%2F2017%2F12%2F16%2Fajax%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[AJAX 异步处理AJAX异步处理基本操作,参考教程w3school AJAX是什么AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX可以在页面不刷新的情况更新局部页面，也可以在页面加载过程中先加载重要部分在加载不那么重要的部分，提高页面加载速度 AJAX工作流程AJAX基本对象 XMLHttpRequest是AJAX的基础，XMLHttpRequest 用于在后台与服务器交换数据 1. XMLHttpRequest的创建现代浏览器内置XMLHttpRequest对象使用如下方式创建 1xmlhttp = new XMLHttpRequest(); 老版本的IE浏览器不支持XMLHttpRequest对象，使用ActiveXObject对象创建: 1xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); 根据浏览器的不同使用不同的方式创建对象 123456var xmlhttp = null;if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();&#125;else&#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")&#125; 2. 使用AJAX发送请求使用的方法如下: 123456789open(method,url,async) 规定请求类型，URL，是否异步处理请求 method:请求类型;GET/POST url:要请求的连接;如www.google.com async:是否同步;true(异步)/false(同步)send(String) 发送请求到服务器 string:仅用于post请求setRequestHeader(header,value) 向请求添加HTTP头 header:规定头的名称 value:规定头的值 3. 获取响应涉及属性如下: responseText 获得字符串形式的相应数据 responseXML 获得XML形式的响应数据 4. onreadystatechange事件onreadystatechange是当AJAX请求发送到服务器时，根据服务器的处理进度进行反馈的标志 12345678910readyState 属性 存储XMLHttpRequest的状态，从0到4变化 0：请求为初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪status 200：“ok” 404：paga not foundonreadystatechange 存储函数名，在每次readyState变化时调用存储的函数 一个基本的请求相映模板12345678910111213141516function loadXMLDoc()&#123; var xmlhttp = null; if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest(); &#125;else&#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP") &#125; xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.state == 200 &amp;&amp; xmlhttp.readeyState == 4)&#123; //获取响应数据 var responseT = xmlhttp.responseText; &#125; &#125;; xmlhttp.open("GET","www.baidu.com",true); xmlhttp.send(null);&#125; 一个使用ajax发送到服务器，服务器使用spring-mvc返回JSON数据并在页面显示的实例源码]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fjson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[JSON是什么JSON：JavaScript 对象表示法（JavaScript Object Notation）。JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。参考w3school JSON实例{ &quot;employees&quot;: [ { &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; }, { &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; }, { &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; } ] } 使用python表示JSON实例one = {&quot;firstName&quot;:&quot;Bill&quot;,&quot;lastName&quot;:&quot;Gates&quot;} two = {&quot;firstName&quot;:&quot;George&quot;,&quot;lastName&quot;:&quot;Bush&quot;} three = {&quot;firstName&quot;:&quot;Thomas&quot;,&quot;lastName&quot;:&quot;Carter&quot;} employees = [one,two,three] o = {&quot;employess&quot;:employees} 使用java表示JSON实例Map&lt;String,String&gt; one = new HashMap&lt;&gt;(); Map&lt;String,String&gt; two = new HashMap&lt;&gt;(); Map&lt;String,String&gt; three = new HashMap&lt;&gt;(); one.put(&quot;firstName&quot;,&quot;Bill&quot;); one.put(&quot;lastName&quot;,&quot;Gates&quot;); two.put(&quot;firstName&quot;,&quot;George&quot;); two.put(&quot;lastName&quot;,&quot;Bush&quot;); three.put(&quot;firstName&quot;,&quot;Thomas&quot;); three.put(&quot;lastName&quot;,&quot;Carter&quot;); List&lt;Map&lt;String,String&gt;&gt; employees = new LinkedList&lt;&gt;(Arrays.asList(one,two,three)); Map&lt;String,List&lt;Map&lt;String,String&gt;&gt;&gt; o = new HashMap&lt;&gt;(); o.put(&quot;employees&quot;,employees); 可以发现JSON并没有什么神奇的地方，只不过是一群人定义的字符床规范格式而已，用的人多了就成了标准 将JSON转换为javascript对象 javascript 可以使用内置eval()函数将JSON数据生成原生的javascript对象var obj = eval(“(“ + JSON + “)”); JSON值有以下几种 数字(整数或浮点数)字符串(双引号中)逻辑值(true或false)数组(在方括号中)对象(在花括号中)null 使用本地JSON构建javascript对象实例可以在w3school找到，这里给出一个使用java:spring-mvc返回json对象并转换成javascript对象的实例spring-mvc返回JSOn数据参考源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-mvc返回json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fspring-mvc%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在使用spring-mvc过程中遇到很多问题，记录下来方便查看 开发环境如下: eclipse Oxygen Release (4.7.0) java1.8 spring 4.3.3 freemarker 2.3.26(这个不是必须的) maven依赖包如下：&lt;!-- spring mvc返回json所需依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- freemarker 引擎，有了这个就不需要使用jstl了，只需要使用freemarker表达式就行了 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring bean 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; web.xml 配置:&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动顺序，让这个Servlet随Servletp容器一起启动。 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!--会拦截URL中带“/”的请求。 --&gt; &lt;/servlet-mapping&gt; spring-mvc配置:&lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=&quot;canxing.web&quot; /&gt; spring-mvc配置freemarker:&lt;!-- freemarker 配置文件 --&gt; &lt;!-- freemarker config --&gt; &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/freemarker/&quot; /&gt; &lt;/bean&gt; &lt;!-- View resolvers can also be configured with ResourceBundles or XML files. If you need different view resolving based on Locale, you have to use the resource bundle resolver. --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; &lt;/bean&gt; JSONController.java:@Controller public class JSONController { @RequestMapping(path=&quot;/json&quot;,produces=&quot;application/json&quot;) public @ResponseBody User index() {//使用@RespnseBody将返回的对象转化为JSON数据 System.out.println(&quot;index start&quot;); User user = new User(); user.setUsername(&quot;canxing&quot;); user.setPassword(&quot;123&quot;); System.out.println(&quot;index end&quot;); return user; } @RequestMapping(path=&quot;/&quot;) public String test() { return &quot;test&quot;; } } User.java：//类不需要进行处理，只是一个普通的pojo类 public class User{ private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; } } test.flt:12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt; &lt;head&gt; &lt;title&gt;freemarker test &lt;/title&gt; &lt;script type="text/javascript"&gt; function loadXMLDoc() &#123; xmlhttp=null; if (window.XMLHttpRequest) &#123;// code for Firefox, Mozilla, IE7, etc. xmlhttp=new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; if (xmlhttp!=null) &#123; xmlhttp.onreadystatechange=state_Change; xmlhttp.open("GET","http://localhost:8080/spring_web_test/json",true); xmlhttp.send(null); &#125; else &#123; alert("Your browser does not support XMLHTTP."); &#125; &#125; function state_Change()&#123; var obj = eval("(" + xmlhttp.responseText + ")"); document.getElementById("username").innerHTML=obj.username document.getElementById("password").innerHTML=obj.password &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;freemarker test&lt;/h1&gt; username : &lt;span id='username'&gt;&lt;/span&gt;&lt;br&gt; password : &lt;span id='password'&gt;&lt;/span&gt;&lt;br&gt; &lt;button type='button' onclick="loadXMLDoc()"&gt;adfads&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; spring-mvc返回JSOn数据参考源码 寻找答案中遇到的问题 依赖问题，spring 默认的对象转化为 json 的 jar 包依赖，网上多是直接使用并没有说明依赖 还是依赖问题，spring 和 jackson 之间版本的兼容性太差，稍微更改以下 jackson 或者 spring 的版本就会导致 NoSuchMethodError 错误，据说这里可以看见版本支持，但是看不懂]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ajax</tag>
        <tag>json</tag>
        <tag>spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述二-栈]]></title>
    <url>%2F2017%2F12%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%8C-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈又称堆栈，仅允许在表的一端进行插入和删除操作的线性表，该位置位于表尾，称为栈顶(Top)，相对地，另一端称为栈底。由于栈的插入和删除运算只能在栈顶一端进行，后进栈元素必定先出栈，所以把栈称为后进先出表(last in first out 简称 LIFO) 这里使用链表实现栈 栈的定义12345678910111213141516171819//头文件中的函数定义struct Node;typedef struct Node *PtrToNode;typedef PtrToNode Stack;typedef int ElementType;int IsEmpty(Stack S);//判断栈是否为空Stack CreateStack(void);//创建一个空栈void MakeEmpty(Stack S);//删除栈中的所有数据void Push(ElementType X,Stack S);//将数据压入栈栈有两种实现方式，一种使用顺序表，另一种使用链表方式实现ElementType Top(Stack S);//返回栈顶的数据void Pop(Stack S);//弹出栈顶的元素void printStack(Stack S);//遍历栈//具体实现文件中栈节点的定义，使用int类型typedef int ElementType;struct Node&#123; ElementType Element; PtrToNode Next;//因为是使用链表，所以这个执行下一个节点地址&#125;; 栈的实现栈的主要操作集中在Push和Pop操作，前者向栈中压入一个数据，后者从栈中弹出一个数据 Push功能实现12345678void Push(ElementType X,Stack S)&#123; PtrToNode Node; Node = (PtrToNode)malloc(sizeof(struct Node)); if(Node == NULL) return; Node-&gt;Element = X; Node-&gt;Next = S-&gt;Next; S-&gt;Next = Node;&#125; Pop功能实现1234567void Pop(Stack S)&#123; if(IsEmpty(S)) return; PtrToNode temp = S-&gt;Next; S-&gt;Next = temp-&gt;Next; temp-&gt;Next = NULL; free(temp);&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述一-链表]]></title>
    <url>%2F2017%2F12%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%80-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表由一系列不必在内存中相连的结构组成，每一个结构单元均含有表元素和指向包含该元素后继元素的结构的指针 如图所示 链表可以有两种表现形式，一种是带有头节点的链表(如上图所示)，另一种是不带有头节点的链表，一般来说带有头节点的链表很多时候处理起来比不带头节点的方便，因此这里选择带有头节点的链表展示 链表定义如下: 123456789101112131415161718192021222324252627//头文件中定义struct Node;typedef struct Node *PtrToNode;typedef PtrToNode List;typedef PtrToNode Position;typedef struct ElementType ElementType;List MakeEmpty(List L);int IsEmpty(List L);int IsLast(Position P,List L);Position Find(ElementType X,List L);void Delete(ElementType X,List L);Position FindPrevious(ElementType X,List L);void Insert(ElementType X,List L,Position P);void DeleteList(List L);Position Header(List L);Position First(List L);void printList(List L);//在具体的实现文件中定义每个节点中的数据，这里选择int类型的数据struct ElementType&#123; int data;&#125;;struct Node&#123; ElementType Element; Position Next;&#125;; 主要功能实现链表中稍微复杂的功能主要集中在删除和插入操作，删除和插入功能主要涉及到链表指针的移动以及内存的分配和释放 当链表删除时，就需要调整指针，将删除节点的前驱节点的后继指针指向删除节点的后继节点，并释放删除节点所占用的内存空间 当链表插入元素时，需要分配内存空间，创建一个新的节点，并将指定节点的后继指针指向新增节点，再把新增节点的后继指针指向原来指定节点的后继节点 链表插入操作实现代码12345678void Insert(ElementType X,List L,Position P)&#123; Position ptr ; ptr = (Position)malloc(sizeof(struct Node)); if(ptr == NULL) exit(0); ptr-&gt;Element = X; ptr-&gt;Next = P-&gt;Next; P-&gt;Next = ptr;&#125; 链表删除操作实现代码12345678910111213void DeleteList(List L)&#123; if(L == NULL || L-&gt;Next == NULL) return; Position ptr = NULL; Position temp = NULL; ptr = L-&gt;Next; L-&gt;Next = NULL; while(ptr != NULL)&#123; temp = ptr; ptr = ptr-&gt;Next; temp-&gt;Next = NULL; free(temp); &#125;&#125; 参考源码]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下gpg的基本使用]]></title>
    <url>%2F2017%2F12%2F10%2Fubuntu%E4%B8%8Bgpg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是gpg 课程实验需要使用pgp对文件进行加密解密操作，pgp是一套用于消息加密、验证的应用程序，采用IDEA的散列算法作为加密与验证之用,但是pgp是商业软件不能自由使用，所以有自由软件基金会开发一个pgp的替代品，取名GnuPG，这就是gpg。 安装gpg 在ubuntu16.04下gpg已经安装好了，可以使用如下命令gpg -h如果输出有gpg的帮助文档，那么就有gpg，如果没有可以前往 gnupg官网 页面下载 gpg 基本使用 1.生成密钥 输入以下命令开始生成密钥对 gpg --gen-key *选择密钥种类，默认选择1,使用RSA and RSA算法，表示加密和签名都使用RSA算法然后选择要使用的密钥长度默认为2048,密钥长度越长，越安全，由于是课程实验，所以使用默认值选择密钥的有效期，由于是课程实验，所以选择永不过期，如果是要上传到服务器上，按情况自行选择有效期系统确认输入真实姓名电子邮箱注释然后生成用户标识然后系统最后确认接着系统让你设置一个私钥密钥，用来保护私钥接着系统生成密钥，需要大量的随机字节，按系统提示等一下就会生成密钥 2.检查密钥 查看本机密钥 gpg --list-keys 3.输出密钥 输出公钥 gpg -a -o public-key.txt --export [用户标识(可以是密钥id，就是使用gpg --list-key 查看到的密钥id)] 输出私钥 gpg -a -o private-key.txt --export-secret-keys ##4.上出公钥 由于是课程实验，所以并没有上传（其实是不知道什么原因，无法上传到服务器) 5.导入密钥 gpg --import [密钥文件] 也可以到公钥服务器上寻找(未验证) gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户id] 注意： 使用手动导入公钥会出现无法认证的问题，可以使用 gpg --fingerpring 打印指纹，指纹是每对密钥生成的时候生成的，查看指纹后可以通过电话或者其他方式到提供者验证指纹 然后使用以下命令 gpg --sign-key [公钥id] 或者使用如下命令删除 gpg --delete-keys [公钥id] 6.公钥加密 gpg -r [用户id] -o [输出文件] -e [加密文件] -r 接受者的公钥的id，可以是邮箱 -o 输出加密后的文件名 -e 要执行加密操作的数据 7.解密 gpg [解密文件] gpg 有一个默认选择 -d 默认使用你的私钥解密别人使用你的公钥解密传送过来的数据 8.数字签名 gpg -s [文件名] 生成一份签名 gpg --clearsign [文件名] 生成一份明文签名 gpg -a -b [文件名] 生成一份分离的明文签名(去掉-a就是二进制签名) 9.验证签名 gpg --verify [被签名的文件] 参考文章 http://www.ruanyifeng.com/blog/2013/07/gpg.html http://www.williamlong.info/archives/3439.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pgp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github+hexo的个人博客]]></title>
    <url>%2F2017%2F12%2F09%2F%E5%9F%BA%E4%BA%8Egithub-hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基于github+hexo的个人博客1. 本地环境配置 操作系统为 ubuntu16.04 1. git 使用 sudo apt install git下载git 2. node.js 安装命令 wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh nvm install stable 3. hexo npm install -g hexo-cli 安装hexo hexo安装 2. github 配置 前往github主页新建一个仓库，仓库名为 xxx.github.io(到时候通过xxx.github.io就可以访问个人博客，xxx最好是和github账户名相同，不同不知道是否可以) 3.创建本地文件资源 在/home/canxing/目录下创建保存博客资源文件夹 makir myblog 使用hexo初始化 hexo init ~/myblog 进入myblog文件夹 生成hexo所需要的文件目录 npm install 使用 hexo s 命令开启hexo服务，并通过localhost:4000 就可以访问一个初始的模板 4. 配置hexo hexo文件夹根目录下的_config.yml 文件为hexo的配置文件官方配置参数参考配置说明 部分参数说明如下 title:网站主标题 subtitle: 子标题 description: 网站描述 author: 作者 language: zh_CN timezone: 时区，没有设置为本地时区设置 url: 你的网站域名 root: 根路径 permalink:生成的链接的格式 theme:生成的博客系统样式，就是视图表示，可以前往hexo样式选择喜欢的样式然后使用git clone到本地 deploy: 部署选项，包括部署类型，仓库url，分支等 type: git repo: 仓库url branch: 一般是master 5. hexo预览和部署 hexo s开启hexo服务器，在网页中可以输入localhost:4000可以查看预览 hexo g生成新的文件资源 hexo d部署到github上，部署路径为_config.yml文件中的deploy的选项]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
