<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mongodb-学习记录]]></title>
    <url>%2F2018%2F07%2F24%2Fmongodb-note%2F</url>
    <content type="text"><![CDATA[MongoDB 学习记录 什么是 MongoDB MongoDB 的组织形式 MongoDB 有几种数据结构 如何创建数据库 那么怎么样才可以创建集合 如何删除集合和数据库 如何查看帮助文档 如何插入文档 插入一条数据 插入多条数据 如何查询插入的数据 查询全部数据 如何仅查询需要的字段 如何根据条件进行查询 如何查询 stars 大于 50 的数据 如何多条件查询 如何查询满足其中一个条件的数据 如何按照 stars 从大到小，从小到大排序 如何实现分页 如何实现分组 如何删除数据 如何删除一条数据 如何删除多条数据 如何更新数据 如何更新一条数据 如何更新多条数据 如何更新数据中的文档数据 如何删除文档类型数据中的域 如何在文档类型数据中插入新的数据 如何更新数组中的数据 如何往数组中插入新的数据 如何删除数组中的数据 如何创建索引 创建升序索引 创建降序索引 如何查看创建索引 如何删除创建的索引 什么是MongoDBMongoDB 是一个 NoSQL 数据库，和 MySQL 等关系型数据库不一样 MongoDB 更简单易用。MongoDB 是 NoSQL 的一种。 MongoDB的组织形式MongoDB 中可以有多个数据库，每个数据库中可以有多个集合，每个集合有多个文档（文档就相当于 MySQL 中的表，但是表中的数据都有相同的域，文档中的每一条数据不一定有相同的域），每个文档都有域，这些域可能存在也可能不存在，在实际使用中每个文档应该有相同的域。 MongoDB 的组织形式图解: MongoDB 和 MySQL 的对对比： MongoDB有几种数据结构MongoDB 中以下几种数据结构： 数字 字符串 布尔 日期 数组 文档（JavaScript 中的对象） 如何创建数据库MongoDB 中的数据库不用手动创建，只需要使用 use &lt;collection&gt; 就可以选择数据库，如何没有这个数据库，在创建一个集合的同时也会创建数据库 那么怎么样才可以创建集合使用以下命令就可以创建一个集合 1db.createCollection("collectionName") 如何删除集合和数据库使用以下命令可以删除一个集合，其中 &lt;collection&gt; 表示选中的集合 1db.&lt;collection&gt;.drop() 删除数据库可以使用以下命令删除，注意，这个 db 是由 use &lt;database&gt; 选中的数据库 1db.dropDatabase() 如何查看帮助文档在 Mongo shell 中直接使用 help 命令可以查看在线帮助文档 使用 db.help() 可以查看数据库相关的帮助文档 使用 db.&lt;collectionname&gt;.help() 可以查看数据库集合的相关帮助文档 如何插入文档查看 db.&lt;collectionname&gt;.help() 可以看见 MongoDB 定义了三种方式来插入文档，有 insert,insertOne,insertMany，其中 insert 用处最多，具备有 insertOne 和 insertMany 的功能。 insertOne 用于向数据库中插入单条数据的情况，insertMany 用于一条命令向数据库中插入多条数据。 插入一条数据12345678db.blog.insert(&#123; title: 'mongodb 的使用', author: 'canxing', publishDate: new Date(2018,7,16,17,31), content : 'mongodb 插入语句的实现', stars : 10, comment : []&#125;) 插入多条数据123456789101112131415161718db.blog.insert([&#123; title: 'mongodb 插入多条数据的使用', author: 'canxing', publishDate : new Date(2018,7,16,17,33), content : "mongodb 插入多条数据的实现", stars: 12, comment : []&#125;,&#123; title: 'mongodb 插入多条数据的使用2', author:'canxing', publishDate: new Date(2018, 7, 16, 17, 34), content: "mongodb 插入多条数据的实现2", stars: 2, comment : []&#125;]) 如何查询插入的数据首先保证数据库中已经插入了下面这些数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647db.blog.insert([ &#123; title: 'mongodb 数据库的创建', author: &#123; firstName: 'liu', lastName: 'xin' &#125;, publishDate: new Date(2018, 7, 20, 9, 12), content: 'mongodb 数据库的创建', stars: 30, comment:[ 'aaaa', 'bbbb', 'cccc' ] &#125;, &#123; title: "走两步", author: &#123; firstName: "tom", lastName: "jerry" &#125;, publishDate: new Date(2018, 7, 21, 8, 23), content: "随便走两步", stars: 32, comment: [ 'dddd', 'eeee', 'ffff' ] &#125;, &#123; title: "葫芦娃救爷爷", author: &#123; firstName: "忘了", lastName: "忘了" &#125;, publishDate: new Date(2018, 7, 22, 10, 23), content: "7个葫芦娃轮流救爷爷，结果都被抓了", stars: 11000, comment: [ 'gggggggggg', 'hhhhhhhhhhh', 'iiiiiiiiiii' ] &#125;]) 查询全部数据 要想查询的结果可读性更强，可以试试 pretty 方法 db.blog.find().pretty() 1db.blog.find() 如何仅查询需要的字段1db.blog.find(&#123;&#125;, &#123;title:1, author:1, publishDate:1, _id:1&#125;) 查询的第一个参数是筛选条件，{} 表示不过滤直接查询，也就是查询所有的数据，第二个参数设置需要显示的域，要显示的设置为 1, 不显示的设置为 0, _id 域默认显示，不想显示需要手动指定。 如何根据条件进行查询123db.blog.find(&#123;title: "mongodb 数据库的创建"&#125;) //根据博客名称进行查询db.blog.find(&#123;author: &#123;firstName: "liu", lastName: "xin"&#125;&#125;) //根据作者进行查询db.blog.find(&#123;comment: 'dddd'&#125;) //根据评论进行查询 上面展示了三种根据条件进行查询的方式，这种方式类似于 MySQL 中的 where 字句但是也有不同。 第一条查询语句使用 {title: &quot;mongodb 数据库的创建&quot;} 来筛选，返回所有数据中满足 title 域对应的值等于 mongodb 数据库的创建 的语句。 第二条查询语句使用 {author: {firstName: &quot;liu&quot;, lastName: &quot;xin&quot;}} 来筛选，注意，这个 author 是一个文档类型，查询的时候需要该文档类型中的所有域都相等。 第三条查询语句使用 {comment: &#39;dddd&#39;} 来筛选，comment 是一个数组类型，查询时可以使用这种方式，表示查询的数组中含有 dddd 元素的数据，也可以使用 db.blog.find({comment: [&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;]}) 来查询，使用后一种方式时要使用匹配该数组中的所有元素才行。 如何查询stars大于 50 的数据1db.blog.find(&#123;stars: &#123;$gt: 50&#125;&#125;) 在 MongoDB 中 &gt;,&lt;, 都不能使用，要使用特殊符号来表示这些。符号如下: 含义 表示 大于 $gt 小于 $lt 不等于 $ne 大于等于 $gte 小于等于 $lte 用法和示例类似 如何多条件查询1db.blog.find(&#123;stars: 32, title: "走两步"&#125;) 要查询同时满足多个条件的数据，只需要如示例添加条件就行了。 如何查询满足其中一个条件的数据如果要求返回匹配多个条件中的一个条件的数据，需要使用关键字 $or，相当于 or 语句。 1db.blog.find(&#123;$or: [&#123;stars: 32&#125;, &#123;stars: 30&#125;]&#125;) 如何按照stars从大到小从小到大排序12db.blog.find(&#123;&#125;).sort(&#123;stars:1&#125;) //升序db.blog.find(&#123;&#125;).sort(&#123;stars:-1&#125;) //降序 如何实现分页MongoDB 中也有 limit 方法，但是这个 limit 和 MySQL 中的 limit 不同，这个 limit 只会返回指定条数的数据，不能指定从什么位置开始读取。要实现和 MySQL 中的 limit 相同的功能，需要同时使用 skip 和 limit。 1db.blog.find(&#123;&#125;).skip(1).limit(1) skip 表示跳过多条数据，limit 表示只读取多条数据，这里跳过第一条，只读取一条，那么就会读取所有数据的第二条。 如何实现分组在 MySQL 中，分组首先要有一个字段，按照这个字段的不同分成不同的组。MongoDB 中也是一样，需要某一个域作为参数，返回这个参数的不同的值。 分组要 aggregate 方法和 $group 操作符，在 $group 操作符中，使用 _id 来说明分组的 key 。 1db.blog.aggregate([&#123;$group: &#123;_id:'$stars'&#125;&#125;]) //按照 stars 字段进行分组 如何删除数据删除数据可以使用 remove,deleteOne 和 deleteMany 中的某一个。 如何删除一条数据如果只想删除一条数据，使用 deleteOne，它会删除满足条件的第一条语句。 1db.blog.deleteOne(&#123;title: "mongodb 数据库的创建"&#125;) 如何删除多条数据删除多条数据使用 deleteMany 是很不错的。 1db.blog.deleteMany(&#123;stars: &#123;$gt: 30&#125;&#125;) 删除单条数据使用 deleteOne，删除多条数据使用 deleteMany，至于 remove 一般情况下不需要使用，毕竟 deleteMany 既可以删除一条也可以删除多条。 如何更新数据更新数据使用 update,updateOne 和 updateMany。 如何更新一条数据更新一条数据使用 updateOne 方法，updateOne 方法会更新第一个匹配的数据。 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$set: &#123;stars: 50&#125;&#125;) updateOne 接收两个参数，第一个参数是要修改数据的查询条件，和查询时使用的条件一样，第二个参数表示要更新的数据。 注意 ：如果没有使用 $set 那么这条数据就只有一个域那就是 {stars:50}，使用 $set 之后才会修改指定的域，不然就是覆盖整条数据。 如何更新多条数据更新多条数据使用 updateMany，使用 update 也可以，可是使用 update 需要额外添加 {multi: true}，有些时候会忘记添加，忘记添加就相当于使用 updateOne。 1db.blog.updateMany(&#123;$or: [&#123;title: "mongodb 数据库的创建"&#125;, &#123;title: "走两步"&#125;]&#125;, &#123;$set: &#123;stars: 1000&#125;&#125;) 如何更新数据中的文档数据在我们插入的数据中有 author 域，该域是一个文档类型，和普通数据类型不同，如何修改，删除，添加里面的数据 如何删除文档类型数据中的域1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$unset: &#123;'author.lastName': 1&#125;&#125;) 这里使用了 $unset，这个操作会删除一个域，&#39;author.lastName&#39; 表示 author 文档的 lastName 属性，1 表示删除。$unset 不仅可以删除一个文档中的域，也可以删除一个域。 如何在文档类型数据中插入新的数据1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$set: &#123;'author.lastName': 'xin'&#125;&#125;) 上述操作不仅可以插入新的数据，也可以用来更新数据 如何更新数组中的数据和数组有关的操作符看这里 如何往数组中插入新的数据往数组中插入新的数据使用 $push 操作符 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$push: &#123;comment: 'zzzzzzzzzz'&#125;&#125;) 如何删除数组中的数据删除数组中的数据使用 $pop 操作符和 $pull 操作符。$pop 操作符用于删除并返回数组中的第一个或最后一个元素。$pull 操作符用于精确删除数组中匹配的数据。 1db.blog.updateOne(&#123;title: "mongodb 数据库的创建"&#125;, &#123;$pop:&#123;comment:1&#125;&#125;) 其中 {comment: 1} 中的 1 表示弹出并删除最后一个元素 1db.blog.updateOne(&#123;title:"mongodb 数据库的创建"&#125;, &#123;$pull: &#123;comment: 'bbbb'&#125;&#125;) 如何创建索引使用文档中某个域创建索引，使用该域进行查询时可以加快查询速度 创建升序索引1db.blog.createIndex(&#123;title:1&#125;) 创建降序索引1db.blog.createIndex(&#123;title:-1&#125;) 如何查看创建索引1db.blog.getIndexes() 如何删除创建的索引删除对应索引，删除索引时的名称不是创建索引时的名称，而是使用 getIndexes 查看的 name 属性的名称 1db.blog.dropIndex('title_1')]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-简单爬虫]]></title>
    <url>%2F2018%2F06%2F30%2Fpython-reptile%2F</url>
    <content type="text"><![CDATA[python 简单爬虫 这不是一篇完整的爬虫教程，这是一篇使用python完成简单爬虫的使用过程记录。使用 python3 以及第三方库 requests 和 lxml 以及 xpath 技术来爬取一些网页数据这里只是用了 GET 请求，没有使用 POST 请求 第三方库和技术介绍requests: 这里使用 requests 来请求一个网页，并将响应结果封装在一个对象中返回 lxml: 使用 lxml 中的 etree 库对响应的 HTML 页面进行解析 xpath: 一种解析 xml 文档的技术，也可以解析 HTML 页面。在w3c可以找到文档 过程介绍 使用 requests.get 函数请求对应的URL 如果请求正常并有返回，将返回结果通过etree.HTML处理 使用xpath技术对etree.HTML处理过的对象进行解析，获取对应的数据 数据存储 请求页面请求头使用requests.get(url)方式可以请求对应的url内容，并将响应结果封装在一个对象中返回，但是直接使用这种方式的请求头中包含这个&quot;User-Agent&quot;:&quot;python-requests/2.19.1&quot;有些服务器会通过这个请求头得知这是一个python爬虫请求从而拒绝响应。为了正常访问，需要传入一个请求头来覆盖这个属性，从而骗过请求服务器。 在firefox浏览器中通过请求http://httpbin.org/get可以获得本机的请求头，下面是我请求的该链接的部分内容 将请求中的User-Agent对应的属性作为键值对形式传入requests.get()的headers参数，如下 12header = &#123;"User-Agent":"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"&#125;response = requests.get(url, headers=header) 请求参数如果你想要传入查询参数，只需要以键值对的形式传入requests.get中的params，下面的查询键为’user’，对应的值为’tom’ 123456789data = &#123;"user":"tom"&#125;response = requests.get(url, params=data)```python如果你有多个查询值也可以添加多个键值对```pythondata = &#123;"user":"tom","pwd":"jerry"&#125;response = requests.get(url, params=data) 请求超时设置对requests.get函数的timeout参数传入一个数字可以设置请求的最长时间 1response = requests.get(url, timeout=0.1) 响应处理使用response = requests.get()之后就获取了响应结果，这时可以对响应做一些处理 响应码response.status_code返回请求的响应码，正常情况下返回200 字符设置响应返回的结果不一定可以正常显示，对response.encoding属性进行赋值可以修改返回的字符集，一般设置为utf-8 1response.encoding = 'utf-8' 返回结果response.text将数据以文本形式返回，文本形式的字符集和字符设置有关，如果没有设置则返回响应数据设置的字符集 response.content将数据以字节形式返回，使用这种方式返回就不用担心返回的数据出现乱码问题 一个完整的请求实例请求一个url并将响应结果以文本的形式返回 123456789101112131415user_agent = "User-Agent"my_user_agent = "Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"header = &#123;user_agent: my_user_agent&#125;def getPage(url, data=None) : '''根据url请求一个html页面并返回''' try : r = requests.get(url, headers=header, params=data) r.encoding = 'utf-8' if r.status_code == 200: return r.text else : raise Exception("返回页面信息失败") except : raise Exception("请求链接失败") xpath处理使用lxml中的etree库中的HTML函数可以将一个HTML页面转换为一个对象，对该对象使用xpath语法即可获取对应的数据。有关更多的xpath技术点击这里 123from lxml import etreehtml = etree.HTML(html)html.xpath(xpath) 对于使用xpath语法来获取数据，在firefox浏览器中使用这个插件，可以在线使用xpath语法来匹配 注意:使用xpath语法返回的数据都是以列表形式返回 一个完整的可以爬取腾讯社招技术类的所有招聘信息的爬虫程序]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>reptile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA社区版使用maven搭建web开发环境]]></title>
    <url>%2F2018%2F04%2F17%2FIntelljJ-IDEA-Community-Edition-maven-webapp%2F</url>
    <content type="text"><![CDATA[IDEA社区版是不支持web应用程序开发，但是IDEA支持Maven，在Maven配置文件中可以添加tomcat插件，因此可以使用IDEA进行web应用程序开发 一 新建Maven项目在选择新项目时选择maven项目，勾选 Create from archetype，在下方选择maven-archetype-webapp，点击Next 输入GroupId和ArtifactId 选择Maven位置，如果Maven已经添加到环境变量，那么可以自动找到，如果没有配置，那么需要手动添加User setting file为你的Maven配置文件，如果不是默认路径需要手动添加Local repository为你的Maven仓库，如果不是默认路径需要手动添加 最后输入工程名称和工程位置 首次使用Maven会下载一些东西需要一些时间 二 配置tomcat 首先在tomcat中添加tomcat插件 123456789101112&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;hostName&gt;localhost&lt;/hostName&gt; &lt;!-- Default: localhost --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 启动端口 Default:8080 --&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;!-- uri编码 Default: ISO-8859-1 --&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 这里使用的tomcat7 配置tomcat7 单击菜单栏 Run，选择Edit Configurations…，进入如下界面 默认只有一个Defaults，Maven是我配置好了的 选择+-&gt;Maven 输入Tomcat7，在Command line输入tomcat7:run完成配置 点击Run开始运行，打开浏览器查看结果如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[java8-collect方法]]></title>
    <url>%2F2018%2F01%2F13%2Fjava8-collect%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[collect方法collect 方法是Stream中一个很重要的方法，通过这个方法可以将流中的数据格式转换为需要的形式，如，List，Set，Map，求流数据的总数，流中数据某条属性的平均值或者其他值，将流中的字符串拼接为一条字符串等。 收集器是Stream用于收集某种形式的数据信息，基本上所有的Stream的终端操作都可以使用collect方法来实现 collect的定义collect方法有两种形式 方法原型1 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner); 方法原型2 &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 这里主要使用方法原型2,这个方法原型接收一个实现了Collector接口的对象，Collector接口有五个抽象方法，幸运的是java8封装了一些常用的方法供我们使用，这些常用方法封装在java.util.stream.Collectors对象中，这个对象含有多个静态方法，用来返回Collector对象 collect方法示例Apple.java public class Apple { private int weight; private String color; public Apple(int weight, String color) { super(); this.weight = weight; this.color = color; } //getter //setter } Main.java public class Main { public static void main(String[] args) { List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,&quot;green&quot;), new Apple(20,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(25,&quot;green&quot;)); //返回重量最重的苹果 System.out.println(&quot;-------------------返回重量最重的苹果----------------&quot;); Optional&lt;Apple&gt; heaviestApple = inventory.stream().collect(Collectors.maxBy(Comparator.comparing(Apple::getWeight))); System.out.println(heaviestApple); //返回重量最轻的苹果 System.out.println(&quot;-------------------返回重量最轻的苹果----------------&quot;); Optional&lt;Apple&gt; lightestApple = inventory.stream().collect(Collectors.minBy(Comparator.comparing(Apple::getWeight))); System.out.println(lightestApple); //返回苹果的总重量 System.out.println(&quot;-------------------返回苹果的总重量----------------&quot;); int sumInt = inventory.stream().collect(Collectors.summingInt(Apple::getWeight)); System.out.println(sumInt); //使用Collectors.averagingInt方法求苹果的平均重量 System.out.println(&quot;-------------------求苹果的平均重量-----------------&quot;); double averageWeight = inventory.stream().collect(Collectors.averagingDouble(Apple::getWeight)); System.out.println(averageWeight); //返回苹果的重量的各个数据 System.out.println(&quot;-------------------返回苹果重量的各个数据属性-----------------&quot;); IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); System.out.println(intSummartStatistics); //将所有苹果颜色拼接为一个字符串 System.out.println(&quot;-------------------将所有苹果颜色拼接为一个字符串-----------------&quot;); //joining会自动将流中的数据拼接为字符串，在处理时需要保证流中的数据都是字符串 String appleColors = inventory.stream() .map(Apple::getColor) //将流中的apple转换为apple的颜色 .collect(Collectors.joining(/*将每一个颜色后面加上一个空格*/&quot; &quot;)); System.out.println(appleColors); //返回苹果数量 System.out.println(&quot;-------------------返回苹果的总数量-----------------&quot;); Long count = inventory.stream().collect(Collectors.counting()); System.out.println(count); //分组 System.out.println(&quot;-------------------将苹果按照苹果颜色进行分组----------------&quot;); Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); System.out.println(appleColorMap); System.out.println(&quot;-------------------将苹果按照苹果颜色和重量进行分组 ----------------&quot;); System.out.println(inventory.stream().collect(Collectors.groupingBy(Apple::getColor, Collectors.groupingBy(apple -&gt; { if(apple.getWeight() &gt; 10 &amp;&amp; apple.getWeight() &lt; 20) return &quot;一般&quot;; else if(apple.getWeight() &gt;= 20 ) return &quot;很重&quot;; else return &quot;轻&quot;; })))); //收集每个颜色的苹果有多少个 System.out.println(&quot;-------------------收集每个颜色的苹果有多少个----------------&quot;); Map&lt;String, Long&gt; colorCount = inventory.stream().collect(Collectors.groupingBy(Apple::getColor,Collectors.counting())); System.out.println(colorCount); //分区 System.out.println(&quot;-------------------根据苹果颜色进行分区----------------&quot;); Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals(&quot;red&quot;))); System.out.println(colorPartition); //归约 System.out.println(&quot;-------------------归约操作----------------&quot;); System.out.println(inventory.stream().collect(Collectors.reducing(0,Apple::getWeight,(a,b) -&gt; a + b))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing((a,b) -&gt; { if(a &gt; b) return a; else return b; }))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing(100,(a,b) -&gt; { if(a &gt; b) return a; else return b; }))); } } 上面代码使用了大多数Collectors的方法，还有一些类型的方法,如:averagingDouble,averagingInt,averagingLong都是相同的。Collectors中的方法大致分为分组，分区，容器（返回list，set，map），简单的数值计算和其他 其中分组和分区是有区别的，分区可以看做是分组的特殊形式，分区只会有两个区别满足条件的（true）和不满足条件的（false），不管是分区还是分组，都可以再分,分组是根据返回的条件进行分组 Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); 这里就是根据苹果的颜色进行分组，map 中只会有两个主键，red 或者 green。如果将条件改为Apple::getWeight,那么主键就会有10,20,12,25,因为有两个重量为12的苹果，这两个苹果就会分在一组 Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 这里根据苹果颜色是不是红色进行分区，只会有两个主键，true或者false，true分区里的苹果都是红色的，false分区里的值都不是红色的，但是partitioningBy里面可以传第二个参数，可以对分区里面再进行收集（collect方法）操作 容器可以为三种，List，Set，Map容器，只需要调用Collectors.toXxxx()方法就可以将流最后组装成一个容易简单的数值计算可以直接通过流计算得出，例如Stream.max()方法和Stream.collect(Collectors.maxBy())方法是相同的，在某些方面，如 IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); 可以返回多种数据的不同运算结果，还是很方便的 collect方法接收一个Collector对象，而大多数的Collector对象都可以通过Collectors对象的静态工厂方法获取，如果有需要可以查阅手册 参考源码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-使用流]]></title>
    <url>%2F2018%2F01%2F12%2Fjava8-%E4%BD%BF%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[流介绍流是java API的新成员，他允许你以声明的方式处理数据集合（通过查询语句，而不是临时编写一个实现） 使用流集合是流最容易上手的方式，Java8 中的集合支持一个新的stream方法，他会放回一个流对象（接口定义在java.util.stream.Stream）中 使用流可以完成什么事？他可以让我们以一种流水线的方法处理集合数据 像我们前面处理苹果集合时那样，可以实现一个方法来收集或处理某些数据，比如过滤颜色不是红色的苹果，收集苹果的重量列表，但是每一次都需要调用一个方法，流为我们处理这种“一系列”数据提供了一些方法，可以像工厂流水线的方法对流数据进行处理 比如要收集颜色是红色苹果的重量集合，可以想这样写 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).map(Apple::getWeight).forEach(System.out::println); 这里先通过方法stream()生成一个流对象，再使用filter方法过滤掉颜色不是红色的苹果，接着通过map将所有颜色是红色的苹果的重量返回成一个数值流也就是剩下苹果重量的集合，接着调用forEach方法打印剩下苹果的重量。可以读作先过滤掉颜色不是红色的苹果，接着返回所有苹果重量的集合，然后打印如果使用上一节自定义方法实现这些操作书写格式如下: inventory = filter(inventory,apple -&gt; apple.getColor().equals(&quot;red&quot;)); List&lt;Integer&gt; weights = map(inventory,Apple::getWeight); forEach(weights, System.out::println); 可以看见流的可读性以及书写性都要高于自定义实现 流方法流的方法分为两类，一类是中间操作，一类是终端操作，中间操作是对流完成操作之后还会返回一个流对象，而终端操作的返回结果是任何不是流的值，前面的filter，map就是中间操作，forEach就是终端操作 使用流方法对苹果库存进行操作 使用forEach打印数据 inventory.stream().forEach(System.out::println); 筛选颜色为红色的苹果 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).forEach(System.out::println); 对苹果颜色进行排序，如果个颜色相同，根据重量大小由小到大排序 Comparator&lt;Apple&gt; colorSort = (a1,a2) -&gt; a1.getColor().compareTo(a2.getColor()); Comparator&lt;Apple&gt; weightSort = (a1,a2) -&gt; a1.getWeight() - a2.getWeight(); inventory.stream().sorted(colorSort.thenComparing(weightSort)).forEach(System.out::println); 去除颜色和重量相同的苹果 inventory.stream().distinct().forEach(System.out::println); 只获取前三个苹果 inventory.stream().limit(3).forEach(System.out::println); 跳过前面两个苹果，只获取后面三个 inventory.stream().skip(2).forEach(System.out::println); 不要第一个苹果也不要最后一个苹果 inventory.stream().skip(1).limit(inventory.size() - 2).forEach(System.out::println); 将所有苹果的重量加10 inventory.stream().peek(apple -&gt; apple.setWeight(apple.getWeight() + 10)).forEach(System.out::println); 查看有没有重量是20,颜色是红色的苹果 System.out.println(inventory.stream().anyMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是所有苹果的重量是20,颜色是红色 System.out.println(inventory.stream().allMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是没有苹果是红色的 System.out.println(inventory.stream().noneMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看第一个苹果 System.out.println(inventory.stream().findFirst()); 返回苹果的总重量 System.out.println(inventory.stream().map(Apple::getWeight).reduce(0, (a,b) -&gt; (a + b))); 返回苹果的最小重量 System.out.println(inventory.stream().map(Apple::getWeight).min((n1,n2) -&gt; n1 - n2)); 返回苹果的最大重量 System.out.println(inventory.stream().map(Apple::getWeight).max((n1,n2) -&gt; n1 - n2)); 流的终端操作 方法 作用 boolean allMatch(Predicate&lt;? super T&gt; predicate) 如果流对象都可以匹配谓词，返回true，否则返回false boolean anyMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中有一个或多个匹配谓词，返回true，否则返回false boolean noneMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中任何一个都没有匹配谓词，返回true，否则返回false Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最大值 Oprional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最小值 Optional&lt;T&gt; findAny() 未知 Optional&lt;T&gt; findFirst() 返回流对象中的第一个值 long count() 返回流中数据的个数 &lt;R,A&gt; R collect(Collecotr&lt;? super T,A,R&gt; collector) 未知 &lt;R&gt; R collecot(Supplier&lt;R&gt; supplier,BiConsumer&lt;R,? super T&gt; accumulator,BiConsumer&lt;R,R&gt; combiner) 未知 void forEach(Consumer&lt;? super T&gt; action) 未知 void forEachOrDered(Consumer&lt;? super T&gt; action) 未知 Oprional&lt;T&gt; reduce&lt;T identity,BinaryOperator&lt;T&gt; accumulator) 未知 &lt;U&gt; U reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner) 未知 Object[] toArray() 未知 &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) 未知 流的中间操作 方法 作用 distinct() 去重，流中的对象需要实现equlas方法 filter(Predicate&lt;? super T&gt; predicate) 按照规则过滤，满足规则的留下，不满足的去掉 limit(long maxSize) 返回数据的最大个数，10表示返回10个数据，5表示返回5个 map(Function&lt;? super T,? extends R&gt; mapper) 将每个流对象作为函数的参数，并且将返回值填充流对象 flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 将每个流对象作为函数的参数，但是只返回一个流对象 peek(Consumer&lt;? super T&gt; action) 可以在流处理时对每个流数据进行操作，并返回Stream对象 skip(long n) 跳过n个数据，n等于10,表示跳过前面10个数据，和limit方法一起使用效果更好 sorted() 默认排序，排序类需要实现默认排序接口 sorted(Comparator&lt;? super T&gt; comparator) 使用自定义排序对流数据进行排序 值得注意的是flatMap方法，这个方法和map方法不同，map方法会将每一个流对象都作用于Function&lt;? super T,? extends R&gt;返回一个R对象，flatMap方法也会将所有的流对象作用于Function的方法，但是只会返回一个`流对象`，这个方法可以用作一个流中的对象的属性是集合，并且需要将所有流对象为集合的属性收集起来的情况，比如收集几个字符串中所有不重复的字符。 参考源码 限于知识和认识有限，页面中难免出现纰漏，如有错误可以发送邮件至canxing_zh@163.com邮箱指正，我将不胜感激。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-复合lambda表达式]]></title>
    <url>%2F2018%2F01%2F11%2Fjava8-%E5%A4%8D%E5%90%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java8中的函数式借口提供了允许你进行复合的方法，可以把多个lambda表达式复合成更复杂的表达式,就好像与操作(and)，或操作(or)，非操作(not)，以及组合操作 Predicate系列的组合操作接口 相关方法 Predicate&lt;T&gt; Predicate&lt;T&gt; negate() Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) DoublePredicate negate() DoublePredicate DoublePredicate and(DoublePredicate other) DoublePredicate or(DoublePredicate other) IntPredicate negate() IntPredicate IntPredicate and(IntPredicate other) IntPredicate or(IntPredicate other) LongPredicate negate() LongPredicate LongPredicate and(LongPredicate other) LongPredicate or(LongPredicate other) BiPredicate&lt;T,U&gt; negate() BiPredicate&lt;T,U&gt; BiPredicate&lt;T,U&gt; and(BiPredicate&lt;? super T,? super U&gt; other) BiPredicate&lt;T,U&gt; or(BiPredicate&lt;? super T,? super U&gt; other) Predicate系列的每个借口都含有and,or,not操作，可以和其他相同的借口进行组合对于苹果类，根据苹果的颜色和重量筛选符合要求的苹果可以有 //筛选颜色为红色的苹果 Predicate&lt;Apple&gt; redApple = (Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;); //筛选苹果重量大于15的苹果 Predicate&lt;Apple&gt; weightApple = apple -&gt; apple.getWeight() &gt; 15; //对苹果的颜色和重量筛选进行复合，筛选出即是红色重量有大于15的苹果 List&lt;Apple&gt; filterApples = filter(inventory,redApple.and(weightApple)); //筛选出是红色或者重量大于15的苹果 filterApples = filter(inventory,redApple.or(weightApple)); //筛选出既不是颜色既不是红色重量也不大于15的苹果 filterApples = filter(inventory,redApple.negate().or(weightApple.negate())); Function系列的组合操作接口 相关方法 Function&lt;T,R&gt; Function&lt;T,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before) BiFunction&lt;T,U,R&gt; BiFunction&lt;T,U,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function系列的接口只有Function和BiFunction可以进行复合操作 Function的意思是函数，作为函数，具有参数和返回值，类似于f(x) = x + 1, 那么Function的addThen方法可以理解为将我的返回值作为别的函数的参数，在别的函数中进行函数运算。 如果说有两个函数 f(x) = x + 1 和 g(y) = y + 2，那么addThen可以将f(x)的返回值作为g(x)的参数传递进去，类似于g(f(x)) = f(x) + 2 = (x + 1) + 2这种 同样compose方法可以将别的函数的返回值作为自己的参数进行函数运算 BiFunction和Function不同的是，他具有三个泛型参数，以及他的addThen方法接收的是一个Function&lt;? super V,? extends T&gt;对象 同样也是将BiFunction的运算结果作为Function的参数，返回Function的运算结果 使用Function接口实现为苹果的重量加20，并返回一个列表 //获取苹果的重量 Function&lt;Apple,Integer&gt; getWeight = Apple::getWeight; //将一个数字加上20,在这里这个数字表示重量 Function&lt;Integer,Integer&gt; addWeight = weight -&gt; weight + 20; //使用Function的addThen方法将所有苹果的重量加上20并返回一个列表 List&lt;Integer&gt; weights = map(inventory,getWeight.andThen(addWeight)); //使用Function的compose方法将所有苹果的重量加上20并返回一个列表 weights = map(inventory,addWeight.compose(getWeight)); Consumer系列接口接口 相关方法 Consumer&lt;T&gt; Consumer&lt;T&gt; addThen(Consumer&lt;? super T&gt; after) DoubleConsumer DoubleConsumer addThen(DoubleConsumer after) IntConsumer IntConsumer addThen(IntConsumer after) LongConsuemr LongConsumer addThen(LongConsumer after) BiConsumer&lt;T,U&gt; BiConsumer&lt;T,U&gt; addThen(BiConsumer&lt;? super T,? super U&gt; after) Consumer系列的接口只接收一个泛型参数的都可以使用addThen方法，接收两个参数的只有BiConsumer接口可以使用addThen方法 关于addThen方法，很显然，在经过当前的Consumer对象的处理之后，可以继续被某个Consumer对象处理 使用Consumer将苹果的重量在原有的基础上乘2再加上10 //将苹果的重量乘2 Consumer&lt;Apple&gt; two = apple -&gt; apple.setWeight(apple.getWeight() * 2); //将苹果的重量加10 Consumer&lt;Apple&gt; add = apple -&gt; apple.setWeight(apple.getWeight() + 10); //使用组合将苹果的重量先乘2再加10 forEach(inventory,two.andThen(add)); 参考源码限于知识和认识有限，页面中难免出现纰漏，如有错误可以发送邮件至liuxin739525@163.com邮箱指正，我将不胜感激。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian-环境搭建]]></title>
    <url>%2F2018%2F01%2F08%2Fdebian-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[今天卸载了ubuntu，换了debian系统，重装系统方式为保留/home，/opt目录，重装/根目录 使用usb installer创建debian启动盘选择系统类型时，选择debian系统无法正确的创建启动盘，要选择其他linux系统类型才能正常创建 安装系统三个挂载目录，/,/home，/opt，其中/home和/opt是原来使用的挂载目录，没有改变，只覆盖了/目录debian桌面环境选择xfce桌面，核心功能模块 联网安装完系统后，第一步就是联网，正常连接校园网，免去了回退ubuntu的烦恼 设置镜像源debian在中国有两个主镜像源 12ftp2.cn.debian.org/debian/ftp.cn.debian.org/debian/ debian的主镜像源在国内也可以正常访问在/etc/apt/source.list文件中添加以下类似的源deb http://ftp.cn.debian.org/debian stretch main non-free 安装vim切换管理员用户 12suapt-get install vim-gnome 安装中文输入法linux下的中文输入法有很多，这里选择fcitx，其他的ibus和搜狗输入法都与各种原因没有安装上，很遗憾没有体验一次切换管理员用户 su apt install fcitx apt install im-config apt install fcitx-sunpinyin 这个中文输入可以自行更换，不一定只能是这个 然后输入im-config进行配置，将下载的输入法添加到fcitx中就行了 配置java环境原来的java文件夹位于/opt/jdk下，因为没有覆盖/opt，所以不用重新下载修改.bashrc文件，在哪个用户目录下修改.bashrc就只会影响该用户在最后添加 export JAVA_HOME=/opt/jdk export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib 修改完成后，使用输入 source ～/.baserc java -version 如果看见java信息说明安装成功但是注销后进入发现运行的java不是sunjdk，而是openjdk，直接卸载openjdk，发现由于依赖关系，debian自动又下载了一个gcj-jdk，将依赖的libreoffice卸载后，sunjdk运行成功 配置maven环境同样修改.bashrc,在最后添加下面语句 export PATH=${PATH}:/opt/maven/bin 配置eclipseeclipse也是放在/opt目录下，没有修改，但是无法运行，报错缺少java运行时的环境。解决方法，修改eclipse目录下的eclipse.ini文件，在最开始添加 -vm /opt/jdk/bin 运行成功 安装mysql前往mysql下载页面根据版本下载mysql包在mysql包下载目录下打开终端，输入 dpkg -i mysql-apt-config_w.x.y-z_all.deb apt-get update apt-get install mysql-server 下载mysql server，中途会选择版本，输入管理员密码 修改mysql字符集，解决中文乱码问题编辑/etc/mysql/my.cnf，输入下面几句话 [client] default-character-set=utf8 [mysqld] character-set-server=utf8 退出，使用service mysql stop 停止mysql 服务然后在使用service mysql start 开启mysql服务进入mysql输入 show variables like &quot;%char%&quot;; 查看字符集，如果都是utf8说明修改成功，如果失败，再去找找其他办法吧 下载msyql-workbenchapt install mysql-workbench 安装gitapt install git 安装visual studio code前往visual studio code官网，下载deb包 dpkg -i codeXXXXX.deb apt-get install -f 解决冲突问题 安装chrome下载文件包 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 执行安装命令 dpkg -i google-chrome-stableXXX.deb 解决依赖问题 apt-get install -f 根据选择的架构不同，安装的chrome版本不同 安装hexonode.js 安装命令 wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装之后需要配置到用户环境变量 ~/.bashrc export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 然后使用下载 nvm install stable hexo 安装命令 npm install -g hexo-cli 安装pip3根据python版本，python2使用如下命令下载 apt-get install python-pip python3使用如下命令 apt-get install python3-pip 安装jupyter notebookjupyter官方安装指南 更新pip pip3 install –upgrade pip 下载jupyter pip3 install jupyter安装jupyter之后因该是可以直接启动，但是输入命令jupyter notebook无法正常启动，重启后输入命令 jupyter notebook可以正常启动 注意:如果在第2步安装jupyter时出错，无法导入name为’main’可以尝试使用以下命令修复 apt install --reinstall python3-requests 安装idle3apt install idle3 安装shadowsocks-qt5客户端感谢网友提供的连接安装成功 安装无线网卡驱动apt install firmware-iwlwifi modprobe -r iwlwifi ; modprobe iwlwifi 安装virtualbox[官方指南][https://www.virtualbox.org/wiki/Linux_Downloads] 先将virtualbox的源添加到主机，这里的mydist指的是你的系统名称 deb https://download.virtualbox.org/virtualbox/debian &lt;mydist&gt; contrib 添加密钥到主机 wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add - wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add - 更新源并下载virtualbox，并不是只能下载virtualbox5.2版本可以选择其他版本下载 apt update apt install virtualbox-5.2 安装kazamapt install kazam 安装dia1apt install dia 安装dia有可能会遇到无法输入中文字符的问题，解决方法如下: 1231. 点击一个流程图下的图形2. 绘出图形3. 在图形上右键`-&gt;`Input Methods 选择X输入法 ssh如果是第一次使用ssh可以使用ssh-keygen生成密钥对 1ssh-keygen 然后使用ssh-copy-id 将公钥发送给远程主机 1ssh-copy-id username@ip-addr 然后在远程主机上将公钥文件名称修改为authorized_keys接着使用ssh登陆远程主机，如果不要密钥可以成功登陆那么完成如果不行你也许还要做这一步 1ssh-add private-key 将你的私钥保存起来]]></content>
      <categories>
        <category>debian-environment</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java8-方法引用]]></title>
    <url>%2F2018%2F01%2F07%2Fjava8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是方法引用方法引用是lambd表达式的一种特殊形式。看起来更易读更自然 如果想要对苹果的重量进行排序我们可以这样写: inventory.sort((a1,a2) -&gt; a1.getWeight() - a2.getWeight()); 使用方法引用之后是这样的 inventory.sort(Apple::getWeight); 方法引用的语法格式 指向静态方法的引用Class::staticMethod 指向现有对象的实例方法的方法引用object::instanceMethod 指向任意类型实例方法的方法引用Class::instanceMethod 语法简述指向静态方法的引用类的静态方法必须满足函数描述符，也就是Class.staticMethod的参数和返回值要和函数描述符一致 对于Function function = Class::staticMethod;Class的staticMethod的静态方法定义应该是: public static intstaticMethod(int number){ //一个返回int类型的代码块 } 对于Consumer consumer = Class:staticMethod;Class的staticMethod的静态方法定义应该是: public static void staticMethod(int number){ //没有返回值的代码块 } 对于Predicate pred = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static boolean staticMethod(int number){ //返回boolean类型的代码块 } 对于Supplier supplier = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static int staticMethod(){ //返回int类型的代码块 } 指向现有对象的实例方法的方法引用类的实例方法必须满足函数描述符，也就是对象调用的方法的参数和返回值要和函数描述法一致 对于Function function = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 如果是BiFunction function = object::instanceMethod;Class的实例方法定义应该是: public int instacneMethod(int number){ //返回int类型的代码块 } 下同 对于Consumer consumer = object::instanceMethod;Class的实例方法定义应该是: public void instacneMethod(int number){ //没有返回值的代码块 } 对于Predicate predicate = object::instanceMethod;Class的实例方法定义应该是: public boolean instanceMethod(){ //返回boolean类型的代码块 } 对于Suplier supplier = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 对于第三种格式，函数描述符至少含有一个参数，也就是说必须有一个参数用来调用方法 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(int number){ //返回int类型的代码块 } 对于Consumer consumer = Class::instanceMethod;Class的实例方法定义应该是: public void instanceMethod(){ //没有返回值的代码块 } 对于Comparator comparator = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(Class clazz){ //比较两个数大小的代码块，最后返回一个数用来表示大于，小于，等于 } 实例:使用方法引用来完成列表苹果的筛选，排序，输出，增加重量，返回对应的苹果重量列表 Apple.java public class Apple { private int weight; private String color; //getter setter } Main.java public class Main { public static void main(String[] args) { List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,&quot;green&quot;), new Apple(20,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(25,&quot;green&quot;)); List&lt;String&gt; strs = Arrays.asList( &quot;red&quot;,&quot;green&quot;,&quot;red&quot;,&quot;black&quot; ); //筛选 List&lt;Apple&gt; redApples = filter(inventory,Apple::getColor,&quot;red&quot;); forEach(redApples,System.out::println); List&lt;String&gt; red = filter(strs,String::toString,&quot;red&quot;); forEach(red,System.out::println); //将所有苹果的重量表示为一个列表 List&lt;Integer&gt; appleWeight = map(inventory,Apple::getWeight); forEach(appleWeight,System.out::println); //将所有苹果的重量加10 addWeight(inventory,Apple::getWeight,Apple::setWeight,10); forEach(inventory,System.out::println); //排序 inventory.sort(Comparator.comparing(Apple::getColor)); forEach(inventory,System.out::println); } public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } public static &lt;T&gt; void addWeight(List&lt;T&gt; inventory,ToIntFunction&lt;T&gt; func,ObjIntConsumer&lt;T&gt; consumer,int added) { for(T t : inventory) { consumer.accept(t,func.applyAsInt(t) + added); } } public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { result.add(func.apply(t)); } return result; } public static &lt;T,R&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Function&lt;T,R&gt; func,Object obj){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { if(func.apply(t).equals(obj)) { result.add(t); } } return result; } } 可以看见方法引用的可读性是要强于lanbda表达式的，如： List redApples = filter(inventory,Apple::getColor,”red”); 可以读作:筛选苹果库存中颜色为红色的苹果 inventory.sort(Comparator.comparing(Apple::getColor)); 可以读作:库存根据苹果的颜色进行排序但是方法引用在某些方面的比较复杂的，比如要将所有苹果的重量加10,需要使用两个方法引用 addWeight(inventory,Apple::getWeight,Apple::setWeight,10); 参考源码限于知识和认识有限，页面中难免出现纰漏，如有错误可以发送邮件至liuxin739525@163.com邮箱指正，我将不胜感激。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-函数式接口]]></title>
    <url>%2F2018%2F01%2F05%2Fjava8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在上一次使用自定义的函数接口来使用lambda表达式，每一个lambda都要自定义一个已知的接口来实现，这样比较麻烦，如果可以使用通用的函数式接口，那么会方便很多。幸运的是java8中新增了一些通用的函数式接口供我们使用。下面就来看看吧。 函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口 —《java核心技术卷I基础知识第10版》一言蔽之，只有一个抽象方法的接口称为函数式接口 —《java8实战》 java8提供了一系列通用的函数式接口，位于java.util.function包中 可以看见这个包中只有含有接口，没有任何的抽象类，类，这些接口都需于函数接口，不要慌张，这些接口大部分表达的意思相同，只有少量的区别 函数描述符函数式接口的抽象方法的签名基本上就是lambda表达式的签名。我们将这种抽象方法叫做函数描述符lambda表达式的参数和返回值都要和函数式接口的签名对应，比如说函数式接口ApplePredicate的签名就是接收一个Apple类型的参数返回一个boolean类型的参数所以基本上满足接收一个Apple类型返回一个boolean类型的lambda表达式都可以看作是ApplePredicate的实现 下面来介绍几个函数式接口 Consumer翻译过来为消费者，接收一个参数没有返回值。源码接口如下： public interface Consumer&lt;T&gt; { void accept(T t); } 使用Consumer来实现一个List的遍厉public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } //使用forEach遍历列表 forEach(redApples,apple -&gt; System.out.println(apple)); 其他Consumer系列接口 接口 抽象方法 DoubleConsumer void accept(double value); IntConsumer void accept(int value); LongConsumer void accept(long value); ObjDoubleConsumer&lt;T&gt; void accept(T t,double value); ObjIntConsumer&lt;T&gt; void accept(T t,int value); ObjLongConsumer&lt;T&gt; void accept(T t,int long value); BiConsumer&lt;T,U&gt; void accept(T t,U u); Predicate谓词，用来描述或判断客体性质等(百度百科),这里用来表示判断 Predicate接口有5个方法，包括4个默认方法，1个抽象方法，默认方法以后再说，这里主要关注抽现方法 接口源码如下,接收一个泛型参数，返回一个boolean型数据，至于根据什么返回，怎么判断交给用户来实现 public interface Predicate&lt;T&gt;{ boolean test(T t); } 使用Predicate来实现过滤 public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Predicate&lt;T&gt; pred){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) if(pred.test(t)) result.add(t); return result; } 筛选红色苹果 List&lt;Apple&gt; redApples = filter(inventory,(Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;)); forEach(redApples,apple -&gt; System.out.println(apple)); 其他Predicate系列接口 接口 抽象方法 DoublePredicate boolean test(double value); IntPredicate boolean test(int value); LongPredicate boolean test(long value); BiPredicate&lt;T,U&gt; boolean test(T t,U u); DoublePredicate,LongPredicate,IntPredicate分别是用来判断double,long,int类型，由于double,long,int类型在使用泛型时会有一个自动装箱拆箱的过程，这是为了提高效率实现的三个类,使用上和Predicate没有什么区别 Function函数，接收一个参数返回一个值 public interface Function&lt;T,R&gt;{ R apply(T t); } 使用Function来实现遍历列表，并对列表进行某种操作，操作后返回一个值 public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) result.add(func.apply(t)); return result; } 使用map来将列表中的所有苹果的重量返回并用列表返回 List&lt;Integer&gt; weights = map(inventory,(Apple apple) -&gt; apple.getWeight()); 其他Function系列接口 接口 抽象方法 DoubleFunction&lt;R&gt; R apply(double value); IntFunction&lt;R&gt; R apply(int value); LongFunction&lt;R&gt; R apply(long value); ToDoubleFunction&lt;T&gt; double apply(T value); ToIntFunction&lt;T&gt; int apply(T value); ToLongFunction&lt;T&gt; long apply(T value); BiFunction&lt;T,U,R&gt; R apply(T t,U u); ToDoubleBiFunction&lt;T,U&gt; double apply(T t,U u); ToIntBiFunction&lt;T,U&gt; int apply(T t,U u); ToLongBuFunction&lt;T,U&gt; long apply(T t,U u); 可以看见大多数接口都是为了解决基本类型的封箱拆箱进行优化的接口 Supplier供应商，没有参数，只有返回值。少有使用，这里只提供接口 接口 抽象方法 Supplier&lt;T&gt; T get(); BooleanSupplier boolean get(); DoubleSupplier double get(); IntSupplier int get(); LongSupplier long get(); 其他函数式接口java.util.function包中还有几个使用Operator结尾的接口，现在还不太明白如何使用，以后再加。 参考源码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-lambda表达式]]></title>
    <url>%2F2018%2F01%2F04%2Fjava8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[测试环境 JDK 10 ，JUnit4 如何使用 lambda 表达式 定义一个只含有一个抽象方法的接口 AbstractFuncOfSingle (只能是接口) 123public interface AbstractFuncOfSingle &#123; int print(int a, int b);&#125; 传入两个int类型的参数，返回一个类型的参数 定义一个方法，传入参数为 AbstractFuncOfSingle 1234public void callAbstractFuncOfSingle(AbstractFuncOfSingle singleFunc, int a, int b)&#123; int result = singleFunc.print(a, b); System.out.println(result * 2);&#125; 在方法中将方法参数 a，b 作为参数传入 AbstractFuncOfSingle.print() 方法，并使用 result 接收返回参数然后打印 调用上述方法 1234567@Testpublic void testAbstractFuncOfSingle()&#123; callAbstractFuncOfSingle((a, b)-&gt;&#123; System.out.println(a + b); return a + b; &#125;, 10, 23);&#125; 使用 lambda 表达式创建一个内部类，打印 a + b 的和并返回 a + b 和 如果接口的抽象方法具有多个参数，那么 lambda 的传入参数个数也要一一对应，如果抽象方法具有返回值，在 lambda 表达式中也要有返回值，否则可以省略 return 语句注意：lambda 表达式的参数类型和返回类型要和抽象方法的参数类型和返回类型相同 lambda 表达式和匿名内部类lambda 表达式是匿名内部类的一种简化形式，lambda 表达式只能书写于只有一个抽象方法的接口，匿名内部类可以书写具有多个抽象方法的接口和抽象类 实例代码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-tcp套接字编程]]></title>
    <url>%2F2017%2F12%2F28%2Fjava-tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是套接字传送们维基百科java中的套接字屏蔽了许多细节，不需要关注更多的底层信息。在java中套接字服务器可以使用java.net.ServerSocket创建一个常用的构造方法如下: 1ServerSocket server = new ServerSocket(int port); port: 表示套接字服务器需要监听的本机的端口，常见的端口有80端口，3306端口等，这个监听的端口不允许重复监听，建议使用靠后面的端口号然后可以使用 Socket client = server.accept()等待客户端的连接并返回一个Socket对象，通过这个Socket对象可以和客户端进行通信: 12OutputStream out = client.getOutputStream();InputStream in = client.getInputStream(); out可以向客户端输出消息，in可以接受客户端的消息（消息的输入和输出都是相对于内存而言的，如果是写入内存中，那么就是输入，如果是从内存中读出，那么就是输出）服务器一般都是长时间运行服务多个客户端，所以服务器一般不会关闭，在客户端和服务器中端连接时，只需要关闭输入输出流就行了。 套接字客户端的创建使用Socket创建，需要指定要连接的ip地址和端口，这个端口要和套接字服务器监听的端口号相同，ip地址要和套接字服务器所在主机的ip地址相同，linux下可以使用ifconfig命令查看ip地址，如果是在本机进行套接字编程，可以使用127.0.0.1或者localhost确定本机ip 1Socket socket = new Socket(Stirng ipAddress,int port); 创建套接字之后就可以获取输入输出流和服务器交流，这里的输入输出流是相对于客户端的输入输出，客户端的输入是服务器端的输出。 客户端不同于服务器，客户端关闭时需要关闭Socket，使用socket.close()关闭 一个简单的服务器Socket： 123456789101112131415//创建套接字服务器ServerSocket server = new ServerSocket(int port);//套接字服务器一般不会关闭，所以使用死循环不同的获取连接，在获取客户端连接是一般要开线程while(true)&#123; //获取客户端连接 Socket socket = server.accept(); //获取输入输出流,按情况获取，如果即需要输入也需要输出那么两个都需要获取，io可以包装成Reader和Writer OutputStream out = socket.getOutputStream();//获取输出流 InputStream in = socket.getInputStream();//获取输入流 //进行消息的获取或发送 //... //关闭输入输出流 out.close(); in.close();&#125; 简单的客户端套接字: 123456789101112131415//创建客户端套接字Socket socket = new Socket(String serverIp,int port);//获取输入输出流（一般来说客户端都是会先获取输出流发送消息到服务器，服务器返回消息，客户端使用输入流获取）OutputStream out = socket.getOutputStream();InputStream in = socket.getInputStream();//进行消息的发送与接收,可以使用死循环，在循环使用特殊字符串之类的东西退出while(true)&#123; //flag; //发送和接受&#125;//关闭输入输出流out.close();in.close();//关闭套接字socket.close(); 参考源码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax异步处理]]></title>
    <url>%2F2017%2F12%2F16%2Fajax%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[AJAX 异步处理AJAX异步处理基本操作,参考教程w3school AJAX是什么AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX可以在页面不刷新的情况更新局部页面，也可以在页面加载过程中先加载重要部分在加载不那么重要的部分，提高页面加载速度 AJAX工作流程AJAX基本对象 XMLHttpRequest是AJAX的基础，XMLHttpRequest 用于在后台与服务器交换数据 1. XMLHttpRequest的创建现代浏览器内置XMLHttpRequest对象使用如下方式创建 1xmlhttp = new XMLHttpRequest(); 老版本的IE浏览器不支持XMLHttpRequest对象，使用ActiveXObject对象创建: 1xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); 根据浏览器的不同使用不同的方式创建对象 123456var xmlhttp = null;if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();&#125;else&#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")&#125; 2. 使用AJAX发送请求使用的方法如下: 123456789open(method,url,async) 规定请求类型，URL，是否异步处理请求 method:请求类型;GET/POST url:要请求的连接;如www.google.com async:是否同步;true(异步)/false(同步)send(String) 发送请求到服务器 string:仅用于post请求setRequestHeader(header,value) 向请求添加HTTP头 header:规定头的名称 value:规定头的值 3. 获取响应涉及属性如下: responseText 获得字符串形式的相应数据 responseXML 获得XML形式的响应数据 4. onreadystatechange事件onreadystatechange是当AJAX请求发送到服务器时，根据服务器的处理进度进行反馈的标志 12345678910readyState 属性 存储XMLHttpRequest的状态，从0到4变化 0：请求为初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪status 200：“ok” 404：paga not foundonreadystatechange 存储函数名，在每次readyState变化时调用存储的函数 一个基本的请求相映模板12345678910111213141516function loadXMLDoc()&#123; var xmlhttp = null; if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest(); &#125;else&#123; xmlhttp = new ActiveXObject("Microsoft.XMLHTTP") &#125; xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.state == 200 &amp;&amp; xmlhttp.readeyState == 4)&#123; //获取响应数据 var responseT = xmlhttp.responseText; &#125; &#125;; xmlhttp.open("GET","www.baidu.com",true); xmlhttp.send(null);&#125; 一个使用ajax发送到服务器，服务器使用spring-mvc返回JSON数据并在页面显示的实例源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fjson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[JSON是什么JSON：JavaScript 对象表示法（JavaScript Object Notation）。JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。参考w3school JSON实例{ &quot;employees&quot;: [ { &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; }, { &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; }, { &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; } ] } 使用python表示JSON实例one = {&quot;firstName&quot;:&quot;Bill&quot;,&quot;lastName&quot;:&quot;Gates&quot;} two = {&quot;firstName&quot;:&quot;George&quot;,&quot;lastName&quot;:&quot;Bush&quot;} three = {&quot;firstName&quot;:&quot;Thomas&quot;,&quot;lastName&quot;:&quot;Carter&quot;} employees = [one,two,three] o = {&quot;employess&quot;:employees} 使用java表示JSON实例Map&lt;String,String&gt; one = new HashMap&lt;&gt;(); Map&lt;String,String&gt; two = new HashMap&lt;&gt;(); Map&lt;String,String&gt; three = new HashMap&lt;&gt;(); one.put(&quot;firstName&quot;,&quot;Bill&quot;); one.put(&quot;lastName&quot;,&quot;Gates&quot;); two.put(&quot;firstName&quot;,&quot;George&quot;); two.put(&quot;lastName&quot;,&quot;Bush&quot;); three.put(&quot;firstName&quot;,&quot;Thomas&quot;); three.put(&quot;lastName&quot;,&quot;Carter&quot;); List&lt;Map&lt;String,String&gt;&gt; employees = new LinkedList&lt;&gt;(Arrays.asList(one,two,three)); Map&lt;String,List&lt;Map&lt;String,String&gt;&gt;&gt; o = new HashMap&lt;&gt;(); o.put(&quot;employees&quot;,employees); 可以发现JSON并没有什么神奇的地方，只不过是一群人定义的字符床规范格式而已，用的人多了就成了标准 将JSON转换为javascript对象 javascript 可以使用内置eval()函数将JSON数据生成原生的javascript对象var obj = eval(“(“ + JSON + “)”); JSON值有以下几种 数字(整数或浮点数)字符串(双引号中)逻辑值(true或false)数组(在方括号中)对象(在花括号中)null 使用本地JSON构建javascript对象实例可以在w3school找到，这里给出一个使用java:spring-mvc返回json对象并转换成javascript对象的实例spring-mvc返回JSOn数据参考源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-mvc返回json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fspring-mvc%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[spring-mvc返回json数据在使用spring-mvc过程中遇到很多问题，记录下来方便查看 开发环境如下:eclipse Oxygen Release (4.7.0)java1.8spring 4.3.3freemarker 2.3.26(这个不是必须的) maven依赖包如下：&lt;!-- spring mvc返回json所需依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- freemarker 引擎，有了这个就不需要使用jstl了，只需要使用freemarker表达式就行了 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring bean 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; web.xml 配置:&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动顺序，让这个Servlet随Servletp容器一起启动。 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!--会拦截URL中带“/”的请求。 --&gt; &lt;/servlet-mapping&gt; spring-mvc配置:&lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=&quot;canxing.web&quot; /&gt; spring-mvc配置freemarker:&lt;!-- freemarker 配置文件 --&gt; &lt;!-- freemarker config --&gt; &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/freemarker/&quot; /&gt; &lt;/bean&gt; &lt;!-- View resolvers can also be configured with ResourceBundles or XML files. If you need different view resolving based on Locale, you have to use the resource bundle resolver. --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; &lt;/bean&gt; JSONController.java:@Controller public class JSONController { @RequestMapping(path=&quot;/json&quot;,produces=&quot;application/json&quot;) public @ResponseBody User index() {//使用@RespnseBody将返回的对象转化为JSON数据 System.out.println(&quot;index start&quot;); User user = new User(); user.setUsername(&quot;canxing&quot;); user.setPassword(&quot;123&quot;); System.out.println(&quot;index end&quot;); return user; } @RequestMapping(path=&quot;/&quot;) public String test() { return &quot;test&quot;; } } User.java：//类不需要进行处理，只是一个普通的pojo类 public class User{ private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; } } test.flt:&lt;html&gt; &lt;head&gt; &lt;title&gt;freemarker test &lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function loadXMLDoc() { xmlhttp=null; if (window.XMLHttpRequest) {// code for Firefox, Mozilla, IE7, etc. xmlhttp=new XMLHttpRequest(); } else if (window.ActiveXObject) {// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } if (xmlhttp!=null) { xmlhttp.onreadystatechange=state_Change; xmlhttp.open(&quot;GET&quot;,&quot;http://localhost:8080/spring_web_test/json&quot;,true); xmlhttp.send(null); } else { alert(&quot;Your browser does not support XMLHTTP.&quot;); } } function state_Change(){ var obj = eval(&quot;(&quot; + xmlhttp.responseText + &quot;)&quot;); document.getElementById(&quot;username&quot;).innerHTML=obj.username document.getElementById(&quot;password&quot;).innerHTML=obj.password } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;freemarker test&lt;/h1&gt; username : &lt;span id=&apos;username&apos;&gt;&lt;/span&gt;&lt;br&gt; password : &lt;span id=&apos;password&apos;&gt;&lt;/span&gt;&lt;br&gt; &lt;button type=&apos;button&apos; onclick=&quot;loadXMLDoc()&quot;&gt;adfads&lt;/button&gt; &lt;/body&gt; 参考源码寻找答案中遇到的问题 依赖问题，spring默认的对象转化为json的jar包依赖，网上多是直接使用并没有说明依赖 还是依赖问题，spring和jackson之间版本的兼容性太差，稍微更改以下jackson或者spring的版本就会导致NoSuchMethodError错误，据说这里可以看见版本支持，但是看不懂]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>json</tag>
        <tag>spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下gpg的基本使用]]></title>
    <url>%2F2017%2F12%2F10%2Fubuntu%E4%B8%8Bgpg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是gpg 课程实验需要使用pgp对文件进行加密解密操作，pgp是一套用于消息加密、验证的应用程序，采用IDEA的散列算法作为加密与验证之用,但是pgp是商业软件不能自由使用，所以有自由软件基金会开发一个pgp的替代品，取名GnuPG，这就是gpg。 安装gpg 在ubuntu16.04下gpg已经安装好了，可以使用如下命令gpg -h如果输出有gpg的帮助文档，那么就有gpg，如果没有可以前往 gnupg官网 页面下载 gpg 基本使用 1.生成密钥 输入以下命令开始生成密钥对 gpg --gen-key *选择密钥种类，默认选择1,使用RSA and RSA算法，表示加密和签名都使用RSA算法然后选择要使用的密钥长度默认为2048,密钥长度越长，越安全，由于是课程实验，所以使用默认值选择密钥的有效期，由于是课程实验，所以选择永不过期，如果是要上传到服务器上，按情况自行选择有效期系统确认输入真实姓名电子邮箱注释然后生成用户标识然后系统最后确认接着系统让你设置一个私钥密钥，用来保护私钥接着系统生成密钥，需要大量的随机字节，按系统提示等一下就会生成密钥 2.检查密钥 查看本机密钥 gpg --list-keys 3.输出密钥 输出公钥 gpg -a -o public-key.txt --export [用户标识(可以是密钥id，就是使用gpg --list-key 查看到的密钥id)] 输出私钥 gpg -a -o private-key.txt --export-secret-keys ##4.上出公钥 由于是课程实验，所以并没有上传（其实是不知道什么原因，无法上传到服务器) 5.导入密钥 gpg --import [密钥文件] 也可以到公钥服务器上寻找(未验证) gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户id] 注意： 使用手动导入公钥会出现无法认证的问题，可以使用 gpg --fingerpring 打印指纹，指纹是每对密钥生成的时候生成的，查看指纹后可以通过电话或者其他方式到提供者验证指纹 然后使用以下命令 gpg --sign-key [公钥id] 或者使用如下命令删除 gpg --delete-keys [公钥id] 6.公钥加密 gpg -r [用户id] -o [输出文件] -e [加密文件] -r 接受者的公钥的id，可以是邮箱 -o 输出加密后的文件名 -e 要执行加密操作的数据 7.解密 gpg [解密文件] gpg 有一个默认选择 -d 默认使用你的私钥解密别人使用你的公钥解密传送过来的数据 8.数字签名 gpg -s [文件名] 生成一份签名 gpg --clearsign [文件名] 生成一份明文签名 gpg -a -b [文件名] 生成一份分离的明文签名(去掉-a就是二进制签名) 9.验证签名 gpg --verify [被签名的文件] 参考文章 http://www.ruanyifeng.com/blog/2013/07/gpg.html http://www.williamlong.info/archives/3439.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pgp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github+hexo的个人博客]]></title>
    <url>%2F2017%2F12%2F09%2F%E5%9F%BA%E4%BA%8Egithub-hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基于github+hexo的个人博客1. 本地环境配置 操作系统为 ubuntu16.04 1. git 使用 sudo apt install git下载git 2. node.js 安装命令 wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh nvm install stable 3. hexo npm install -g hexo-cli 安装hexo hexo安装 2. github 配置 前往github主页新建一个仓库，仓库名为 xxx.github.io(到时候通过xxx.github.io就可以访问个人博客，xxx最好是和github账户名相同，不同不知道是否可以) 3.创建本地文件资源 在/home/canxing/目录下创建保存博客资源文件夹 makir myblog 使用hexo初始化 hexo init ~/myblog 进入myblog文件夹 生成hexo所需要的文件目录 npm install 使用 hexo s 命令开启hexo服务，并通过localhost:4000 就可以访问一个初始的模板 4. 配置hexo hexo文件夹根目录下的_config.yml 文件为hexo的配置文件官方配置参数参考配置说明 部分参数说明如下 title:网站主标题 subtitle: 子标题 description: 网站描述 author: 作者 language: zh_CN timezone: 时区，没有设置为本地时区设置 url: 你的网站域名 root: 根路径 permalink:生成的链接的格式 theme:生成的博客系统样式，就是视图表示，可以前往hexo样式选择喜欢的样式然后使用git clone到本地 deploy: 部署选项，包括部署类型，仓库url，分支等 type: git repo: 仓库url branch: 一般是master 5. hexo预览和部署 hexo s开启hexo服务器，在网页中可以输入localhost:4000可以查看预览 hexo g生成新的文件资源 hexo d部署到github上，部署路径为_config.yml文件中的deploy的选项]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
