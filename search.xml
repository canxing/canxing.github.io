<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python3-04-字典]]></title>
    <url>%2F2018%2F05%2F09%2Fpython3-04-dict%2F</url>
    <content type="text"><![CDATA[字典时python内置的一种通过名称来访问各个值的数据结构，其值不按顺序排列，而是存储在键下。 简单使用存储字典通常以以下方式表示 &gt;&gt;&gt; a = {&apos;a&apos;:123, &apos;b&apos;:456, 42:&apos;afa&apos;, (123,34):&apos;abcdef&apos;} &gt;&gt;&gt; a {42: &apos;afa&apos;, (123, 34): &apos;abcdef&apos;, &apos;a&apos;: 123, &apos;b&apos;: 456} 访问通过存储的键来访问值 &gt;&gt;&gt; a[42] &apos;afa&apos; &gt;&gt;&gt; a[(123,34)] &apos;abcdef&apos; &gt;&gt;&gt; a[&apos;a&apos;] 123 &gt;&gt;&gt; a[&apos;b&apos;] 456 函数dict出了通过以上方式构造字典还可以通过dict函数构造字典函数dict的构造方式如下: dict() -&gt; 创建一个空字典 &gt;&gt;&gt; a = dict() &gt;&gt;&gt; a {} dict(mapping) -&gt; 从键值序列中创建字典，一个键值对就好象(key,value) dict(iterable) -&gt; 从一个可迭代类型中按照其中的键值对构建字典 d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2) 基本操作返回字典的键值对个数&gt;&gt;&gt; len({&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3}) 3 返回与键相关的值并且可以通过键赋新值&gt;&gt;&gt; a = {&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3} &gt;&gt;&gt; a[&apos;a&apos;] 1 &gt;&gt;&gt; a[&apos;a&apos;] = 132 &gt;&gt;&gt; a {&apos;c&apos;: 3, &apos;a&apos;: 132, &apos;b&apos;: 2} 删除指定键的键值对&gt;&gt;&gt; del a[&apos;b&apos;] &gt;&gt;&gt; a {&apos;c&apos;: 3, &apos;a&apos;: 132} 检查字典中是否包含指定键的键值对&gt;&gt;&gt; &apos;c&apos; in a True &gt;&gt;&gt; &apos;d&apos; in a False 字典方法clear方法clear用户清除所有字典中的键值对 &gt;&gt;&gt; a = {&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3} &gt;&gt;&gt; a.clear() &gt;&gt;&gt; a {} copy方法copy返回一个新字典，新字典中的键值对与原来字典相同，但是修改新字典并不会影响原来的字典 &gt;&gt;&gt; a = {&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3} &gt;&gt;&gt; b = a.copy() &gt;&gt;&gt; b {&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2} &gt;&gt;&gt; b[&apos;a&apos;] = 2333 &gt;&gt;&gt; b {&apos;a&apos;: 2333, &apos;c&apos;: 3, &apos;b&apos;: 2} &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3, &apos;a&apos;: 1} fromkeys方法fromkeys会将一个序列中的每个元素作为主键，指定值作为值，初始化为一个字典，这在对字典进行初始化赋值时很有用 &gt;&gt;&gt; a.fromkeys([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) {&apos;b&apos;: None, &apos;c&apos;: None, &apos;a&apos;: None} &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3, &apos;a&apos;: 1} &gt;&gt;&gt; a.fromkeys(&apos;abcd&apos;) {&apos;b&apos;: None, &apos;c&apos;: None, &apos;a&apos;: None, &apos;d&apos;: None} get方法get返回键所对应的值，如果键不存在可以返回None或者其他指定值，和d[‘key’]相比使用get不容易抛出异常 &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3, &apos;a&apos;: 1} &gt;&gt;&gt; a.get(&apos;a&apos;) 1 &gt;&gt;&gt; a.get(&apos;d&apos;) &gt;&gt;&gt; a.get(&apos;d&apos;, 32) 32 &gt;&gt;&gt; a[&apos;d&apos;] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &apos;d&apos; items方法items返回一个包含所有字典键值对的列表，其中每个元素为（key，value）形式 &gt;&gt;&gt; a.items() dict_items([(&apos;b&apos;, 2), (&apos;c&apos;, 3), (&apos;a&apos;, 1)]) &gt;&gt;&gt; for k,v in a.items(): ... print(k,&apos; &apos;, v) ... b 2 c 3 a 1 keys方法keys返回字典中所有键的列表 &gt;&gt;&gt; a.keys() dict_keys([&apos;b&apos;, &apos;c&apos;, &apos;a&apos;]) &gt;&gt;&gt; for k in a.keys(): ... print(k) ... b c a pop方法pop用于获取对应键的值并将该键值对从字典中删除，如果键不存在会抛出异常 &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3, &apos;a&apos;: 1} &gt;&gt;&gt; a.pop(&apos;a&apos;) 1 &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3} &gt;&gt;&gt; a.pop(&apos;d&apos;) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &apos;d&apos; popitem方法popitem随即弹出字典中的一个键值对，如果字典为空则抛出异常 &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3} &gt;&gt;&gt; a.popitem() (&apos;b&apos;, 2) &gt;&gt;&gt; a {&apos;c&apos;: 3} setdefault方法setdefault用于为字典中的键设置默认值，如果该键没有值，那么获取时会返回默认值，如果该键有值，那么返回键对应的值 &gt;&gt;&gt; a = {&apos;a&apos;:1, &apos;b&apos;:2, &apos;c&apos;:3} &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3, &apos;a&apos;: 1} &gt;&gt;&gt; a.setdefault(&apos;d&apos;, None) &gt;&gt;&gt; a[&apos;d&apos;] &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3, &apos;a&apos;: 1, &apos;d&apos;: None} &gt;&gt;&gt; a.get(&apos;d&apos;) values方法values用于返回字典中所有值组成的列表 &gt;&gt;&gt; a {&apos;b&apos;: 2, &apos;c&apos;: 3, &apos;a&apos;: 1, &apos;d&apos;: None} &gt;&gt;&gt; a.values() dict_values([2, 3, 1, None])]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-复习]]></title>
    <url>%2F2018%2F05%2F02%2FAndroid-review%2F</url>
    <content type="text"><![CDATA[android 体系结构 应用层 Android平台不仅仅是操作系统，也包含了常用的SMS短信客户端程序 应用框架层 Android应用开发基础，应用框架层包括活动管理器，窗口管理器，内容提供者，视图系统，包管理器，电话管理器，资源管理器，位置管理器，通知管理器和XMPP服务 系统运行库层 系统运行库分为两部分，分别是系统库和Android运行时。 系统库是应用程序框架的支撑，是连接应用程序框架层与Linux内核层的重要纽带 Adnroid运行时包括核心库和Dalvik虚拟机，前者兼容了大多数Java语言所需要调用的功能函数，有包括了Adnroid的核心库;Dalvik虚拟机主要是完成对生命周期的管理，堆栈的管理，线程的管理，安全和异常的管理以及垃圾回收 Linux内核层 Android的核心系统服务依赖于Linux内核。Linux内核层也同时作为硬件和软件栈之间的抽象层 Android四大组件 Activity应用表示层 一个活动表示一个可视化的用户界面 Service:没有可见的用户界面，但能够长时间运行于后台 Service(服务)是一个没有用户界面的在后台运行耗时操作的应用组件 Broadcast Receiver:用户接收广播通知的组件 广播接收者仅是接受广播并做出相应的响应 Content Provider:应用程序间数据通信，共享 内容提供者可以将一个应用程序的指定数据集提供给其他应用程序 Activity的生命周期四种状态 在屏幕前台(Activity栈顶)，称为活动状态或者运行状态 如果一个Activity失去焦点，但依然可见，称为暂停状态 如果一个Activity被另外的Activity完全覆盖，称为停止状态 如果Activity是Paused或者Stop状态，系统可以将Activity从内存中删除，Android系统采用两种方式进行删除，要么要求该Activity结束，要么直接“杀掉”它的进程 三个关键的循环 整个的生命周期 可见的生命周期 前台的生命周期 几个方法 onCreate(Bundle icicle) onStart() onRestart() onResume() onPaused() onStop() onDestroy() 静态布局和动态布局所谓静态方法即以XML布局文件来定义用户界面，通过XML布局文件中的相关属性进行控制动态方式是指通过Java代码来开发用户界面，动态的控制界面中的组件 常用控件的公共属性 属性名称 属性值 描述 android:id @+id/&lt;控件 ID&gt; 标识控件ID android:layout_width wrap_content|fill_parent|match_parent 描述当前空间的宽度 android:layout_height wrap_content|fill_parent|match_parent 描述当前空间的高度 android:padding 数值 描述控件内容与空间边框的距离 android:margin 数值 描述控件之间的距离 android:text 字符串 描述控件文本值 List与ArrayAdapterListView arrayListView = findViewById(R.id.arrayList); String[] arr = {&quot;abcd&quot;,&quot;1234&quot;,&quot;算法大&quot;}; arrayListView.setAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,arr)); List与SimpleAdapteradapter_item.xml &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:text=&quot;test&quot; android:id=&quot;@+id/itemView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; SimpleListViewActivity.java ListView listView = findViewById(R.id.simpleAdapterListView); ArrayList&lt;Map&lt;String,String&gt;&gt; values = new ArrayList&lt;&gt;(); String[] item1 = new String[]{&quot;a&quot;,&quot;b&quot;,&quot;C&quot;,&quot;发&quot;}; for(int i = 0;i &lt; item1.length;i++){ Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;,item1[i]); values.add(map); } String[] from = {&quot;key&quot;}; int[] to = {R.id.itemView}; SimpleAdapter adapter = new SimpleAdapter(this,values,R.layout.adapter_item, from,to); listView.setAdapter(adapter); Handler要是Handler就要重写Handler.handleMessage方法 Handler handler = new Handler() { public void handleMessage(Message msg) {} } 然后使用handler.sendEmptyMessage方法或者handler.sendMessage方法传递数据，调用handleMessage方法 Activity显式启动假设有两个Activity，AActivity.java,BActivity.java,要从AActivity跳转到BActivity Intent intent = new Intent(AActivity.this, BActivity.class); startActivity(intent); 隐式启动隐式启动和上述的显式启动不同，Intent不指定要跳转的Class对象，而是指定一个Action，有Android系统来判断要跳转的指定了IntentFilter的对象，可以在不同APP之间跳转 String Action = &quot;&quot;; Intent intent = new Intent(Action); 使用Bundle在Intent之间传递数据在Intent跳转的同时可以使用Intent存储跳转中的数据，可以实现不同组件之间的数据交互 Bundle bundle = new Bundle(); String key = &quot;&quot;; String value = &quot;&quot;; bundle.putString(key, value); Bundle可以使用putString,putInt,putFloat等方法使用键值对应的形式存放数据，然后使用Intent的putExtras方法将Bundle存放 Intent intent = new Intent(AActivity.this, BActivity.class); intent.putExtras(bundle); 同样Intent可以使用getExtras方法获取Bundle Bundle bundle = intent.getExtras(); 然后Bundle使用getXxx方法获取键所对应的数据 String value = bundle.getString(key); Activity的跳转并返回值Activity之间可以使用Context.startActivity方法跳转到其他Activity，也可以使用startActivityForResult方法跳转到其他Activity运行后返回结果 AActivity.java public class AActivity extends Activity { protected void onCreate(Bundle state) { super.onCreate(state); setContextView(R.layout.activity_A); Intent intent = new Intent(AActivity.this, BActivity.class); int requestCode = 1; startActivityForResult(intent, requestCode); } public void onActivityResutl(int requestCode, int resultCode, Intent intent) { //根据requestCode和resultCode确定是哪个Activity返回的 //intent封装了可能需要的数据 } } BActivity.java public class BActivity extends Activity { protected void onCreate(Bundle state) { super.onCreate(state); setContextView(R.layout.activity_B); Intent intent = getIntent(); Bundle bundle = intent.getExtras(); int resultCode = 0; //resultCode 对应AActivity.java中onActivityResult方法的resultCode参数 setResult(resultCode, intent); finish(); } } ServiceService的生命流程context.startService() –&gt; Service.onCreate() –&gt; Service.onStart()/Service.onStartCommand() –&gt; runningcontext.stopService() –&gt; Service.onDestroy() –&gt; Service stop 创建一个Servicepublic class MyService extends Service { public void onCreate(){} public void onStartCommand(Intent intent, int flags, int startId){} public void onDestroy(){} //用于绑定服务时需要的方法，不使用绑定服务时返回null即可 public IBinder onBind(Intent intent){} } 显式启动服务启动一个服务通过Intent和startService方法启动，假设有AActivity.java要启动MyService服务 protected class AActivity extends Activity { public void onCreate(Bundle state) { super.onCreate(state); setContextView(R.layout.activity_A); Intent intent = new Intent(AActivity.this, MyService.class); startService(intent); } } 隐式启动服务要想隐式启动一个服务需要先注册服务在AndroidManifest.xml文件，在&lt;application&gt;标签中修改为 &lt;service android:name = &quot;.MyService&quot; android:exported = &quot;true&quot; android:enabled = &quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name = &quot;com.example.canxing.MyService&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 然后在AActivity.java的onCreate方法使用Intent的隐式跳转 public classt AActivity extends Activity { protected void onCreate(Bundle state) { super.onCreate(state); setContextView(R.layout.Activity_A); Intent intent = new Intent(&quot;com.example.canxing.MyService&quot;); startService(intent); } } BroadcastReceiverBroadcastReceiver属于Android四大组件之一，可以接受其他APP的广播消息 创建一个BroadcastReceiver对象public class MyBroadcastReceiver extends BroadcastReceiver { public void onReceive(Context context, Intent intent){} } 注解BroadcastReceiver对象要让BroadcastReceiver正常工作，需要对其进行注册 静态注册在AndroidManifest.xml文件中进行注册 &lt;receiver android:name = &quot;.MyBroadcastReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name = &quot;com.example.canxing.MyBroadcastReceiver&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 使用静态注册之后，在APP运行时就会接受广播，为了灵活管理推荐使用动态注册 动态注册MyBroadcastReceiver br = new MyBroadcastReceiver(); IntentFilter filter = new IntentFilter(&quot;com.example.canxing.MyBroadcastReceiver&quot;); registerReceiver(br, filter); 取消动态注册 unregisterReceiver(br); 发送广播发送广播也需要使用Intent对象 Intent intent = new Intent(&quot;com.example.canxing.MyBroadcastReceiver&quot;); sendBroadcast(intent); SharedPrefencesSharedPrefences一种Android提供的轻量级存储方案，使用键值对应的方式存储数据，数据存储在文件中 获取文件SharedPrefences sp = getSharedPrefences(filename, mode); mode是打开文件的方式，MODE_PRIVATE表示只允许本应用程序读写MODE_WORLD_READABLE表示别的应用程序读MODE_WORLD_WRITABLE表示别的应用程序写 写数据Editor edit = sp.edit(); edit.putString(key, value); edit.commit(); 读数据Stirng value = sp.getString(key, default); 打开别的应用程序的SharedPrefencesContext context = createPackageContext(&quot;包名&quot;, Context.CONTEXT_IGNORE_SECURITY); SharedPrefences sp = context.getSharedPrefences(name, mode); SQLite数据库SQLite内置在Android系统中的一种轻量级的数据库要使用SQLite数据库首先需要打卡数据，要打开数据库需要实现SQLiteOpenHelper 实现SQLiteOpenHelperpublic class DBHelper extends SQLiterOpenHelper { public DBHelper(Context context, String tablename, int version) { super(context, tablename, null, version); } public void onCreate(SQLiteDatabase db){ String SQL = &quot;create table sutdnet(id varchar primary key, name varchar)&quot;; db.execut(SQL); } public void onUpgrade(SQLiteDatabase db,int oldVersion, int newVersion){} } 打开数据库DBHelper dbHelper = new DBHelper(this, &quot;student&quot;, 1); 只读形式打开SQLiteDatabase db = dbHelper.getReadableDatabase(); 可写形式打开SQLiteDatabase db = dbHelper.getWritableDatabase(); 查询数据Cursor sursor = db.query(false, &quot;student&quot;, new String[]{&quot;id&quot;, &quot;name&quot;}, &quot;&quot;, null, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); SimpleCursorAdapter adapter = new SimpleCursorAdapter(AActivity.this, R.layout.listViewItem, cursor, new Stirng[]{&quot;id&quot;, &quot;name&quot;}, new int[]{R.id.student_id, R.id.student_name}, 0); 这里使用的查询方法是参数最多的查询方法，也是功能最全面的查询方法，一共有9个参数，依次是：是否去重，表名，要查询的列，筛选条件，筛选条件中要填充的数据，分组，分组筛选，排序语句，分页语句然后使用SimpleCursorAdapter将查询的数据封装成Adapter对象，可以填充到ListView中 插入数据ContentValues values = new ContentValues(); String colnum = &quot;&quot;; String value = &quot;&quot;; values.put(colnum, value); int rowId = db.insert(&quot;student&quot;, null, values); insert方法需要借助ContextValue对象，用于表示要插入的列和值，insert方法的第二个参数表示插入数据的列数量少于总的列数量时的默认值 删除数据String selection = &quot;&quot;; String[] selectionArgs = null; int rowId = db.delete(&quot;studnet&quot;, selection, selctionArgs); 更新数据ContentValues values = new ContentValues(); String selection = &quot;&quot;; String[] selectionArgs = null; int rowId = db.update(&quot;student&quot;, values, selection, selectionArgs); ContentProvider和ContentResolverContentProvider可以将某些数据暴露出来供其他应用程序使用，而ContentResolver则是用来获取ContentProvider暴露的数据，ContentProvider和ContentResolver之间使用Uri进行数据交换uri格式 content://&lt;authority&gt;/&lt;words&gt;/&lt;id&gt; 实现ContentProviderpublic class MyContentProvider extends ContentProvider { public boolean onCreate(){} public int insert(Uri uri, ContentValues values){} public int delete(Uri uri, String selection, String[] selectionArgs){} public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs){} public Cursor query(Uri uri, String[] colnums, String selection, String[] selectionArgs, String sortedOrder){} public String getType(Uri uri){} } 注册在AndroidManifest.xml文件进行注册 &lt;provider android:name=&quot;.MyContentProvider&quot; android:authorities = &quot;com.exammle.canxing.MyContentProvider&quot; /&gt; 在java代码中注册 UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); matcher.addURI(&quot;com.example.canxing.MyContentProvider&quot;, &quot;data&quot;, 1); 使用ContentResolver获取ContentProvider暴露的数据ContentResolver resolver = getContentResolver(); Uri uri = Uri.parse(&quot;com.example.canxing.MyContentProvider&quot;) resolver.delete(uri, null, null); AsyncTaskpublic class MyTask extends AsyncTask&lt;String, Integer, String&gt; { protected void onPreExecute(){} protected String onInBackground(String...params){} protected void onPregressUpdate(Integer...params){} protected void onPostExecute(String result){} protected void onCancelled(){} } onPreExecute方法在开始任务之间执行onInBackground方法用于运行任务的主要方法onProgressUpdate方法用于在执行过程中处理onPostExecute方法用于在任务结束时的处理onCancelled用于在任务在使用AsyncTask.cancel(true)时的关闭处理 Http通信HttpURLConnectionAndroid可以通过HttpURLConnection对象进行Http通信，要获取HttpURLConnection对象要通过URL.openConnection对象获得 URL url = new URL(&quot;www.biying.com&quot;); HttpURLConnection urlconn = (HttpURLConnection)url.openConnection(); GET方式通信要使用Http的GET方式进行通信直接使用HttpURLConnection.connect方法就可以了 urlconn.connect(); 判断服务器响应通过HttpURLConnection的getResponseCode方法可以获取服务器响应，然后与HttpURLConnection.HTTP_OK进行比较可以判断响应情况 boolean flag = urlconn.getResponseCode() == HttpURLConnection.HTTP_OK 获取响应数据BufferedReader buffIn = new BufferedReader(new InputStreamReader(urlconn.getInputStream)); 关闭连接urlconn.disconnect(); POST方式通信设置请求方式urlconn.setRequestMethod(&quot;POST&quot;); 设置输入输出方式urlconn.setDoInput(true); urlconn.setDoOoutput(true); 设置不使用缓存urlconn.setUseCaches(false); 设置自动Http重定向urlconn.setinstanceFollowRedirects(true); 设置内容格式urlconn.setRequestProperty(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencodeed&quot;); 输出要提交的数据DataOutputStream out = new DataOutputStream(urlconn.getOutputStream()); String param = &quot;username=&quot; + URLEncode.encode(&quot;ss&quot;, &quot;utf-8&quot;) out.wirteBytes(param); TCPSocket服务器ServerSocket server = new ServerSocket(10000); Socket socket = server.accept(); 客户端Socket socket = new Socket(&quot;127.0.0.1&quot;, 10000); UDP通信服务器DatagramSocket server = new DatagramSocket(10000); byte[] bytes = new byte[1024]; DatagramPacket packet = new DatagramPacket(bytes, bytes.length); server.receive(packet); String result = new String(packet.getData(), packet.getOffset(), packet.getLength()); 客户端DatagramSocket socket = new DatagramSocket(10000); InetAddress address = new InetAddress.getByName(&quot;127.0.0.1&quot;); String message = &quot;&quot;; byte[] bytes = message.getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, 10000); socket.send(packet);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>android-reivew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3-03-字符串]]></title>
    <url>%2F2018%2F04%2F30%2Fpython3-03-string%2F</url>
    <content type="text"><![CDATA[字符串的构造方式python将两个单引号，双引号，三引号（三个连续的单引号或双引号）扩起的内容当作字符串，一些字符串的形式如下： &gt;&gt;&gt; print(&apos;afa1324&apos;) afa1324 &gt;&gt;&gt; print(&quot; fa14319&quot;) fa14319 &gt;&gt;&gt; print(&quot;&quot;&quot;fadsf ... 1341 ... fa&quot;&quot;&quot;) fadsf 1341 fa &gt;&gt;&gt; print(&apos;&apos;&apos;adsf193249 ... fdasj&apos;&apos;&apos;) adsf193249 fdasj 在单引号构造的字符串中可以包含双引号，双引号构造的字符串中可以包含单引号，如果想在单引号或双引号中使用单引号或双引号字符，那么就需要使用转义 转义对于使用单引号构造的字符串中想要使用单引号或者在使用双引号构造的字符串中使用双引号，可以使用反斜杠 \ 对引号进行转义 &gt;&gt;&gt; print(&apos;let\&apos;s go!&apos;) let&apos;s go! 当然也可以在双引号构造的字符串中直接使用单引号 &gt;&gt;&gt; print(&quot;let&apos;s go!&quot;) let&apos;s go! 如果想在字符串中打印反斜杠，可以使用反斜杠来对反斜杠进行转义 &gt;&gt;&gt; print(&apos;a\\b&apos;) a\b 基本操作字符串属于序列的一种，字符串支持所有序列的操作 索引&gt;&gt;&gt; str = &apos;123456789&apos; &gt;&gt;&gt; str[0] &apos;1&apos; &gt;&gt;&gt; str[5] &apos;6&apos; &gt;&gt;&gt; str[-1] &apos;9&apos; &gt;&gt;&gt; str[-8] &apos;2&apos; 字符串可以通过索引获取值，但是不能通过索引来赋值 &gt;&gt;&gt; str[1] = &apos;a&apos; Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: &apos;str&apos; object does not support item assignment 和序列一样，索引超过范围或报错 &gt;&gt;&gt; str[-12] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: string index out of range &gt;&gt;&gt; str[10] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: string index out of range 切片字符串也支持切片操作 &gt;&gt;&gt; str[1:8] &apos;2345678&apos; &gt;&gt;&gt; str[3:-3] &apos;456&apos; &gt;&gt;&gt; str[1:8:2] &apos;2468&apos; 相加两个字符串可以通过加号合成一个新的字符串 &gt;&gt;&gt; str + str1 &apos;123456789abcdefghijklmn&apos; 相乘字符串可以和整数x相乘，将原本字符串的内容复制x份合成一个新的字符串 &gt;&gt;&gt; 7 * str &apos;123456789123456789123456789123456789123456789123456789123456789&apos; 成员资格字符串支持使用运算符in来判断指定字符串是否在字符串中 &gt;&gt;&gt; str &apos;123456789&apos; &gt;&gt;&gt; &apos;a&apos; in str False &gt;&gt;&gt; &apos;1&apos; in str True &gt;&gt;&gt; &apos;123&apos; in str True 字符串方法字符串含有大量的方法这里只给出部分方法 center方法center可以在字符串两边填充字符（默认是空格）使字符串居中 &gt;&gt;&gt; &apos;Tom&apos;.center(10) &apos; Tom &apos; &gt;&gt;&gt; &apos;Tom&apos;.center(10, &apos;-&apos;) &apos;---Tom----&apos; 相似方法：ljust, rjust, zfill &gt;&gt;&gt; &apos;Tom&apos;.ljust(10, &apos;-&apos;) &apos;Tom-------&apos; &gt;&gt;&gt; &apos;Tom&apos;.ljust(1, &apos;-&apos;) &apos;Tom&apos; &gt;&gt;&gt; &apos;Tom&apos;.rjust(10, &apos;-&apos;) &apos;-------Tom&apos; &gt;&gt;&gt; &apos;Tom&apos;.zfill(10) &apos;0000000Tom&apos; &gt;&gt;&gt; &apos;+Tom&apos;.zfill(10) &apos;+000000Tom&apos; find方法find用于在字符串中查找字串，如果找到返回字串的第一个字符索引，否则返回-1，可以指定要查找的范围 &gt;&gt;&gt; a = &apos;tom jerry tom jerry&apos; &gt;&gt;&gt; a.find(&apos;tom&apos;) 0 &gt;&gt;&gt; a.find(&apos;tom&apos;, 1) 10 &gt;&gt;&gt; a.find(&apos;tom&apos;, 1, 4) -1 相似方法：rfind, index, rindex, count, startswith, endswith join方法join用于合并序列元素，序列中的元素只能是字符串 &gt;&gt;&gt; s = &apos;-&apos; &gt;&gt;&gt; a = (&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;) &gt;&gt;&gt; s.join(a) &apos;1-2-3-4-5&apos; &gt;&gt;&gt; s = &apos;+&apos; &gt;&gt;&gt; s.join(a) &apos;1+2+3+4+5&apos; 与join方法相反的方法split用于分割字符串 &gt;&gt;&gt; s &apos;1+2+3+4+5&apos; &gt;&gt;&gt; s.split(&apos;+&apos;) [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;] lower方法lower返回字符串的小写版本 &gt;&gt;&gt; s = s + &apos;ABCDEFG&apos; &gt;&gt;&gt; s &apos;1+2+3+4+5ABCDEFG&apos; &gt;&gt;&gt; s.lower() &apos;1+2+3+4+5abcdefg&apos; 相似方法：upper，title，swapcase，casefold，capitalize判断方法：islower，istitle，isupper，translate replace方法replace将指定字串替换为另一字符串，并返回替换后的结果 &gt;&gt;&gt; s = &apos;tom and jerry&apos; &gt;&gt;&gt; s.replace(&apos;tom&apos;, &apos;ton&apos;) &apos;ton and jerry&apos; strip方法strip将字符串开头和结尾指定的字符删除默认是空白，并返回删除后的结果 &gt;&gt;&gt; s = &apos; abcd efg hijk &apos; &gt;&gt;&gt; s.strip() &apos;abcd efg hijk&apos; &gt;&gt;&gt; s = &apos;*****abcdef jgij********&apos; &gt;&gt;&gt; s.strip(&apos;*&apos;) &apos;abcdef jgij&apos; 相似方法：lstrip，rstrip 判断字符串是否满足某种条件isalnum 检查字符串中的字符是否是字母或数字isalpha 检查字符串中的字符是否是字母isdecima 检查字符串中的字符是否是十进制数isdigit 检查字符串中的字符是否是数字isidentifie 检查字符串中的字符是否可用作Python标识符islower 检查字符串中的字母是否都是小写isnumeri 检查字符串中的字符是否都是数字字符isprintable 检查字符串中的字符是否都是可打印的isspace 检查字符串中的字符是否都是空白字符istitle 检查字符串中的字符位于非字母后面的字母都是大写的，且其他所有字母都是小写的isupper 检查字符串中的字母是否都是大写的 格式化字符串字符串提供一种简单方式可以将动态的值嵌入到字符串中，就像C语言中的printf函数一样，使用占位符占据位置，然后将值填充进去 python2 的格式化字符串&gt;&gt;&gt; s = &apos;hello %s&apos; &gt;&gt;&gt; s % &apos;tom&apos; &apos;hello tom&apos; python2使用和%将指定的格式来占位，然后填充，这里以python3为主，使用新方式格式化字符串，不多展开 python3 的格式化字符串python3使用字符串的format方法来进行格式化，一个简单的格式化字符串如下 &gt;&gt;&gt; s = &apos;hello {}&apos; &gt;&gt;&gt; s.format(&apos;tom&apos;) &apos;hello tom&apos; 在格式化字符串中可以自由选择以下部分组成:字段名:索引或标识符转换标志:跟在叹号(!)后面的单个字符，有r(表示repr)，s(表示str)，a(表示ascii)，默认就好格式说明符:可以详细的指定要最终显示的格式，包括类型，字段宽度，精度，各种对齐方式等]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3-02-列表和元组]]></title>
    <url>%2F2018%2F04%2F29%2Fpython3-02-ListAndTuple%2F</url>
    <content type="text"><![CDATA[列表和元组 在python中最基本的数据结构是序列，列表属于序列的一种，还有如字符串和元组也是序列，列表是修改的，元组是不可修改的将元素放在放括号内，并有逗号隔开的类型是列表，元组使用元括号 一些列表的形式： [] 空列表 [1, 2, 3, 4, 5, 6, 7, 8, 9] 只包含数字的列表 [‘a’, ‘b’, ‘c’, ‘d’] 包含字符串的列表 [1, 2, 3, ‘a’, ‘b’, ‘c’] 既有数字也有字符串的列表 [1, 2, 3, [‘a’, ‘b’, ‘c’], 4, ‘5’] 包含数字，列表，字符串的列表 序列中可以包含任何类型的对象，可以是数字，字符串，元组，列表等任意类型 通用序列操作（可以适用于所有序列的操作包括元组，字符串）索引序列中的所有元素都有编号，从左到右从0开始递增，从右到左从-1开始递减，可以通过编号来访问序列中的各个元素 &gt;&gt;&gt; a = [1, 2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 4, &apos;5&apos;] &gt;&gt;&gt; a [1, 2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 4, &apos;5&apos;] 可以通过a[0]来访问列表中的第一个元素，也可以通过a[-6]来访问 &gt;&gt;&gt; a[0] 1 &gt;&gt;&gt; a[-6] 1 对于元素’b’，可以通过a[3][1]来访问 &gt;&gt;&gt; a[3][1] &apos;b&apos; 当索引超过列表的访问范围时会报错 &gt;&gt;&gt; a[10] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range 切片可以通过两个索引来访问特定范围内的元素 &gt;&gt;&gt; a = [1, 2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 4, &apos;5&apos;] &gt;&gt;&gt; a[1:4] [2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]] &gt;&gt;&gt; a[-5:-2] [2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]] a[1:4]将返回 [2, 3, [‘a’, ‘b’, ‘c’]]返回范围为’左闭右开’，可以访问起始索引的元素，却只能访问到结束索引之前的元素也可以使用a[-5:-2]来达到a[1:4]相同的结果 简写只访问前三个元素 &gt;&gt;&gt; a[:3] [1, 2, 3] 如果切片没有给起始索引，那么默认起始索引为0 只访问最后三个元素 &gt;&gt;&gt; a[-3:] [[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 4, &apos;5&apos;] 如果切片的结束索引没有指定，那么默认结束索引为-1 起始索引大于结束索引时 &gt;&gt;&gt; a[-3:-4] [] 当起始索引指定的元素为终止索引指定的元素后面，那么返回一个空列表 复制整个序列 &gt;&gt;&gt; a[:] [1, 2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 4, &apos;5&apos;] 当起始索引和终止索引都没有指定时，会复制整个序列 步长切片不仅能访问特定范围的元素，还可以访问指定范围内指定间隔的元素 &gt;&gt;&gt; a[1:5:2] [2, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]] 表示从起始索引1开始，依次访问间隔1个元素的元素，直到终止索引，如果不指定，默认步长为1，依次访问间隔为0个的元素 步长可以为负数，当步长为负数时，表示索引位置是由右到左移动的 &gt;&gt;&gt; a[-1:0:-2] [&apos;5&apos;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 2] 序列相加序列支持加法算术运算符，可以通过’+’来生成一个新的序列 &gt;&gt;&gt; c = [1, 2, 3, 4,] &gt;&gt;&gt; d = [5, 6, 7, 8] &gt;&gt;&gt; c [1, 2, 3, 4] &gt;&gt;&gt; c + d [1, 2, 3, 4, 5, 6, 7, 8] &gt;&gt;&gt; e = c + d &gt;&gt;&gt; e [1, 2, 3, 4, 5, 6, 7, 8] 通过’+’运算符生成的序列是一个新的序列，改变原来的序列，新序列不会改变 &gt;&gt;&gt; c [0] = 10 &gt;&gt;&gt; e [1, 2, 3, 4, 5, 6, 7, 8] &gt;&gt;&gt; c [10, 2, 3, 4] 不同类型的序列不能使用’+’运算符 &gt;&gt;&gt; c + (1, 2, 3, 4) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: can only concatenate list (not &quot;tuple&quot;) to list 乘法序列支持乘法运算符，当序列和一个数x相乘时，会重复这个序列x次来创建一个序列 &gt;&gt;&gt; a = [1] &gt;&gt;&gt; a * 10 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] 通过序列的这个性质可以用来初始化序列，如上面的表达式就初始化了一个元素为1，容量为10的列表 生成一个二维序列for循环&gt;&gt;&gt; a = [] &gt;&gt;&gt; for i in range(5): ... a.append([None] * 4) ... &gt;&gt;&gt; a [[None, None, None, None], [None, None, None, None], [None, None, None, None], [None, None, None, None], [None, None, None, None]] 列表推导式&gt;&gt;&gt; a = [] &gt;&gt;&gt; a = [[None] * 4 for i in range(5)] &gt;&gt;&gt; a [[None, None, None, None], [None, None, None, None], [None, None, None, None], [None, None, None, None], [None, None, None, None]] 成员资格要检查特定的值是否包含在序列中，可以使用运算符in &gt;&gt;&gt; users = [&apos;mih&apos;, &apos;foo&apos;, &apos;bar&apos;] &gt;&gt;&gt; &apos;mih&apos; in users True &gt;&gt;&gt; &apos;tom&apos; in users False &gt;&gt;&gt; &apos;foo&apos; in users True 当序列中有这个元素时返回True，否则返回False 列表操作函数listlist函数可以将其他序列转换为列表 &gt;&gt;&gt; list((1, 2, 3, 4)) [1, 2, 3, 4] &gt;&gt;&gt; list(&apos;abcdefg&apos;) [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;] 基本操作给列表赋值&gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; a[0] = 10 &gt;&gt;&gt; a [10, 2, 3, 4, 5] 删除元素通过del语句可以删除列表中元素 &gt;&gt;&gt; a [10, 2, 3, 4, 5] &gt;&gt;&gt; del a[2] &gt;&gt;&gt; a [10, 2, 4, 5] 给切片赋值&gt;&gt;&gt; a [10, 2, 4, 5] &gt;&gt;&gt; a[2:] = [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; a [10, 2, 1, 2, 3, 4, 5, 6] 通过这种方式也可以删除元素 &gt;&gt;&gt; a[2:3] = [] &gt;&gt;&gt; a [10, 2, 2, 3, 4, 5, 6] 切片范围内元素替换为一个空列表可以达到删除的效果当然也可以使用这种方式清空整个列表 &gt;&gt;&gt; a[:] = [] &gt;&gt;&gt; a [] 列表方法python中列表是一种对象，拥有方法 append方法append将一个对象附加到列表末尾 &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; a [1, 2, 3, 4, 5] &gt;&gt;&gt; a.append(80) &gt;&gt;&gt; a [1, 2, 3, 4, 5, 80] 可以使用’+’运算符实现 &gt;&gt;&gt; a + [80] [1, 2, 3, 4, 5, 80, 80] clear方法clear清空整个列表 &gt;&gt;&gt; a.clear() &gt;&gt;&gt; a [] 使用切片清空列表 &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; a [1, 2, 3, 4, 5] &gt;&gt;&gt; a[:] = [] &gt;&gt;&gt; a [] copy方法copy复制列表，复制出的列表是一个新的列表对象，修改新列表不会改变原来列表的值 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = a.copy() &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; b[1] = 4 &gt;&gt;&gt; b [1, 4, 3] &gt;&gt;&gt; a [1, 2, 3] 使用a[:]和list(a)也可以达到相同的效果 &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b [1, 2, 3] &gt;&gt;&gt; b = list(a) &gt;&gt;&gt; b [1, 2, 3] count方法count统计指定元素在列表中出现的多少次 &gt;&gt;&gt; a = [1, 2, 3, 2, 4, 2, 5, 2] &gt;&gt;&gt; a [1, 2, 3, 2, 4, 2, 5, 2] &gt;&gt;&gt; a.count(2) 4 extend方法extend可以同时将序列附加到列表末尾，是append的加强版 &gt;&gt;&gt; b = (1, 2, 3, 4, 5) &gt;&gt;&gt; a.extend(b) &gt;&gt;&gt; a [1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 4, 5] 使用切片和’+’运算符也可以实现效果‘+’运算符可以将两个列表拼接成一个列表，但是无法将一个列表和一个元组拼接 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = [4, 5, 6] &gt;&gt;&gt; a = a + b &gt;&gt;&gt; a [1, 2, 3, 4, 5, 6] 切片 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = [4, 5, 6] &gt;&gt;&gt; a[len(a):] = b &gt;&gt;&gt; a [1, 2, 3, 4, 5, 6] index方法index放回指定元素在列表中第一次出现的索引，如果列表中没有指定元素会报错 &gt;&gt;&gt; a = [&apos;We&apos;, &apos;are&apos;, &apos;the&apos;, &apos;knights&apos;, &apos;who&apos;, &apos;say&apos;, &apos;ni&apos;] &gt;&gt;&gt; a.index(&apos;who&apos;) 4 &gt;&gt;&gt; a.index(&apos;herring&apos;) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: &apos;herring&apos; is not in list insert方法insert将一个对象插入列表中指定位置 &gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] &gt;&gt;&gt; a.insert(3, &apos;four&apos;) &gt;&gt;&gt; a [1, 2, 3, &apos;four&apos;, 4, 5, 6, 7, 8, 9, 10] 使用切片也可以达到相同效果 &gt;&gt;&gt; a[3:3] = [&apos;four&apos;] &gt;&gt;&gt; a [1, 2, 3, &apos;four&apos;, &apos;four&apos;, 4, 5, 6, 7, 8, 9, 10] pop方法pop用于弹出并返回列表中最后一个元素，当列表为空时抛出异常 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; a.pop() 3 &gt;&gt;&gt; a.pop() 2 &gt;&gt;&gt; a.pop() 1 &gt;&gt;&gt; a [] &gt;&gt;&gt; a.pop() Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: pop from empty list remove方法remove用于删除列表中第一次出现的指定元素，如果列表中没有指定元素，抛出异常 &gt;&gt;&gt; a = [1, 2, 3, 1, 2, 3] &gt;&gt;&gt; a.remove(1) &gt;&gt;&gt; a [2, 3, 1, 2, 3] &gt;&gt;&gt; a.remove(1) &gt;&gt;&gt; a [2, 3, 2, 3] &gt;&gt;&gt; a.remove(1) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: list.remove(x): x not in list sort方法sort用于对列表中元素进行排序 &gt;&gt;&gt; a = [3, 5, 2, 1, 7, 8, 6, 10] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a [1, 2, 3, 5, 6, 7, 8, 10] sort方法有两个参数key表示用于排序的函数reverse为bool值，默认为False，表示是否要逆序排列 元组tuple一些简单的元组() 表示空元组1, 2, 3 表示元组(1, 2, 3)32, 表示元组(32)tuple([1, 2, 3]) 表示元组(1, 2, 3)元组由于不可变性，不能增加，删除，修改，只支持有限的操作]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3-01-数]]></title>
    <url>%2F2018%2F04%2F29%2Fpython3-01-number%2F</url>
    <content type="text"><![CDATA[python中有两种数字：整数和浮点数，他们遵循同样的计算方式，拥有相同的算数运算符 赋值在python中可以将变量和特定的值关联起来，然后通过变量名来访问值，这就是赋值形如：a = 123b = 23.42c = 341d = a之类的使用 ‘=’ 号将左边变量和右边值相连接的表达式 算数运算符+ 加法&gt;&gt;&gt; 10 + 10 20 &gt;&gt;&gt; 10 + 12.2 22.2 &gt;&gt;&gt; 10 + -132.2 -122.19999999999999 &gt;&gt;&gt; 23.0 + 2.2 25.2 - 减法&gt;&gt;&gt; 10 - 1 9 &gt;&gt;&gt; 10 -1.20 8.8 &gt;&gt;&gt; 1.2 - 123 -121.8 &gt;&gt;&gt; 10.2 - 1.2 9.0 * 乘法&gt;&gt;&gt; 10 * 2 20 &gt;&gt;&gt; 10 * 2.3 23.0 &gt;&gt;&gt; 2.8 * 10 28.0 &gt;&gt;&gt; 2.3 * 2.1 4.83 / 除法&gt;&gt;&gt; 10 / 2 5.0 &gt;&gt;&gt; 10 / 2.5 4.0 &gt;&gt;&gt; 223.2 /2 111.6 &gt;&gt;&gt; 12.2 / 1.1 11.09090909090909 % 求余求余在结果为负时难以理解，求余结果遵循如下方式结算先计算整除，用整除结果乘上被除数得出一个值，如果除数和值符号相同，除数减去值的结果作为求余数，否则除数加上值的结果作为求余数，例：求 -20 % 3 的值，先计算整除数为-7，然后将-7 * 3得出-21，再用-20 - (-21) 得出求余数1 &gt;&gt;&gt; 10 % 3 1 &gt;&gt;&gt; 10 % -3 -2 &gt;&gt;&gt; -10 % 3 2 &gt;&gt;&gt; 10.2 % 3 1.1999999999999993 &gt;&gt;&gt; -10.2 % 3 1.8000000000000007 &gt;&gt;&gt; 10.2 % -3 -1.8000000000000007 // 整除整除运算可以将运算的结果向下取整，如果运算结果为3.2,整除结果为3,运算结果为-2.3，那么整除结果为-3，正数和负数的结果有差别 &gt;&gt;&gt; 1 // 2 0 &gt;&gt;&gt; 1 // 1 1 &gt;&gt;&gt; 5.0 // 2.5 2.0 &gt;&gt;&gt; 20 // -3 -7 &gt;&gt;&gt; -20 // 3 -7 ** 求幂&gt;&gt;&gt; 2 ** 3 8 &gt;&gt;&gt; 2 ** 2.3 4.924577653379664 &gt;&gt;&gt; 2.1 ** 2 4.41 &gt;&gt;&gt; 2.2 ** 2.1 5.23706096672078 在以上运算中，除除法以外，参与运算的数都是整数，那么运算结果为整数，如果参数运算的至少有一个浮点数，那么运算结果为浮点数，除法运算的结果只能是浮点数 其他数字除了上述的表示方式数字还有以下形式 十六进制数 0xAF 八进制数 0o10 二进制数 0b100112]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA社区版使用maven搭建web开发环境]]></title>
    <url>%2F2018%2F04%2F17%2FIntelljJ-IDEA-Community-Edition-maven-webapp%2F</url>
    <content type="text"><![CDATA[IDEA社区版是不支持web应用程序开发，但是IDEA支持Maven，在Maven配置文件中可以添加tomcat插件，因此可以使用IDEA进行web应用程序开发 一 新建Maven项目在选择新项目时选择maven项目，勾选 Create from archetype，在下方选择maven-archetype-webapp，点击Next 输入GroupId和ArtifactId 选择Maven位置，如果Maven已经添加到环境变量，那么可以自动找到，如果没有配置，那么需要手动添加User setting file为你的Maven配置文件，如果不是默认路径需要手动添加Local repository为你的Maven仓库，如果不是默认路径需要手动添加 最后输入工程名称和工程位置 首次使用Maven会下载一些东西需要一些时间 二 配置tomcat 首先在tomcat中添加tomcat插件 &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;hostName&gt;localhost&lt;/hostName&gt; &lt;!-- Default: localhost --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 启动端口 Default:8080 --&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;!-- uri编码 Default: ISO-8859-1 --&gt; &lt;/configuration&gt; 这里使用的tomcat7 配置tomcat7 单击菜单栏 Run，选择Edit Configurations…，进入如下界面 默认只有一个Defaults，Maven是我配置好了的 选择+-&gt;Maven输入Tomcat7，在Command line输入tomcat7:run完成配置 点击Run开始运行，打开浏览器查看结果如下]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述九-插入排序和希尔排序]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B9%9D-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序插入排序基于这样一种情况，待插入的数组是顺序的(升序或降序)，此时将插入数据从数组从后向前比较，满足条件就插入，不满足就依次向后移动 插入排序就好象玩扑克时一张一张的拿牌，大的在左边，小的在右边，每拿一张牌就从右到左一次比较，在第一张大于的牌的右边插入新的扑克 插入算法typedef int ElementType; void insertSort(ElementType* array,int len){ int arrayMaxIndex = len - 1; int arrayMinIndex = 0; int index = 0; int j = 0; for(index = arrayMinIndex + 1;index &lt;= arrayMaxIndex;index++){ int insertValue = array[index]; for(j = index - 1;j &gt;= 0 &amp;&amp; array[j] &gt; insertValue;j--){ array[j + 1] = array[j]; } array[j + 1] = insertValue; } } 希尔排序希尔排序通过比较相距一定间隔的元素来工作，将比较的元素按照大小排列到比较元素的位置，然后通过减小间隔再次比较，最后间隔为1时所有比较完成 最上面数据为未排序数据，由上往下增量依次为5,3,1 希尔排序算法typedef int ElementType; void shellSort(ElementType* array,int increment,int len){ int arrayMinIndex = 0; int arrayMaxIndex = len - 1; int sortTime = 0; int j = 0; int insertValue = 0; //当一趟的增量大于排序数组长度时进行的处理 if(increment &gt; len){ shellSort(array,1,len); } for(;sortTime &lt; increment;sortTime++){ //插入排序的变形 for(int i = sortTime + increment;i &lt; len;i += increment){ insertValue = array[i]; for(j = i - increment;j &gt;= arrayMinIndex &amp;&amp; array[j] &gt;= insertValue;j -= increment){ array[j + increment] = array[j]; } array[j + increment] = insertValue; } } } 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述八-再散列]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AB-%E5%86%8D%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么是再散列再散列也是散列表的一种，不同的是再散列可以动态的扩充表长，再搭配好的散列函数解决冲突 再散列在散列表到达某一临界点时扩充原来表长的容量，再将原来散列表中的数据重新散列移动到新的散列表的过程 类型声明typedef unsigned int Index; typedef Index Position; struct HashTbl; typedef struct HashTbl* HashTable; typedef int ElementType; HashTable InitializeTable(int TableSize,float Facotr); void DestroyTable(HashTable H); Position Find(ElementType key,HashTable H); HashTable Insert(ElementType key,HashTable H); void Delete(ElementType key,HashTable H); HashTable Rehash(HashTable H); static Index Hash(const int key,int TableSize); enum KindOfEntry{Legitimate,Emtry,Deleted}; struct HashEntry{ ElementType Element; enum KindOfEntry Info; }; typedef struct HashEntry Cell; struct HashTbl{ int TableSize; int Capacity; float LocalFacotr;//装填因子 int MaxCapacity;//散列表所能容纳的最大容量，超过该容量后就要扩容 Cell* TheCells; }; 这里采用当散列表容量达到指定的装填因子时进行再散列，采用的默认散列因子是0.75，TableSize表示散列表的长度，Capacity表示散列表容乃数据的大小，MaxCapacity表示散列表可以容纳的最大容量，由TableSize × LocalFacotr得出 散列表的插入HashTable Insert(ElementType key,HashTable H){ if(H == NULL) return NULL ; if(H-&gt;Capacity &gt;= H-&gt;MaxCapacity){ H = Rehash(H); } int index = Hash(key,H-&gt;TableSize); //如果已经在相同下标的散列表上有值，那就不管了 if(H-&gt;TheCells[index].Info != Emtry){ return H; } H-&gt;Capacity++; H-&gt;TheCells[index].Element = key; H-&gt;TheCells[index].Info = Legitimate; return H; } 当散列表的容量超过最大容量是就要使用再散列方法 HashTable Rehash(HashTable H){ if(H == NULL) return NULL; HashTable T = InitializeTable(H-&gt;TableSize &lt;&lt; 1,H-&gt;LocalFacotr); for(int i = 0;i &lt; H-&gt;TableSize;i++){ if(H-&gt;TheCells[i].Element != 0) Insert(H-&gt;TheCells[i].Element,T); } DestroyTable(H); return T; } 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述七-开放定址散列表]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%83-%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是开放定址法开放定址法是另一种不用链表解决散列表冲突问题的方法，在开放定址散列算法系统中，如果发生冲突，那么就要尝试选择另外的单元，直到找出空的单元为止 冲突解决的方法 线性探测法 平方探测法 双散列 这里使用平方探测法进行示例，平方探测法在第一次冲突时将第一次哈希值的结果加上F(i)，如果还是冲突，那么i加1,再次使用第一次哈希值加上F(i)以此循环;F(i) = i * i(i = 1) 类型声明typedef unsigned int Index; typedef Index Position; struct HashTbl; typedef struct HashTbl* HashTable; typedef int ElementType; HashTable InitializeTable(int TableSize); void DestroyTable(HashTable H); Position Find(ElementType key,HashTable H); HashTable Insert(ElementType key,HashTable H); static Index Hash(const int key,int TableSize); enum KindOfEntry{Legitimate,Empty,Deleted}; struct HashEntry{ ElementType Element; enum KindOfEntry Info; }; typedef struct HashEntry Cell; struct HashTbl{ int TableSize; int Capacity; Cell* TheCells; }; 在哈希表中，保存有哈希表的表长，当前表的容量，以及存储单元，每个存储单元保存实际存储的值，以及存储单元的信息，包括已经存储，没有存储和原来有存储现在被删除三种信息 哈希表的插入HashTable Insert(ElementType key,HashTable H){ if(H == NULL) return NULL ; int index = Hash(key,H-&gt;TableSize); int number = 0; //检查表容量 if(H-&gt;Capacity &gt;= H-&gt;TableSize) { return H; } //查找可以可以插入的点 while(H-&gt;TheCells[index].Info == Legitimate){ index = index + 2 * (++number) + 1; if(index &gt;= H-&gt;TableSize) index = index - H-&gt;TableSize; } //插入数据，重置单元信息，表容量加1 H-&gt;TheCells[index].Element = key; H-&gt;TheCells[index].Info = Legitimate; H-&gt;Capacity++; return H; } 哈希表的查找查找操作也是和插入操作差不多的，不同的是如果查找的单元为空，则说明查找不成功 Position Find(ElementType key,HashTable H){ if(H == 0) return -1; int index = Hash(key,H-&gt;TableSize); int number = 0; while(1){ if(H-&gt;TheCells[index].Info == Empty){ return -1; } if(H-&gt;TheCells[index].Element == key) return index; index += 2 * (++number) + 1; if(index &gt;= H-&gt;TableSize) index = index - H-&gt;TableSize; } return -1; } 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述六-分离链接散列表]]></title>
    <url>%2F2018%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AD-%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是分离链接散列表分离链接散列表是散列表解决冲突的一种方法，其做法是将散列到同一个值的所有元素保留到一个表中。为方便起见，这些表都有表头 分离链接散列表的定义 struct ListNode; typedef struct ListNode* Position; struct HashTbl; typedef struct HashTbl* HashTable; typedef int ElementType; HashTable InitializeTable(int TableSize); void DestroyTable(HashTable H); Position Find(ElementType key,HashTable H); void Insert(ElementType key,HashTable H); ElementType Retrieve(Position P); static int Hash(const int key,int TableSize); struct ListNode{ ElementType Element; Position Next; }; typedef Position List; struct HashTbl{ int TableSize; List* TheList; }; 分离链接散列表的初始化分离链接散列表在数组的每个位置保存有冲突元素组成链表的表头 HashTable InitializeTable(int TableSize){ HashTable H = NULL; H = (HashTable)malloc(sizeof(struct HashTbl)); if(H == NULL) return NULL; H-&gt;TableSize = TableSize; H-&gt;TheList = (List*)malloc(sizeof(struct ListNode) * TableSize); for(int i = 0;i &lt; TableSize;i++){ H-&gt;TheList[i] = (List)malloc(sizeof(struct ListNode)); H-&gt;TheList[i]-&gt;Next = NULL; } return H; } 分离链接散列表的插入插入时先计算Hash值，然后将值作为对应表头的第一个元素，这里就相当与链表的头插法 void Insert(ElementType key,HashTable H){ if(H == NULL) return ; int index = Hash(key,H-&gt;TableSize); Position ptr = H-&gt;TheList[index]; Position temp = (List)malloc(sizeof(struct ListNode)); if(temp == NULL) return ; temp-&gt;Element = key; temp-&gt;Next = ptr-&gt;Next; ptr-&gt;Next = temp; } 分离链接散列表的查找查找时首先计算要查找值的Hash值，然后返回对应的表头，遍历链表，找到就返回 Position Find(ElementType key,HashTable H){ if(H == NULL) return NULL; int index = Hash(key,H-&gt;TableSize); Position ptr = H-&gt;TheList[index]; ptr = ptr-&gt;Next; while(ptr != NULL){ if(ptr-&gt;Element == key) return ptr; ptr = ptr-&gt;Next; } return NULL; } 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述五-伸展树]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%94-%E4%BC%B8%E5%B1%95%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是伸展树伸展树保证了从空树开始任意连续M次对树的操作最多话费O(M log N)时间，伸展树是二叉搜索树的一种变形，不同于AVL树，伸展树不需要维护节点的高度，相对AVL树来说比较容易实现 当一个节点被访问时它就有可能在不久之后被再次访问，因此，伸展树的基本思想是：当一个节点被访问，它就经过一系列AVL树的旋转操作将该节点放到根上 将某个节点经过一系列的变形移动到树根上的操作称之为伸展(Splay)，伸展操作主要进行六个形态的转变，再将伸展节点伸展之后会再次检查伸展节点的位置，如果伸展节点是根结点则返回，否则继续伸展 伸展树声明SplayTree MakeEmpty(SplayTree T); Position Find(ElementType X,SplayTree T); Position FindMin(SplayTree T); Position FindMax(SplayTree T); SplayTree Insert(ElementType X,SplayTree T); SplayTree Delete(ElementType X,SplayTree T); ElementType Retrieve(Position P); Position FindPositionUp(SplayTree T,ElementType X); void printTree(SplayTree T); static Position SingleRotaleWithLeft(Position T); static Position SingleRotaleWithRight(Position T); static Position ContinuRotaleWithLeft(Position T); static Position ContinuRotaleWithRight(Position T); static Position DoubleRotaleWithLeft(Position T); static Position DoubleRotaleWithRight(Position T); static Position Splay(ElementType X,SplayTree T); struct TreeNode{ ElementType Element; SplayTree Left; SplayTree Right; }; 伸展功能伸展功能依赖于6个函数分别时左旋转，右旋转，连续左旋转，连续右旋转，左双旋转，右双旋转，分别对应6中变形 //左旋转 static Position SingleRotaleWithLeft(Position T){ Position ptr = T-&gt;Left; T-&gt;Left = ptr-&gt;Right; ptr-&gt;Right = T; return ptr; } //右旋转 static Position SingleRotaleWithRight(Position T){ Position ptr = T-&gt;Right; T-&gt;Right = ptr-&gt;Left; ptr-&gt;Left = T; return ptr; } //连续左旋转 static Position ContinuRotaleWithLeft(Position T){ Position ptr = SingleRotaleWithLeft(T); return SingleRotaleWithLeft(ptr); } //左双旋转 static Position DoubleRotaleWithLeft(Position T){ T-&gt;Right = SingleRotaleWithLeft(T-&gt;Right); return SingleRotaleWithRight(T); } //连续右旋转 static Position ContinuRotaleWithRight(Position T){ Position ptr = SingleRotaleWithRight(T); return SingleRotaleWithRight(ptr); } //右双旋转 static Position DoubleRotaleWithRight(Position T){ T-&gt;Left = SingleRotaleWithRight(T-&gt;Left); return SingleRotaleWithLeft(T); } 伸展树的伸展流程如下: 伸展节点为根节点，不做任何改变，并返回 伸展节点是根结点的左儿子，将伸展节点向左旋转 伸展节点是根结点的右儿子，将伸展节点向左旋转 伸展节点不属于上述三种情况，将伸展节点称为X,X的父结点称为F，F的父结点称为G，G节点就是X节点的’祖父’节点 4.1. 如果G的左儿子是F，并且F的左儿子是X，进行连续左旋转 4.2. 如果G的右儿子是F，并且F的右儿子是X，进行连续右旋转 4.3. 如果G的左儿子是F，并且F的右儿子是X，进行左双旋转 4.4. 如果G的右儿子是F，并且F的左儿子是X，进行有双旋转 static Position Splay(ElementType X,SplayTree T){ if(T == NULL || T-&gt;Element == X) return T; //查找伸展节点的父结点 Position fatherNode = FindPositionUp(T,X); if(fatherNode == T){ if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X){ //伸展节点属于根结点的左儿子 return SingleRotaleWithLeft(fatherNode); }else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X){ //伸展节点属于根结点的右儿子 return SingleRotaleWithRight(fatherNode); } }else{ Position grandNode = FindPositionUp(T,fatherNode-&gt;Element); Position grandGrandNode = FindPositionUp(T,grandNode-&gt;Element); Position temp = NULL; int level = -1; //判断伸展节点，父结点和祖父节点的关系 if(grandNode-&gt;Left != NULL &amp;&amp; grandNode-&gt;Left == fatherNode){ if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X){ level = 1; }else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X){ level = 2; } }else if(grandNode-&gt;Right != NULL &amp;&amp; grandNode-&gt;Right == fatherNode){ if(fatherNode-&gt;Left != NULL &amp;&amp; fatherNode-&gt;Left-&gt;Element == X){ level = 3; }else if(fatherNode-&gt;Right != NULL &amp;&amp; fatherNode-&gt;Right-&gt;Element == X){ level = 4; } } switch(level){ case 1://左左 temp = ContinuRotaleWithLeft(grandNode); break; case 2://左右 temp = DoubleRotaleWithRight(grandNode); break; case 3://右左 temp = DoubleRotaleWithLeft(grandNode); break; case 4://右右 temp = ContinuRotaleWithRight(grandNode); break; } if(grandNode == T) return temp; else if(grandGrandNode-&gt;Left == grandNode) grandGrandNode-&gt;Left = temp; else if(grandGrandNode-&gt;Right == grandNode) grandGrandNode-&gt;Right = temp; return Splay(X,T); } } 查询操作查询操作先要确定树中含有要查询的节点，如果没有则直接返回，否则将查询到的节点进行伸展移动到根结点然后返回 Position Find(ElementType X,SplayTree T){ if(T-&gt;Element == X) return T; Position dst = T; while(dst != NULL &amp;&amp; X != dst-&gt;Element){ if(X &lt; dst-&gt;Element) dst = dst-&gt;Left; else if(X &gt; dst-&gt;Element) dst = dst-&gt;Right; } if(dst != NULL) return Splay(X,T); return T; } 插入操作插入操作先将元素按照二叉搜索树的性质插入树中，然后在将插入的节点伸展到根结点 SplayTree Insert(ElementType X,SplayTree T){ Position temp = NULL; temp = (SplayTree)malloc(sizeof(struct TreeNode)); if(temp == NULL){ printf(&quot;初始化树失败\n&quot;); return NULL; } temp-&gt;Element = X; temp-&gt;Left = temp-&gt;Right = NULL; if(T == NULL){ T = temp; return T; } Position ptr = T; //按照二叉搜索树的性质插入节点 while(1){ if(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left != NULL){ ptr = ptr-&gt;Left; }else if(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right != NULL){ ptr = ptr-&gt;Right; }else if(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left == NULL){ ptr-&gt;Left = temp; break; }else if(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right == NULL){ ptr-&gt;Right = temp; break; } } return Splay(X,T); } 删除操作删除操作先将删除节点伸展到根结点，此时，根结点的左子树元素都小于根节点，右子树元素都大于根结点，删除根结点，然后将左子树的最大元素进行伸展，此时左子树根结点是左子树中的最大元素，没有右儿子，然后再将左子树的右指针指向右子树，删除完成 SplayTree Delete(ElementType X,SplayTree T){ if(T == NULL) return NULL; if(X == T-&gt;Element){ if(T-&gt;Left == NULL) return T-&gt;Right; else if(T-&gt;Right == NULL) return T-&gt;Left; //再查找最大元素的同时就对最大元素进行了伸展操作 Position left = FindMax(T-&gt;Left); left-&gt;Right = T-&gt;Right; free(T); return left; } T = Splay(X,T); return Delete(X,T); } 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述四-AVL树]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%9B%9B-AVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[AVL树是带有平衡条件的二叉查找树，所谓平衡条件就是:任何节点的深度均不得过深，如下图所示的二叉查找树是不应该出现的一颗AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树（空树的高度定义为-1），这是一颗AVL树，树的高度为3 AVL树的定义//头文件中的函数定义 struct AvlNode; typedef struct AvlNode* Position; typedef struct AvlNode* AvlTree; typedef int ElementType ; AvlTree MakeEmpty(AvlTree T); Position Find(ElementType X,AvlTree T); Position FindMin(AvlTree T); Position FindMax(AvlTree T); AvlTree Insert(ElementType X,AvlTree T); AvlTree Delete(ElementType X,AvlTree T); ElementType Retrieve(Position P); //具体实现文件中的树节点定义，这里的树节点元素使用int类型 struct AvlNode{ ElementType Element; AvlTree Left; AvlTree Right; int Height; }; 可以看见，AVL树和二叉查找树的定义没有什么区别，在节点定义上多了一个变量用来存储树的高度 AVL树的实现AVL树的不同主要体现在插入和删除时的不同，在插入和删除时都有可能破坏AVL树的平衡，此时就需要对AVL树进行平衡修复 AVL树的插入实现图摘自维基百科进行插入操作时，有四种情况可能破坏AVL树的平衡，我们把被破坏的平衡的节点称为root 1. 对root左儿子的左子树进行一次插入，对应上图的左左情况 2. 对root右儿子的右子树进行一次插入，对应上图的右右情况 3. 对root左儿子的右子树进行一次插入，对应上图的左右情况 4. 对root右儿子的左子树进行一次哈入，对应上图的右左情况 对于1，2情况，插入节点相对于root节点的&apos;外侧&apos;，这时只需要对root节点和root节点的左儿子或者右儿子进行一次右旋转或者左旋转就可以了;3，4情况相对于root节点的&apos;内侧&apos;，这是需要实行两次的旋转达到平衡 注意，无论是一次旋转还是两次旋转，都是为了满足二叉查找树的性质和平衡条件 下图演示了依次将3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9插入AVL树的过程，带箭头的表示插入时使用了旋转操作 上图演示了从1到7顺序插入AVL树的过程，这里都是1和2的情况 插入代码实现AvlTree Insert(ElementType X,AvlTree T){ if(T == NULL){ T = (AvlTree)malloc(sizeof(struct AvlNode)); if(T == NULL) return NULL; T-&gt;Left = T-&gt;Right = NULL; T-&gt;Element = X; T-&gt;Height = 0; }else{ if(X &gt; T-&gt;Element){ T-&gt;Right = Insert(X,T-&gt;Right); if(Height(T-&gt;Right) - Height(T-&gt;Left) == 2) if(X &gt; T-&gt;Right-&gt;Element) T = SingleRotaleWithRight(T); else T = DoubleRotaleWithRight(T); }else{ T-&gt;Left = Insert(X,T-&gt;Left); if(Height(T-&gt;Left) - Height(T-&gt;Right) == 2) if(X &lt; T-&gt;Left-&gt;Element) T = SingleRotaleWithLeft(T); else T = DoubleRotaleWithLeft(T); } } T-&gt;Height = max(Height(T-&gt;Left),Height(T-&gt;Right)) + 1; return T; } AVL树的删除实现AVL树的删除实现比起插入实现要复杂基本想法是删除成功时，修正删除路径上节点高度，然后判断删除路径上的节点的平衡，然后进行旋转删除失败时，不改变任何东西 由于删除功能是按照本人自己的想法实现，实现过程较长，这里不进行展示，如有兴趣可以查看参考源码 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述三-二叉查找树]]></title>
    <url>%2F2018%2F03%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%89-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树是二叉树的特殊形式，主要性质是，对于树中的每个节点X，它的左子树中所有值小于X的值，而它的右子树中所有值大于X的值因此，二叉查找树可以用某种统一的方式排序 根据这一性质，可以对二叉查找树有如下的函数定义 //头文件中的函数定义 struct TreeNode; typedef struct TreeNode* Position; typedef struct TreeNode* SearchTree; typedef int ElementType; SearchTree MakeEmpty(SearchTree T); Position Find(ElementType X,SearchTree T); Position FindMin(SearchTree T); Position FindMax(SearchTree T); SearchTree Insert(ElementType X,SearchTree T); SearchTree Delete(ElementType X,SearchTree T); ElementType Retrieve(Position P); Position FindPositionUp(SearchTree T,ElementType X); //具体实现文件中树节点的定义，这里将树节点元素类型定义为int类型 typedef int ElementType; struct TreeNode{ ElementType Element; SearchTree Left; SearchTree Right; }; 函数实现二叉查找树中最主要的两个功能就是插入数据和删除数据，在插入和删除数据之后需要保持整个二叉查找树任然具备二叉查找树的性质，这是很关键的 插入功能的实现根据二叉查找树的性质，那么要插入的数据是出入叶子节点实现算法如下: 判断插入元素与根节点元素的大小: 如果被插入的树是空树，那么分配内存空间并将新节点插入空树中; 如果插入元素大于根节点元素，使用递归的方式将插入元素插入到根节点的右子树上; 如果插入元素小于根节点元素，使用递归的方式将插入元素插入根节点的左子树上; 如果插入元素等于根节点元素，什么也不做 代码实现如下 SearchTree Insert(ElementType X,SearchTree T){ if(T == NULL){ T = (SearchTree)malloc(sizeof(struct TreeNode)); if(T == NULL) { printf(&quot;初始化树失败\n&quot;); return NULL; } T-&gt;Element = X; T-&gt;Left = T-&gt;Right = NULL; }else if(X &lt; T-&gt;Element){ T-&gt;Left = Insert(X,T-&gt;Left); }else if(X &gt; T-&gt;Element){ T-&gt;Right = Insert(X,T-&gt;Right); } return T; } 删除功能的实现删除功能相比于插入功能要困难， 如果删除的节点是叶子节点直接删除就行了， 如果删除的节点不是叶子节点，那么就需要找到一个节点来代替这个删除节点继续维持性质 删除功能算法如下: 1. 如果删除元素小于根节点元素，就去根节点的左子树删除该元素 2. 如果删除元素大于根节点元素，就去根节点的右子树删除该元素 3. 如果删除元素等于根节点元素，并且这个根节点还有两个子节点，先找到根节点右子树的最小值(或者根节点左子树的最大值)，将根节点的值修改为右子树的最小值(或者左子树的最大值)，然后去根节点的右子树删除最小值(或者去根节点的左子树删除最大值)。这里实际上把删除一个根节点改变为删除一个叶子节点 4. 如果删除元素等于根节点，并且这个根节点只有一个或者没有子节点 4.1 如果根节点只有右节点，将根节点变为右节点 4.2 如果根节点只有左节点，将根节点变为左节点 4.3 如果根节点没有子节点，参照4.1 代码实现如下 SearchTree Delete(ElementType X,SearchTree T){ Position ptr = T; if(T == NULL) return T; else if(X &lt; T-&gt;Element) T-&gt;Left = Delete(X,T-&gt;Left); else if(X &gt; T-&gt;Element) T-&gt;Right = Delete(X,T-&gt;Right); else if(T-&gt;Left != NULL &amp;&amp; T-&gt;Right != NULL){ //找到根节点右子树的最小值 ptr = FindMin(T-&gt;Right); //将右子树的最小值赋给根节点 T-&gt;Element = ptr-&gt;Element; //前往右子树删除最小值 T-&gt;Right = Delete(T-&gt;Element,T-&gt;Right); }else{ ptr = T; if(T-&gt;Left == NULL){ T = T-&gt;Right; }else if(T-&gt;Right == NULL){ T = T-&gt;Left; } free(ptr); } return T; } 二叉查找树可以方便的查找，但是在某些情况下，如果在二叉查找树中依次插入1,2,3,4,5,6，那么得到的二叉查找树图如下:这样的情况不是我们想看见的，在这种情况下使用平衡二叉树可以改善这个问题参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3-正则表达式]]></title>
    <url>%2F2018%2F01%2F23%2Fpython3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[python3 正则表达式 这篇文章需要具备正则表达式基础 re模块中文文档正则表达式练习网站 re模块主要有两个对象，正则表达式对象和匹配对象，正则表达式对象由re.compile()函数对正则表达式进行编译后获得匹配对象由正则表达式对象或re模块函数对文本进行匹配后取得，可以通过匹配对象获得文本匹配的字符串，位置等信息 使用正则表达式有两种方式使用编译正则表达式的方式对文本进行操作： 编译正则表达式，获得正则表达式对象 使用编译后的正则表达式对象对文本进行匹配或搜索 获得匹配对象，根据匹配对象获得匹配成功的文本或者匹配对象为None 直接使用函数对文本进行操作 使用re模块函数对传入的正则表达式和字符文本进行操作，获得匹配对象 获得匹配对象，根据匹配对象获得匹配成功的文本或者匹配对象为None 编译正则表达式的方式在多次使用正则表达式时效果更好 re函数直接对文本使用正则表达式验证和正则表达式对象对文本进行验证的过程大同小异，这里介绍使用re模块函数对文本使用正则表达式对象进行验证 实例使用正则表达式匹配电话号码 match匹配文本phones = [&apos;18408288131&apos;, &apos;1840-8288-131&apos;, &apos;184-0828-8131&apos;] phoneregex = r&apos;\d{3,4}-?\d{3,4}-?\d{3,4}&apos; for phone in phones: match = re.match(phoneregex,phone) if match is not None: print(match.group()) else : print(phone,&apos;is not match&apos;) 使用search搜索文本中满足正则表达式的字符串虽然使用match函数可以匹配文本，但是match函数只会从文本的开始出匹配文本，也就是从第一个字符位置开始匹配正则表达式，如果满足正则表达式的字符串不处于文本开始位置，那么match是无法匹配的而使用search函数可以搜索第一个匹配正则表达式的字符串 phones = [&apos;afdfa18408288131adfa&apos;, &apos;adfa1840-8288-131&apos;, &apos;abc184-0828-8131&apos;] for phone in phones: match = re.search(phoneregex,phone) if match is not None: print(match.group()) else : print(phone,&apos;is not search phone&apos;) 使用fullmatch函数完全匹配文本match函数会在文本开始出扫描文本匹配的字符串，但是无法判断这个文本之后是否有其他字符，search更不用说，只能获取文本中第一次匹配的字符串那么要判断一个文本是否完全匹配正则表达式，就需要使用fullmatch函数 phones = [&apos;afdfa18408288131adfa&apos;,&apos;18408288131&apos;, &apos;adfa1840-8288-131&apos;, &apos;184-0828-8131134141&apos;,&apos;184-0828-8131adfa&apos;] for phone in phones: match = re.fullmatch(phoneregex,phone) if match is not None: print(match.group()) else: print(phone,&apos;is not search phone&apos;) 使用findall函数返回所有匹配的字符串如果需要返回一个文本中所有满足正则表达式规则的字符串，前面的函数都无法达到要求使用findall可以将所有满足正则表达式的字符串封装成一个列表返回 phones = &apos;18408288131adfa1840-8288-131 184-0828-8131&apos; match = re.findall(phoneregex,phones) if match is not None: for m in match: print(m) 使用finditer函数返回所有满足要求的匹配对象finditer的效果和findall差不多，只不过finditer返回一个所有匹配的匹配对象的迭代器，通过这个迭代器可以获取匹配字符串 match = re.finditer(phoneregex,phones) if match is not None: for m in match: print(m.group()) 分组匹配当需要使用一个正则表达式获取一个文本中不同匹配字符串时上面函数又不能满足要求，当前可以使用多个正则表达式验证，但是有更好的方法可以得到这个效果 phones = [&apos;0830-18408288131&apos;,&apos;0830-18408288131&apos;, &apos;0830-1840-8288-131&apos;, &apos;0830-184-0828-8131&apos;,&apos;0830-184-0828-8131&apos;] phoneregex = r&apos;(\d{3,4}-)?(&apos; + phoneregex + &apos;)&apos; for phone in phones: match = re.match(phoneregex,phone) if match is not None: print(match.group(1),&apos;:&apos;,match.group(2)) else : print(phone, &apos;is not match&apos;) 这里使用一个正则表达式获取了电话的区号，电话号码，已经区号+电话号码 还有几个函数没有讲到:split函数使用正则表达式分割文sub和subn函数可以替换文本中正则表达式匹配成功的字符串以及escape函数和purge函数参考源码]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-collect方法]]></title>
    <url>%2F2018%2F01%2F13%2Fjava8-collect%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[collect方法collect 方法是Stream中一个很重要的方法，通过这个方法可以将流中的数据格式转换为需要的形式，如，List，Set，Map，求流数据的总数，流中数据某条属性的平均值或者其他值，将流中的字符串拼接为一条字符串等。 收集器是Stream用于收集某种形式的数据信息，基本上所有的Stream的终端操作都可以使用collect方法来实现 collect的定义collect方法有两种形式 方法原型1 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner); 方法原型2 &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 这里主要使用方法原型2,这个方法原型接收一个实现了Collector接口的对象，Collector接口有五个抽象方法，幸运的是java8封装了一些常用的方法供我们使用，这些常用方法封装在java.util.stream.Collectors对象中，这个对象含有多个静态方法，用来返回Collector对象 collect方法示例Apple.java public class Apple { private int weight; private String color; public Apple(int weight, String color) { super(); this.weight = weight; this.color = color; } //getter //setter } Main.java public class Main { public static void main(String[] args) { List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,&quot;green&quot;), new Apple(20,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(25,&quot;green&quot;)); //返回重量最重的苹果 System.out.println(&quot;-------------------返回重量最重的苹果----------------&quot;); Optional&lt;Apple&gt; heaviestApple = inventory.stream().collect(Collectors.maxBy(Comparator.comparing(Apple::getWeight))); System.out.println(heaviestApple); //返回重量最轻的苹果 System.out.println(&quot;-------------------返回重量最轻的苹果----------------&quot;); Optional&lt;Apple&gt; lightestApple = inventory.stream().collect(Collectors.minBy(Comparator.comparing(Apple::getWeight))); System.out.println(lightestApple); //返回苹果的总重量 System.out.println(&quot;-------------------返回苹果的总重量----------------&quot;); int sumInt = inventory.stream().collect(Collectors.summingInt(Apple::getWeight)); System.out.println(sumInt); //使用Collectors.averagingInt方法求苹果的平均重量 System.out.println(&quot;-------------------求苹果的平均重量-----------------&quot;); double averageWeight = inventory.stream().collect(Collectors.averagingDouble(Apple::getWeight)); System.out.println(averageWeight); //返回苹果的重量的各个数据 System.out.println(&quot;-------------------返回苹果重量的各个数据属性-----------------&quot;); IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); System.out.println(intSummartStatistics); //将所有苹果颜色拼接为一个字符串 System.out.println(&quot;-------------------将所有苹果颜色拼接为一个字符串-----------------&quot;); //joining会自动将流中的数据拼接为字符串，在处理时需要保证流中的数据都是字符串 String appleColors = inventory.stream() .map(Apple::getColor) //将流中的apple转换为apple的颜色 .collect(Collectors.joining(/*将每一个颜色后面加上一个空格*/&quot; &quot;)); System.out.println(appleColors); //返回苹果数量 System.out.println(&quot;-------------------返回苹果的总数量-----------------&quot;); Long count = inventory.stream().collect(Collectors.counting()); System.out.println(count); //分组 System.out.println(&quot;-------------------将苹果按照苹果颜色进行分组----------------&quot;); Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); System.out.println(appleColorMap); System.out.println(&quot;-------------------将苹果按照苹果颜色和重量进行分组 ----------------&quot;); System.out.println(inventory.stream().collect(Collectors.groupingBy(Apple::getColor, Collectors.groupingBy(apple -&gt; { if(apple.getWeight() &gt; 10 &amp;&amp; apple.getWeight() &lt; 20) return &quot;一般&quot;; else if(apple.getWeight() &gt;= 20 ) return &quot;很重&quot;; else return &quot;轻&quot;; })))); //收集每个颜色的苹果有多少个 System.out.println(&quot;-------------------收集每个颜色的苹果有多少个----------------&quot;); Map&lt;String, Long&gt; colorCount = inventory.stream().collect(Collectors.groupingBy(Apple::getColor,Collectors.counting())); System.out.println(colorCount); //分区 System.out.println(&quot;-------------------根据苹果颜色进行分区----------------&quot;); Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals(&quot;red&quot;))); System.out.println(colorPartition); //归约 System.out.println(&quot;-------------------归约操作----------------&quot;); System.out.println(inventory.stream().collect(Collectors.reducing(0,Apple::getWeight,(a,b) -&gt; a + b))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing((a,b) -&gt; { if(a &gt; b) return a; else return b; }))); System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing(100,(a,b) -&gt; { if(a &gt; b) return a; else return b; }))); } } 上面代码使用了大多数Collectors的方法，还有一些类型的方法,如:averagingDouble,averagingInt,averagingLong都是相同的。Collectors中的方法大致分为分组，分区，容器（返回list，set，map），简单的数值计算和其他 其中分组和分区是有区别的，分区可以看做是分组的特殊形式，分区只会有两个区别满足条件的（true）和不满足条件的（false），不管是分区还是分组，都可以再分,分组是根据返回的条件进行分组 Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor)); 这里就是根据苹果的颜色进行分组，map中只会有两个主键，red或者green。如果将条件改为Apple::getWeight,那么主键就会有10,20,12,25,因为有两个重量为12的苹果，这两个苹果就会分在一组 Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 这里根据苹果颜色是不是红色进行分区，只会有两个主键，true或者false，true分区里的苹果都是红色的，false分区里的值都不是红色的，但是partitioningBy里面可以传第二个参数，可以对分区里面再进行收集（collect方法）操作 容器可以为三种，List，Set，Map容器，只需要调用Collectors.toXxxx()方法就可以将流最后组装成一个容易简单的数值计算可以直接通过流计算得出，例如Stream.max()方法和Stream.collect(Collectors.maxBy())方法是相同的，在某些方面，如 IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight)); 可以返回多种数据的不同运算结果，还是很方便的 collect方法接收一个Collector对象，而大多数的Collector对象都可以通过Collectors对象的静态工厂方法获取，如果有需要可以查阅手册 参考源码限于知识和认识有限，页面中难免出现纰漏，如有错误可以发送邮件至liuxin739525@163.com邮箱指正，我将不胜感激。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-使用流]]></title>
    <url>%2F2018%2F01%2F12%2Fjava8-%E4%BD%BF%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[流介绍流是java API的新成员，他允许你以声明的方式处理数据集合（通过查询语句，而不是临时编写一个实现） 使用流集合是流最容易上手的方式，Java8 中的集合支持一个新的stream方法，他会放回一个流对象（接口定义在java.util.stream.Stream）中使用流可以完成什么事？他可以让我们以一种流水线的方法处理集合数据像我们前面处理苹果集合时那样，可以实现一个方法来收集或处理某些数据，比如过滤颜色不是红色的苹果，收集苹果的重量列表，但是每一次都需要调用一个方法，流为我们处理这种“一系列”数据提供了一些方法，可以像工厂流水线的方法对流数据进行处理 比如要收集颜色是红色苹果的重量集合，可以想这样写 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).map(Apple::getWeight).forEach(System.out::println); 这里先通过方法stream()生成一个流对象，再使用filter方法过滤掉颜色不是红色的苹果，接着通过map将所有颜色是红色的苹果的重量返回成一个数值流也就是剩下苹果重量的集合，接着调用forEach方法打印剩下苹果的重量。可以读作先过滤掉颜色不是红色的苹果，接着返回所有苹果重量的集合，然后打印如果使用上一节自定义方法实现这些操作书写格式如下: inventory = filter(inventory,apple -&gt; apple.getColor().equals(&quot;red&quot;)); List&lt;Integer&gt; weights = map(inventory,Apple::getWeight); forEach(weights, System.out::println); 可以看见流的可读性以及书写性都要高于自定义实现 流方法流的方法分为两类，一类是中间操作，一类是终端操作，中间操作是对流完成操作之后还会返回一个流对象，而终端操作的返回结果是任何不是流的值，前面的filter，map就是中间操作，forEach就是终端操作 使用流方法对苹果库存进行操作 使用forEach打印数据 inventory.stream().forEach(System.out::println); 筛选颜色为红色的苹果 inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).forEach(System.out::println); 对苹果颜色进行排序，如果个颜色相同，根据重量大小由小到大排序 Comparator&lt;Apple&gt; colorSort = (a1,a2) -&gt; a1.getColor().compareTo(a2.getColor()); Comparator&lt;Apple&gt; weightSort = (a1,a2) -&gt; a1.getWeight() - a2.getWeight(); inventory.stream().sorted(colorSort.thenComparing(weightSort)).forEach(System.out::println); 去除颜色和重量相同的苹果 inventory.stream().distinct().forEach(System.out::println); 只获取前三个苹果 inventory.stream().limit(3).forEach(System.out::println); 跳过前面两个苹果，只获取后面三个 inventory.stream().skip(2).forEach(System.out::println); 不要第一个苹果也不要最后一个苹果 inventory.stream().skip(1).limit(inventory.size() - 2).forEach(System.out::println); 将所有苹果的重量加10 inventory.stream().peek(apple -&gt; apple.setWeight(apple.getWeight() + 10)).forEach(System.out::println); 查看有没有重量是20,颜色是红色的苹果 System.out.println(inventory.stream().anyMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是所有苹果的重量是20,颜色是红色 System.out.println(inventory.stream().allMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看是不是没有苹果是红色的 System.out.println(inventory.stream().noneMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;))); 查看第一个苹果 System.out.println(inventory.stream().findFirst()); 返回苹果的总重量 System.out.println(inventory.stream().map(Apple::getWeight).reduce(0, (a,b) -&gt; (a + b))); 返回苹果的最小重量 System.out.println(inventory.stream().map(Apple::getWeight).min((n1,n2) -&gt; n1 - n2)); 返回苹果的最大重量 System.out.println(inventory.stream().map(Apple::getWeight).max((n1,n2) -&gt; n1 - n2)); 流的终端操作 方法 作用 boolean allMatch(Predicate&lt;? super T&gt; predicate) 如果流对象都可以匹配谓词，返回true，否则返回false boolean anyMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中有一个或多个匹配谓词，返回true，否则返回false boolean noneMatch(Predicate&lt;? super T&gt; predicate) 如果流对象中任何一个都没有匹配谓词，返回true，否则返回false Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最大值 Oprional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator) 自定义比较方法，返回流对象中比较方法比较出来的最小值 Optional&lt;T&gt; findAny() 未知 Optional&lt;T&gt; findFirst() 返回流对象中的第一个值 long count() 返回流中数据的个数 &lt;R,A&gt; R collect(Collecotr&lt;? super T,A,R&gt; collector) 未知 &lt;R&gt; R collecot(Supplier&lt;R&gt; supplier,BiConsumer&lt;R,? super T&gt; accumulator,BiConsumer&lt;R,R&gt; combiner) 未知 void forEach(Consumer&lt;? super T&gt; action) 未知 void forEachOrDered(Consumer&lt;? super T&gt; action) 未知 Oprional&lt;T&gt; reduce&lt;T identity,BinaryOperator&lt;T&gt; accumulator) 未知 &lt;U&gt; U reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner) 未知 Object[] toArray() 未知 &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) 未知 流的中间操作 方法 作用 distinct() 去重，流中的对象需要实现equlas方法 filter(Predicate&lt;? super T&gt; predicate) 按照规则过滤，满足规则的留下，不满足的去掉 limit(long maxSize) 返回数据的最大个数，10表示返回10个数据，5表示返回5个 map(Function&lt;? super T,? extends R&gt; mapper) 将每个流对象作为函数的参数，并且将返回值填充流对象 flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper) 将每个流对象作为函数的参数，但是只返回一个流对象 peek(Consumer&lt;? super T&gt; action) 可以在流处理时对每个流数据进行操作，并返回Stream对象 skip(long n) 跳过n个数据，n等于10,表示跳过前面10个数据，和limit方法一起使用效果更好 sorted() 默认排序，排序类需要实现默认排序接口 sorted(Comparator&lt;? super T&gt; comparator) 使用自定义排序对流数据进行排序 值得注意的是flatMap方法，这个方法和map方法不同，map方法会将每一个流对象都作用于Function&lt;? super T,? extends R&gt;返回一个R对象，flatMap方法也会将所有的流对象作用于Function的方法，但是只会返回一个`流对象`，这个方法可以用作一个流中的对象的属性是集合，并且需要将所有流对象为集合的属性收集起来的情况，比如收集几个字符串中所有不重复的字符。 参考源码限于知识和认识有限，页面中难免出现纰漏，如有错误可以发送邮件至canxing_zh@163.com邮箱指正，我将不胜感激。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-复合lambda表达式]]></title>
    <url>%2F2018%2F01%2F11%2Fjava8-%E5%A4%8D%E5%90%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java8中的函数式借口提供了允许你进行复合的方法，可以把多个lambda表达式复合成更复杂的表达式,就好像与操作(and)，或操作(or)，非操作(not)，以及组合操作 Predicate系列的组合操作接口 相关方法 Predicate&lt;T&gt; Predicate&lt;T&gt; negate() Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) DoublePredicate negate() DoublePredicate DoublePredicate and(DoublePredicate other) DoublePredicate or(DoublePredicate other) IntPredicate negate() IntPredicate IntPredicate and(IntPredicate other) IntPredicate or(IntPredicate other) LongPredicate negate() LongPredicate LongPredicate and(LongPredicate other) LongPredicate or(LongPredicate other) BiPredicate&lt;T,U&gt; negate() BiPredicate&lt;T,U&gt; BiPredicate&lt;T,U&gt; and(BiPredicate&lt;? super T,? super U&gt; other) BiPredicate&lt;T,U&gt; or(BiPredicate&lt;? super T,? super U&gt; other) Predicate系列的每个借口都含有and,or,not操作，可以和其他相同的借口进行组合对于苹果类，根据苹果的颜色和重量筛选符合要求的苹果可以有 //筛选颜色为红色的苹果 Predicate&lt;Apple&gt; redApple = (Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;); //筛选苹果重量大于15的苹果 Predicate&lt;Apple&gt; weightApple = apple -&gt; apple.getWeight() &gt; 15; //对苹果的颜色和重量筛选进行复合，筛选出即是红色重量有大于15的苹果 List&lt;Apple&gt; filterApples = filter(inventory,redApple.and(weightApple)); //筛选出是红色或者重量大于15的苹果 filterApples = filter(inventory,redApple.or(weightApple)); //筛选出既不是颜色既不是红色重量也不大于15的苹果 filterApples = filter(inventory,redApple.negate().or(weightApple.negate())); Function系列的组合操作接口 相关方法 Function&lt;T,R&gt; Function&lt;T,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before) BiFunction&lt;T,U,R&gt; BiFunction&lt;T,U,V&gt; addThen(Function&lt;? super R,? extends V&gt; after) Function系列的接口只有Function和BiFunction可以进行复合操作 Function的意思是函数，作为函数，具有参数和返回值，类似于f(x) = x + 1, 那么Function的addThen方法可以理解为将我的返回值作为别的函数的参数，在别的函数中进行函数运算。 如果说有两个函数 f(x) = x + 1 和 g(y) = y + 2，那么addThen可以将f(x)的返回值作为g(x)的参数传递进去，类似于g(f(x)) = f(x) + 2 = (x + 1) + 2这种 同样compose方法可以将别的函数的返回值作为自己的参数进行函数运算 BiFunction和Function不同的是，他具有三个泛型参数，以及他的addThen方法接收的是一个Function&lt;? super V,? extends T&gt;对象 同样也是将BiFunction的运算结果作为Function的参数，返回Function的运算结果 使用Function接口实现为苹果的重量加20，并返回一个列表 //获取苹果的重量 Function&lt;Apple,Integer&gt; getWeight = Apple::getWeight; //将一个数字加上20,在这里这个数字表示重量 Function&lt;Integer,Integer&gt; addWeight = weight -&gt; weight + 20; //使用Function的addThen方法将所有苹果的重量加上20并返回一个列表 List&lt;Integer&gt; weights = map(inventory,getWeight.andThen(addWeight)); //使用Function的compose方法将所有苹果的重量加上20并返回一个列表 weights = map(inventory,addWeight.compose(getWeight)); Consumer系列接口接口 相关方法 Consumer&lt;T&gt; Consumer&lt;T&gt; addThen(Consumer&lt;? super T&gt; after) DoubleConsumer DoubleConsumer addThen(DoubleConsumer after) IntConsumer IntConsumer addThen(IntConsumer after) LongConsuemr LongConsumer addThen(LongConsumer after) BiConsumer&lt;T,U&gt; BiConsumer&lt;T,U&gt; addThen(BiConsumer&lt;? super T,? super U&gt; after) Consumer系列的接口只接收一个泛型参数的都可以使用addThen方法，接收两个参数的只有BiConsumer接口可以使用addThen方法 关于addThen方法，很显然，在经过当前的Consumer对象的处理之后，可以继续被某个Consumer对象处理 使用Consumer将苹果的重量在原有的基础上乘2再加上10 //将苹果的重量乘2 Consumer&lt;Apple&gt; two = apple -&gt; apple.setWeight(apple.getWeight() * 2); //将苹果的重量加10 Consumer&lt;Apple&gt; add = apple -&gt; apple.setWeight(apple.getWeight() + 10); //使用组合将苹果的重量先乘2再加10 forEach(inventory,two.andThen(add)); 参考源码限于知识和认识有限，页面中难免出现纰漏，如有错误可以发送邮件至liuxin739525@163.com邮箱指正，我将不胜感激。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian-环境搭建]]></title>
    <url>%2F2018%2F01%2F08%2Fdebian-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[今天卸载了ubuntu，换了debian系统，重装系统方式为保留/home，/opt目录，重装/根目录 使用usb installer创建debian启动盘选择系统类型时，选择debian系统无法正确的创建启动盘，要选择其他linux系统类型才能正常创建 安装系统三个挂载目录，/,/home，/opt，其中/home和/opt是原来使用的挂载目录，没有改变，只覆盖了/目录debian桌面环境选择xfce桌面，核心功能模块 联网安装完系统后，第一步就是联网，正常连接校园网，免去了回退ubuntu的烦恼 设置镜像源debian在中国有两个主镜像源 ftp2.cn.debian.org/debian/ ftp.cn.debian.org/debian/ debian的主镜像源在国内也可以正常访问在/etc/apt/source.list文件中添加以下类似的源deb http://ftp.cn.debian.org/debian stretch main non-free 安装vim切换管理员用户 su apt-get install vim-gnome 安装中文输入法linux下的中文输入法有很多，这里选择fcitx，其他的ibus和搜狗输入法都与各种原因没有安装上，很遗憾没有体验一次切换管理员用户 su apt install fcitx apt install im-config apt install fcitx-sunpinyin 这个中文输入可以自行更换，不一定只能是这个 然后输入im-config进行配置，将下载的输入法添加到fcitx中就行了 配置java环境原来的java文件夹位于/opt/jdk下，因为没有覆盖/opt，所以不用重新下载修改.bashrc文件，在哪个用户目录下修改.bashrc就只会影响该用户在最后添加 export JAVA_HOME=/opt/jdk export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib 修改完成后，使用输入 source ～/.baserc java -version 如果看见java信息说明安装成功但是注销后进入发现运行的java不是sunjdk，而是openjdk，直接卸载openjdk，发现由于依赖关系，debian自动又下载了一个gcj-jdk，将依赖的libreoffice卸载后，sunjdk运行成功 配置maven环境同样修改.bashrc,在最后添加下面语句 export PATH=${PATH}:/opt/maven/bin 配置eclipseeclipse也是放在/opt目录下，没有修改，但是无法运行，报错缺少java运行时的环境。解决方法，修改eclipse目录下的eclipse.ini文件，在最开始添加 -vm /opt/jdk/bin 运行成功 安装mysql前往mysql下载页面根据版本下载mysql包在mysql包下载目录下打开终端，输入 dpkg -i mysql-apt-config_w.x.y-z_all.deb apt-get update apt-get install mysql-server 下载mysql server，中途会选择版本，输入管理员密码 修改mysql字符集，解决中文乱码问题编辑/etc/mysql/my.cnf，输入下面几句话 [client] default-character-set=utf8 [mysqld] character-set-server=utf8 退出，使用service mysql stop 停止mysql 服务然后在使用service mysql start 开启mysql服务进入mysql输入 show variables like &quot;%char%&quot;; 查看字符集，如果都是utf8说明修改成功，如果失败，再去找找其他办法吧 下载msyql-workbenchapt install mysql-workbench 安装gitapt install git 安装visual studio code前往visual studio code官网，下载deb包 dpkg -i codeXXXXX.deb apt-get install -f 解决冲突问题 安装chrome下载文件包 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 执行安装命令 dpkg -i google-chrome-stableXXX.deb 解决依赖问题 apt-get install -f 根据选择的架构不同，安装的chrome版本不同 安装hexonode.js 安装命令 wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装之后需要配置到用户环境变量 ~/.bashrc export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 然后使用下载 nvm install stable hexo 安装命令 npm install -g hexo-cli 安装pip3根据python版本，python2使用如下命令下载 apt-get install python-pip python3使用如下命令 apt-get install python3-pip 安装jupyter notebookjupyter官方安装指南 更新pip pip3 install –upgrade pip 下载jupyter pip3 install jupyter安装jupyter之后因该是可以直接启动，但是输入命令jupyter notebook无法正常启动，重启后输入命令 jupyter notebook可以正常启动 注意:如果在第2步安装jupyter时出错，无法导入name为’main’可以尝试使用以下命令修复 apt install --reinstall python3-requests 安装idle3apt install idle3 安装shadowsocks-qt5客户端感谢网友提供的连接安装成功 安装无线网卡驱动apt install firmware-iwlwifi modprobe -r iwlwifi ; modprobe iwlwifi 安装virtualbox(官方指南)[https://www.virtualbox.org/wiki/Linux_Downloads] 先将virtualbox的源添加到主机，这里的mydist指的是你的系统名称 deb https://download.virtualbox.org/virtualbox/debian &lt;mydist&gt; contrib 添加密钥到主机 wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add - wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add - 更新源并下载virtualbox，并不是只能下载virtualbox5.2版本可以选择其他版本下载 apt update apt install virtualbox-5.2 安装kazamapt install kazam 安装diaapt install dia 安装dia有可能会遇到无法输入中文字符的问题，解决方法如下: 1. 点击一个流程图下的图形 2. 绘出图形 3. 在图形上右键`-&gt;`Input Methods 选择X输入法 ssh如果是第一次使用ssh可以使用ssh-keygen生成密钥对 ssh-keygen 然后使用ssh-copy-id 将公钥发送给远程主机 ssh-copy-id username@ip-addr 然后在远程主机上将公钥文件名称修改为authorized_keys接着使用ssh登陆远程主机，如果不要密钥可以成功登陆那么完成如果不行你也许还要做这一步 ssh-add private-key 将你的私钥保存起来]]></content>
      <categories>
        <category>debian-environment</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java8-方法引用]]></title>
    <url>%2F2018%2F01%2F07%2Fjava8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是方法引用方法引用是lambd表达式的一种特殊形式。看起来更易读更自然 如果想要对苹果的重量进行排序我们可以这样写: inventory.sort((a1,a2) -&gt; a1.getWeight() - a2.getWeight()); 使用方法引用之后是这样的 inventory.sort(Apple::getWeight); 方法引用的语法格式 指向静态方法的引用Class::staticMethod 指向现有对象的实例方法的方法引用object::instanceMethod 指向任意类型实例方法的方法引用Class::instanceMethod 语法简述指向静态方法的引用类的静态方法必须满足函数描述符，也就是Class.staticMethod的参数和返回值要和函数描述符一致 对于Function function = Class::staticMethod;Class的staticMethod的静态方法定义应该是: public static intstaticMethod(int number){ //一个返回int类型的代码块 } 对于Consumer consumer = Class:staticMethod;Class的staticMethod的静态方法定义应该是: public static void staticMethod(int number){ //没有返回值的代码块 } 对于Predicate pred = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static boolean staticMethod(int number){ //返回boolean类型的代码块 } 对于Supplier supplier = Class::staticMethod;Class.staticMethod的静态方法定义应该是: public static int staticMethod(){ //返回int类型的代码块 } 指向现有对象的实例方法的方法引用类的实例方法必须满足函数描述符，也就是对象调用的方法的参数和返回值要和函数描述法一致 对于Function function = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 如果是BiFunction function = object::instanceMethod;Class的实例方法定义应该是: public int instacneMethod(int number){ //返回int类型的代码块 } 下同 对于Consumer consumer = object::instanceMethod;Class的实例方法定义应该是: public void instacneMethod(int number){ //没有返回值的代码块 } 对于Predicate predicate = object::instanceMethod;Class的实例方法定义应该是: public boolean instanceMethod(){ //返回boolean类型的代码块 } 对于Suplier supplier = object::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 对于第三种格式，函数描述符至少含有一个参数，也就是说必须有一个参数用来调用方法 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(){ //返回int类型的代码块 } 对于Function function = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(int number){ //返回int类型的代码块 } 对于Consumer consumer = Class::instanceMethod;Class的实例方法定义应该是: public void instanceMethod(){ //没有返回值的代码块 } 对于Comparator comparator = Class::instanceMethod;Class的实例方法定义应该是: public int instanceMethod(Class clazz){ //比较两个数大小的代码块，最后返回一个数用来表示大于，小于，等于 } 实例:使用方法引用来完成列表苹果的筛选，排序，输出，增加重量，返回对应的苹果重量列表 Apple.java public class Apple { private int weight; private String color; //getter setter } Main.java public class Main { public static void main(String[] args) { List&lt;Apple&gt; inventory = Arrays.asList( new Apple(10,&quot;green&quot;), new Apple(20,&quot;red&quot;), new Apple(12,&quot;red&quot;), new Apple(25,&quot;green&quot;)); List&lt;String&gt; strs = Arrays.asList( &quot;red&quot;,&quot;green&quot;,&quot;red&quot;,&quot;black&quot; ); //筛选 List&lt;Apple&gt; redApples = filter(inventory,Apple::getColor,&quot;red&quot;); forEach(redApples,System.out::println); List&lt;String&gt; red = filter(strs,String::toString,&quot;red&quot;); forEach(red,System.out::println); //将所有苹果的重量表示为一个列表 List&lt;Integer&gt; appleWeight = map(inventory,Apple::getWeight); forEach(appleWeight,System.out::println); //将所有苹果的重量加10 addWeight(inventory,Apple::getWeight,Apple::setWeight,10); forEach(inventory,System.out::println); //排序 inventory.sort(Comparator.comparing(Apple::getColor)); forEach(inventory,System.out::println); } public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } public static &lt;T&gt; void addWeight(List&lt;T&gt; inventory,ToIntFunction&lt;T&gt; func,ObjIntConsumer&lt;T&gt; consumer,int added) { for(T t : inventory) { consumer.accept(t,func.applyAsInt(t) + added); } } public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { result.add(func.apply(t)); } return result; } public static &lt;T,R&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Function&lt;T,R&gt; func,Object obj){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) { if(func.apply(t).equals(obj)) { result.add(t); } } return result; } } 可以看见方法引用的可读性是要强于lanbda表达式的，如： List redApples = filter(inventory,Apple::getColor,”red”); 可以读作:筛选苹果库存中颜色为红色的苹果 inventory.sort(Comparator.comparing(Apple::getColor)); 可以读作:库存根据苹果的颜色进行排序但是方法引用在某些方面的比较复杂的，比如要将所有苹果的重量加10,需要使用两个方法引用 addWeight(inventory,Apple::getWeight,Apple::setWeight,10); 参考源码限于知识和认识有限，页面中难免出现纰漏，如有错误可以发送邮件至liuxin739525@163.com邮箱指正，我将不胜感激。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-函数式接口]]></title>
    <url>%2F2018%2F01%2F05%2Fjava8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在上一次使用自定义的函数接口来使用lambda表达式，每一个lambda都要自定义一个已知的接口来实现，这样比较麻烦，如果可以使用通用的函数式接口，那么会方便很多。幸运的是java8中新增了一些通用的函数式接口供我们使用。下面就来看看吧。 函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口 —《java核心技术卷I基础知识第10版》一言蔽之，只有一个抽象方法的接口称为函数式接口 —《java8实战》 java8提供了一系列通用的函数式接口，位于java.util.function包中 可以看见这个包中只有含有接口，没有任何的抽象类，类，这些接口都需于函数接口，不要慌张，这些接口大部分表达的意思相同，只有少量的区别 函数描述符函数式接口的抽象方法的签名基本上就是lambda表达式的签名。我们将这种抽象方法叫做函数描述符lambda表达式的参数和返回值都要和函数式接口的签名对应，比如说函数式接口ApplePredicate的签名就是接收一个Apple类型的参数返回一个boolean类型的参数所以基本上满足接收一个Apple类型返回一个boolean类型的lambda表达式都可以看作是ApplePredicate的实现 下面来介绍几个函数式接口 Consumer翻译过来为消费者，接收一个参数没有返回值。源码接口如下： public interface Consumer&lt;T&gt; { void accept(T t); } 使用Consumer来实现一个List的遍厉public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) { for(T t : inventory) { consumer.accept(t); } } //使用forEach遍历列表 forEach(redApples,apple -&gt; System.out.println(apple)); 其他Consumer系列接口 接口 抽象方法 DoubleConsumer void accept(double value); IntConsumer void accept(int value); LongConsumer void accept(long value); ObjDoubleConsumer&lt;T&gt; void accept(T t,double value); ObjIntConsumer&lt;T&gt; void accept(T t,int value); ObjLongConsumer&lt;T&gt; void accept(T t,int long value); BiConsumer&lt;T,U&gt; void accept(T t,U u); Predicate谓词，用来描述或判断客体性质等(百度百科),这里用来表示判断 Predicate接口有5个方法，包括4个默认方法，1个抽象方法，默认方法以后再说，这里主要关注抽现方法 接口源码如下,接收一个泛型参数，返回一个boolean型数据，至于根据什么返回，怎么判断交给用户来实现 public interface Predicate&lt;T&gt;{ boolean test(T t); } 使用Predicate来实现过滤 public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Predicate&lt;T&gt; pred){ List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) if(pred.test(t)) result.add(t); return result; } 筛选红色苹果 List&lt;Apple&gt; redApples = filter(inventory,(Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;)); forEach(redApples,apple -&gt; System.out.println(apple)); 其他Predicate系列接口 接口 抽象方法 DoublePredicate boolean test(double value); IntPredicate boolean test(int value); LongPredicate boolean test(long value); BiPredicate&lt;T,U&gt; boolean test(T t,U u); DoublePredicate,LongPredicate,IntPredicate分别是用来判断double,long,int类型，由于double,long,int类型在使用泛型时会有一个自动装箱拆箱的过程，这是为了提高效率实现的三个类,使用上和Predicate没有什么区别 Function函数，接收一个参数返回一个值 public interface Function&lt;T,R&gt;{ R apply(T t); } 使用Function来实现遍历列表，并对列表进行某种操作，操作后返回一个值 public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){ List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) result.add(func.apply(t)); return result; } 使用map来将列表中的所有苹果的重量返回并用列表返回 List&lt;Integer&gt; weights = map(inventory,(Apple apple) -&gt; apple.getWeight()); 其他Function系列接口 接口 抽象方法 DoubleFunction&lt;R&gt; R apply(double value); IntFunction&lt;R&gt; R apply(int value); LongFunction&lt;R&gt; R apply(long value); ToDoubleFunction&lt;T&gt; double apply(T value); ToIntFunction&lt;T&gt; int apply(T value); ToLongFunction&lt;T&gt; long apply(T value); BiFunction&lt;T,U,R&gt; R apply(T t,U u); ToDoubleBiFunction&lt;T,U&gt; double apply(T t,U u); ToIntBiFunction&lt;T,U&gt; int apply(T t,U u); ToLongBuFunction&lt;T,U&gt; long apply(T t,U u); 可以看见大多数接口都是为了解决基本类型的封箱拆箱进行优化的接口 Supplier供应商，没有参数，只有返回值。少有使用，这里只提供接口 接口 抽象方法 Supplier&lt;T&gt; T get(); BooleanSupplier boolean get(); DoubleSupplier double get(); IntSupplier int get(); LongSupplier long get(); 其他函数式接口java.util.function包中还有几个使用Operator结尾的接口，现在还不太明白如何使用，以后再加。 参考源码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-lambda表达式]]></title>
    <url>%2F2018%2F01%2F04%2Fjava8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[测试环境 JDK 10 ，JUnit4 如何使用lambda表达式 定义一个只含有一个抽象方法的接口AbstractFuncOfSingle(只能是接口) public interface AbstractFuncOfSingle { int print(int a, int b); } 传入两个int类型的参数，返回一个类型的参数 定义一个方法，传入参数为AbstractFuncOfSingle public void callAbstractFuncOfSingle(AbstractFuncOfSingle singleFunc, int a, int b){ int result = singleFunc.print(a, b); System.out.println(result * 2); } 在方法中将方法参数a，b作为参数传入AbstractFuncOfSingle.print()方法，并使用result接收返回参数然后打印 调用上述方法 @Test public void testAbstractFuncOfSingle(){ callAbstractFuncOfSingle((a, b)-&gt;{ System.out.println(a + b); return a + b; }, 10, 23); } 使用lambda表达式创建一个内部类，打印a + b的和并返回a + b和 如果接口的抽象方法具有多个参数，那么lambda的传入参数个数也要一一对应，如果抽象方法具有返回值，在lambda表达式中也要有返回值，否则可以省略retur语句注意：lambda表达式的参数类型和返回类型要和抽象方法的参数类型和返回类型相同 lambda表达式和匿名内部类lambda表达式是匿名内部类的一种简化形式，lambda表达式只能书写于只有一个抽象方法的接口，匿名内部类可以书写具有多个抽象方法的接口和抽象类 实例代码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-tcp套接字编程]]></title>
    <url>%2F2017%2F12%2F28%2Fjava-tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是套接字传送们维基百科java中的套接字屏蔽了许多细节，不需要关注更多的底层信息。在java中套接字服务器可以使用java.net.ServerSocket创建一个常用的构造方法如下: ServerSocket server = new ServerSocket(int port); port: 表示套接字服务器需要监听的本机的端口，常见的端口有80端口，3306端口等，这个监听的端口不允许重复监听，建议使用靠后面的端口号然后可以使用 Socket client = server.accept()等待客户端的连接并返回一个Socket对象，通过这个Socket对象可以和客户端进行通信: OutputStream out = client.getOutputStream(); InputStream in = client.getInputStream(); out可以向客户端输出消息，in可以接受客户端的消息（消息的输入和输出都是相对于内存而言的，如果是写入内存中，那么就是输入，如果是从内存中读出，那么就是输出） 服务器一般都是长时间运行服务多个客户端，所以服务器一般不会关闭，在客户端和服务器中端连接时，只需要关闭输入输出流就行了。 套接字客户端的创建使用Socket创建，需要指定要连接的ip地址和端口，这个端口要和套接字服务器监听的端口号相同，ip地址要和套接字服务器所在主机的ip地址相同，linux下可以使用ifconfig命令查看ip地址，如果是在本机进行套接字编程，可以使用127.0.0.1或者localhost确定本机ip Socket socket = new Socket(Stirng ipAddress,int port); 创建套接字之后就可以获取输入输出流和服务器交流，这里的输入输出流是相对于客户端的输入输出，客户端的输入是服务器端的输出。 客户端不同于服务器，客户端关闭时需要关闭Socket，使用socket.close()关闭 一个简单的服务器Socket： //创建套接字服务器 ServerSocket server = new ServerSocket(int port); //套接字服务器一般不会关闭，所以使用死循环不同的获取连接，在获取客户端连接是一般要开线程 while(true){ //获取客户端连接 Socket socket = server.accept(); //获取输入输出流,按情况获取，如果即需要输入也需要输出那么两个都需要获取，io可以包装成Reader和Writer OutputStream out = socket.getOutputStream();//获取输出流 InputStream in = socket.getInputStream();//获取输入流 //进行消息的获取或发送 //... //关闭输入输出流 out.close(); in.close(); } 简单的客户端套接字: //创建客户端套接字 Socket socket = new Socket(String serverIp,int port); //获取输入输出流（一般来说客户端都是会先获取输出流发送消息到服务器，服务器返回消息，客户端使用输入流获取） OutputStream out = socket.getOutputStream(); InputStream in = socket.getInputStream(); //进行消息的发送与接收,可以使用死循环，在循环使用特殊字符串之类的东西退出 while(true){ //flag; //发送和接受 } //关闭输入输出流 out.close(); in.close(); //关闭套接字 socket.close(); 参考源码]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax异步处理]]></title>
    <url>%2F2017%2F12%2F16%2Fajax%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[AJAX异步处理基本操作,参考教程w3school AJAX是什么AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX可以在页面不刷新的情况更新局部页面，也可以在页面加载过程中先加载重要部分在加载不那么重要的部分，提高页面加载速度 AJAX工作流程AJAX基本对象 XMLHttpRequest是AJAX的基础，XMLHttpRequest 用于在后台与服务器交换数据 1. XMLHttpRequest的创建现代浏览器内置XMLHttpRequest对象使用如下方式创建 xmlhttp = new XMLHttpRequest(); 老版本的IE浏览器不支持XMLHttpRequest对象，使用ActiveXObject对象创建: xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 根据浏览器的不同使用不同的方式创建对象 var xmlhttp = null; if(window.XMLHttpRequest){ xmlhttp = new XMLHttpRequest(); }else{ xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) } 2. 使用AJAX发送请求使用的方法如下: open(method,url,async) 规定请求类型，URL，是否异步处理请求 method:请求类型;GET/POST url:要请求的连接;如www.google.com async:是否同步;true(异步)/false(同步) send(String) 发送请求到服务器 string:仅用于post请求 setRequestHeader(header,value) 向请求添加HTTP头 header:规定头的名称 value:规定头的值 3. 获取响应涉及属性如下: responseText 获得字符串形式的相应数据 responseXML 获得XML形式的响应数据 4. onreadystatechange事件onreadystatechange是当AJAX请求发送到服务器时，根据服务器的处理进度进行反馈的标志 readyState 属性 存储XMLHttpRequest的状态，从0到4变化 0：请求为初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪 status 200：“ok” 404：paga not found onreadystatechange 存储函数名，在每次readyState变化时调用存储的函数 一个基本的请求相映模板function loadXMLDoc(){ var xmlhttp = null; if(window.XMLHttpRequest){ xmlhttp = new XMLHttpRequest(); }else{ xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) } xmlhttp.onreadystatechange = function(){ if(xmlhttp.state == 200 &amp;&amp; xmlhttp.readeyState == 4){ //获取响应数据 var responseT = xmlhttp.responseText; } }; xmlhttp.open(&quot;GET&quot;,&quot;www.baidu.com&quot;,true); xmlhttp.send(null); } 一个使用ajax发送到服务器，服务器使用spring-mvc返回JSON数据并在页面显示的实例源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fjson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[JSON是什么JSON：JavaScript 对象表示法（JavaScript Object Notation）。JSON 是存储和交换文本信息的语法。类似 XML。JSON 比 XML 更小、更快，更易解析。参考w3school JSON实例{ &quot;employees&quot;: [ { &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; }, { &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; }, { &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; } ] } 使用python表示JSON实例one = {&quot;firstName&quot;:&quot;Bill&quot;,&quot;lastName&quot;:&quot;Gates&quot;} two = {&quot;firstName&quot;:&quot;George&quot;,&quot;lastName&quot;:&quot;Bush&quot;} three = {&quot;firstName&quot;:&quot;Thomas&quot;,&quot;lastName&quot;:&quot;Carter&quot;} employees = [one,two,three] o = {&quot;employess&quot;:employees} 使用java表示JSON实例Map&lt;String,String&gt; one = new HashMap&lt;&gt;(); Map&lt;String,String&gt; two = new HashMap&lt;&gt;(); Map&lt;String,String&gt; three = new HashMap&lt;&gt;(); one.put(&quot;firstName&quot;,&quot;Bill&quot;); one.put(&quot;lastName&quot;,&quot;Gates&quot;); two.put(&quot;firstName&quot;,&quot;George&quot;); two.put(&quot;lastName&quot;,&quot;Bush&quot;); three.put(&quot;firstName&quot;,&quot;Thomas&quot;); three.put(&quot;lastName&quot;,&quot;Carter&quot;); List&lt;Map&lt;String,String&gt;&gt; employees = new LinkedList&lt;&gt;(Arrays.asList(one,two,three)); Map&lt;String,List&lt;Map&lt;String,String&gt;&gt;&gt; o = new HashMap&lt;&gt;(); o.put(&quot;employees&quot;,employees); 可以发现JSON并没有什么神奇的地方，只不过是一群人定义的字符床规范格式而已，用的人多了就成了标准 将JSON转换为javascript对象 javascript 可以使用内置eval()函数将JSON数据生成原生的javascript对象var obj = eval(“(“ + JSON + “)”); JSON值有以下几种 数字(整数或浮点数)字符串(双引号中)逻辑值(true或false)数组(在方括号中)对象(在花括号中)null 使用本地JSON构建javascript对象实例可以在w3school找到，这里给出一个使用java:spring-mvc返回json对象并转换成javascript对象的实例spring-mvc返回JSOn数据参考源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-mvc返回json数据]]></title>
    <url>%2F2017%2F12%2F16%2Fspring-mvc%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[spring-mvc返回json数据在使用spring-mvc过程中遇到很多问题，记录下来方便查看 开发环境如下:eclipse Oxygen Release (4.7.0)java1.8spring 4.3.3freemarker 2.3.26(这个不是必须的) maven依赖包如下:&lt;!-- spring mvc返回json所需依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- freemarker 引擎，有了这个就不需要使用jstl了，只需要使用freemarker表达式就行了 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.26-incubating&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring bean 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; web.xml 配置:&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动顺序，让这个Servlet随Servletp容器一起启动。 --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!--会拦截URL中带“/”的请求。 --&gt; &lt;/servlet-mapping&gt; spring-mvc配置:&lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=&quot;canxing.web&quot; /&gt; spring-mvc配置freemarker:&lt;!-- freemarker 配置文件 --&gt; &lt;!-- freemarker config --&gt; &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/freemarker/&quot; /&gt; &lt;/bean&gt; &lt;!-- View resolvers can also be configured with ResourceBundles or XML files. If you need different view resolving based on Locale, you have to use the resource bundle resolver. --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt; &lt;/bean&gt; JSONController.java:@Controller public class JSONController { @RequestMapping(path=&quot;/json&quot;,produces=&quot;application/json&quot;) public @ResponseBody User index() {//使用@RespnseBody将返回的对象转化为JSON数据 System.out.println(&quot;index start&quot;); User user = new User(); user.setUsername(&quot;canxing&quot;); user.setPassword(&quot;123&quot;); System.out.println(&quot;index end&quot;); return user; } @RequestMapping(path=&quot;/&quot;) public String test() { return &quot;test&quot;; } } User.java://类不需要进行处理，只是一个普通的pojo类 public class User{ private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; } } test.flt:&lt;html&gt; &lt;head&gt; &lt;title&gt;freemarker test &lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function loadXMLDoc() { xmlhttp=null; if (window.XMLHttpRequest) {// code for Firefox, Mozilla, IE7, etc. xmlhttp=new XMLHttpRequest(); } else if (window.ActiveXObject) {// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } if (xmlhttp!=null) { xmlhttp.onreadystatechange=state_Change; xmlhttp.open(&quot;GET&quot;,&quot;http://localhost:8080/spring_web_test/json&quot;,true); xmlhttp.send(null); } else { alert(&quot;Your browser does not support XMLHTTP.&quot;); } } function state_Change(){ var obj = eval(&quot;(&quot; + xmlhttp.responseText + &quot;)&quot;); document.getElementById(&quot;username&quot;).innerHTML=obj.username document.getElementById(&quot;password&quot;).innerHTML=obj.password } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;freemarker test&lt;/h1&gt; username : &lt;span id=&apos;username&apos;&gt;&lt;/span&gt;&lt;br&gt; password : &lt;span id=&apos;password&apos;&gt;&lt;/span&gt;&lt;br&gt; &lt;button type=&apos;button&apos; onclick=&quot;loadXMLDoc()&quot;&gt;adfads&lt;/button&gt; &lt;/body&gt; 参考源码寻找答案中遇到的问题 依赖问题，spring默认的对象转化为json的jar包依赖，网上多是直接使用并没有说明依赖 还是依赖问题，spring和jackson之间版本的兼容性太差，稍微更改以下jackson或者spring的版本就会导致NoSuchMethodError错误，据说这里可以看见版本支持，但是看不懂]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>json</tag>
        <tag>spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述二-栈]]></title>
    <url>%2F2017%2F12%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%8C-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈又称堆栈，仅允许在表的一端进行插入和删除操作的线性表，该位置位于表尾，称为栈顶(Top)，相对地，另一端称为栈底。由于栈的插入和删除运算只能在栈顶一端进行，后进栈元素必定先出栈，所以把栈称为后进先出表(last in first out 简称 LIFO)这里使用链表实现栈 栈的定义//头文件中的函数定义 struct Node; typedef struct Node *PtrToNode; typedef PtrToNode Stack; typedef int ElementType; int IsEmpty(Stack S);//判断栈是否为空 Stack CreateStack(void);//创建一个空栈 void MakeEmpty(Stack S);//删除栈中的所有数据 void Push(ElementType X,Stack S);//将数据压入栈栈有两种实现方式，一种使用顺序表，另一种使用链表方式实现 ElementType Top(Stack S);//返回栈顶的数据 void Pop(Stack S);//弹出栈顶的元素 void printStack(Stack S);//遍历栈 //具体实现文件中栈节点的定义，使用int类型 typedef int ElementType; struct Node{ ElementType Element; PtrToNode Next;//因为是使用链表，所以这个执行下一个节点地址 }; 栈的实现栈的主要操作集中在Push和Pop操作，前者向栈中压入一个数据，后者从栈中弹出一个数据 Push功能实现void Push(ElementType X,Stack S){ PtrToNode Node; Node = (PtrToNode)malloc(sizeof(struct Node)); if(Node == NULL) return; Node-&gt;Element = X; Node-&gt;Next = S-&gt;Next; S-&gt;Next = Node; } Pop功能实现void Pop(Stack S){ if(IsEmpty(S)) return; PtrToNode temp = S-&gt;Next; S-&gt;Next = temp-&gt;Next; temp-&gt;Next = NULL; free(temp); } 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构c语言描述一-链表]]></title>
    <url>%2F2017%2F12%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%80-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表由一系列不必在内存中相连的结构组成，每一个结构单元均含有表元素和指向包含该元素后继元素的结构的指针如图所示 链表可以有两种表现形式，一种是带有头节点的链表(如上图所示)，另一种是不带有头节点的链表，一般来说带有头节点的链表很多时候处理起来比不带头节点的方便，因此这里选择带有头节点的链表展示 链表定义如下: //头文件中定义 struct Node; typedef struct Node *PtrToNode; typedef PtrToNode List; typedef PtrToNode Position; typedef struct ElementType ElementType; List MakeEmpty(List L); int IsEmpty(List L); int IsLast(Position P,List L); Position Find(ElementType X,List L); void Delete(ElementType X,List L); Position FindPrevious(ElementType X,List L); void Insert(ElementType X,List L,Position P); void DeleteList(List L); Position Header(List L); Position First(List L); void printList(List L); //在具体的实现文件中定义每个节点中的数据，这里选择int类型的数据 struct ElementType{ int data; }; struct Node{ ElementType Element; Position Next; }; 主要功能实现链表中稍微复杂的功能主要集中在删除和插入操作，删除和插入功能主要涉及到链表指针的移动以及内存的分配和释放当链表删除时，就需要调整指针，将删除节点的前驱节点的后继指针指向删除节点的后继节点，并释放删除节点所占用的内存空间当链表插入元素时，需要分配内存空间，创建一个新的节点，并将指定节点的后继指针指向新增节点，再把新增节点的后继指针指向原来指定节点的后继节点 链表插入操作实现代码void Insert(ElementType X,List L,Position P){ Position ptr ; ptr = (Position)malloc(sizeof(struct Node)); if(ptr == NULL) exit(0); ptr-&gt;Element = X; ptr-&gt;Next = P-&gt;Next; P-&gt;Next = ptr; } 链表删除操作实现代码void DeleteList(List L){ if(L == NULL || L-&gt;Next == NULL) return; Position ptr = NULL; Position temp = NULL; ptr = L-&gt;Next; L-&gt;Next = NULL; while(ptr != NULL){ temp = ptr; ptr = ptr-&gt;Next; temp-&gt;Next = NULL; free(temp); } } 参考源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下gpg的基本使用]]></title>
    <url>%2F2017%2F12%2F10%2Fubuntu%E4%B8%8Bgpg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是gpg 课程实验需要使用pgp对文件进行加密解密操作，pgp是一套用于消息加密、验证的应用程序，采用IDEA的散列算法作为加密与验证之用,但是pgp是商业软件不能自由使用，所以有自由软件基金会开发一个pgp的替代品，取名GnuPG，这就是gpg。 安装gpg 在ubuntu16.04下gpg已经安装好了，可以使用如下命令gpg -h如果输出有gpg的帮助文档，那么就有gpg，如果没有可以前往 gnupg官网 页面下载 gpg 基本使用1.生成密钥 输入以下命令开始生成密钥对 gpg --gen-key *选择密钥种类，默认选择1,使用RSA and RSA算法，表示加密和签名都使用RSA算法然后选择要使用的密钥长度默认为2048,密钥长度越长，越安全，由于是课程实验，所以使用默认值选择密钥的有效期，由于是课程实验，所以选择永不过期，如果是要上传到服务器上，按情况自行选择有效期系统确认输入真实姓名电子邮箱注释然后生成用户标识然后系统最后确认接着系统让你设置一个私钥密钥，用来保护私钥接着系统生成密钥，需要大量的随机字节，按系统提示等一下就会生成密钥 2.检查密钥 查看本机密钥 gpg --list-keys 3.输出密钥 输出公钥 gpg -a -o public-key.txt --export [用户标识(可以是密钥id，就是使用gpg --list-key 查看到的密钥id)] 输出私钥 gpg -a -o private-key.txt --export-secret-keys ##4.上出公钥 由于是课程实验，所以并没有上传（其实是不知道什么原因，无法上传到服务器) 5.导入密钥 gpg --import [密钥文件] 也可以到公钥服务器上寻找(未验证) gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户id] 注意： 使用手动导入公钥会出现无法认证的问题，可以使用 gpg --fingerpring 打印指纹，指纹是每对密钥生成的时候生成的，查看指纹后可以通过电话或者其他方式到提供者验证指纹 然后使用以下命令 gpg --sign-key [公钥id] 或者使用如下命令删除 gpg --delete-keys [公钥id] 6.公钥加密 gpg -r [用户id] -o [输出文件] -e [加密文件] -r 接受者的公钥的id，可以是邮箱 -o 输出加密后的文件名 -e 要执行加密操作的数据 7.解密 gpg [解密文件] gpg 有一个默认选择 -d 默认使用你的私钥解密别人使用你的公钥解密传送过来的数据 8.数字签名 gpg -s [文件名] 生成一份签名 gpg --clearsign [文件名] 生成一份明文签名 gpg -a -b [文件名] 生成一份分离的明文签名(去掉-a就是二进制签名) 9.验证签名 gpg --verify [被签名的文件] 参考文章 http://www.ruanyifeng.com/blog/2013/07/gpg.html http://www.williamlong.info/archives/3439.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pgp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github+hexo的个人博客]]></title>
    <url>%2F2017%2F12%2F09%2F%E5%9F%BA%E4%BA%8Egithub-hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[基于github+hexo的个人博客1. 本地环境配置 操作系统为 ubuntu16.04 1. git 使用 sudo apt install git下载git 2. node.js 安装命令 wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh nvm install stable 3. hexo npm install -g hexo-cli 安装hexo hexo安装 2. github 配置 前往github主页新建一个仓库，仓库名为 xxx.github.io(到时候通过xxx.github.io就可以访问个人博客，xxx最好是和github账户名相同，不同不知道是否可以) 3.创建本地文件资源 在/home/canxing/目录下创建保存博客资源文件夹 makir myblog 使用hexo初始化 hexo init ~/myblog 进入myblog文件夹 生成hexo所需要的文件目录 npm install 使用 hexo s 命令开启hexo服务，并通过localhost:4000 就可以访问一个初始的模板 4. 配置hexo hexo文件夹根目录下的_config.yml 文件为hexo的配置文件官方配置参数参考配置说明 部分参数说明如下 title:网站主标题 subtitle: 子标题 description: 网站描述 author: 作者 language: zh_CN timezone: 时区，没有设置为本地时区设置 url: 你的网站域名 root: 根路径 permalink:生成的链接的格式 theme:生成的博客系统样式，就是视图表示，可以前往hexo样式选择喜欢的样式然后使用git clone到本地 deploy: 部署选项，包括部署类型，仓库url，分支等 type: git repo: 仓库url branch: 一般是master 5. hexo预览和部署 hexo s开启hexo服务器，在网页中可以输入localhost:4000可以查看预览 hexo g生成新的文件资源 hexo d部署到github上，部署路径为_config.yml文件中的deploy的选项]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
