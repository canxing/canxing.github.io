<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDEA社区版使用maven搭建web开发环境</title>
    <url>/2018/04/17/IntelljJ-IDEA-Community-Edition-maven-webapp/</url>
    <content><![CDATA[<p>IDEA社区版是不支持web应用程序开发，但是IDEA支持Maven，在Maven配置文件中可以添加tomcat插件，因此可以使用IDEA进行web应用程序开发</p>
<h1 id="一-新建Maven项目"><a href="#一-新建Maven项目" class="headerlink" title="一 新建Maven项目"></a>一 新建Maven项目</h1><p>在选择新项目时选择maven项目，勾选 Create from archetype，在下方选择maven-archetype-webapp，点击Next<br><img src="idea-maven.png" alt="idea-创建maven类型项目"></p>
<p>输入GroupId和ArtifactId<br><img src="输入名称.png" alt="GroupId和ArtifactId"></p>
<p>选择Maven位置，如果Maven已经添加到环境变量，那么可以自动找到，如果没有配置，那么需要手动添加<br>User setting file为你的Maven配置文件，如果不是默认路径需要手动添加<br>Local repository为你的Maven仓库，如果不是默认路径需要手动添加<br><img src="maven-position.png" alt="Maven工程配置"></p>
<p>最后输入工程名称和工程位置<br><img src="最后.png" alt="工程名称和位置"></p>
<p>首次使用Maven会下载一些东西需要一些时间</p>
<h1 id="二-配置tomcat"><a href="#二-配置tomcat" class="headerlink" title="二 配置tomcat"></a>二 配置tomcat</h1><ol>
<li>首先在tomcat中添加tomcat插件  </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hostName</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">hostName</span>&gt;</span>    <span class="comment">&lt;!-- Default: localhost --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span>    <span class="comment">&lt;!-- 启动端口 Default:8080 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span>      <span class="comment">&lt;!-- uri编码 Default: ISO-8859-1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用的tomcat7</p>
<ol start="2">
<li>配置tomcat7</li>
</ol>
<p>单击菜单栏 Run，选择Edit Configurations…，进入如下界面  </p>
<p><img src="tomcat7配置.png" alt="tomcat7配置">  </p>
<p>默认只有一个Defaults，Maven是我配置好了的</p>
<p>选择+-&gt;Maven</p>
<p><img src="选择Mave.png" alt="选择Maven">  </p>
<p>输入Tomcat7，在Command line输入tomcat7:run完成配置</p>
<p><img src="tomcat7配置运行.png" alt></p>
<ol start="3">
<li>点击Run开始运行，打开浏览器查看结果如下</li>
</ol>
<p><img src="运行结果.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>ide</category>
      </categories>
      <tags>
        <tag>configure</tag>
        <tag>ide</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_基本类型</title>
    <url>/2018/10/10/Java-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li><a href="#基本类型">基本类型</a></li>
<li><a href="#引用类型">引用类型</a></li>
</ul>
<p>在 Java 中，每一个变量属于一种类型。在声明变量时，变量所属的类型位于变量名之前。</p>
<p>Java 的类型包括：基本类型和引用类型。基本类型和引用类型的区别在于，基本类型存储在栈上，而引用类型存储在堆上，并且基本类型没有方法。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>其中基本类型包括 byte, char, short, int, long, float, double, boolean。</p>
<p>基本类型的定义初始化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">3l</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">boolean</span> bool = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>所有基本类型在使用时必须先初始化后才能使用，否则会出现错误。</p>
<p>如果基本类型在类中方法之外定义但是没有初始化，那么类在创建时会对基本类型自动初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicTypeInit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">char</span> c ; </span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">boolean</span> bool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicTypeInit bti = <span class="keyword">new</span> BasicTypeInit();</span><br><span class="line">        System.out.println(bti.b);</span><br><span class="line">        System.out.println(bti.c);</span><br><span class="line">        System.out.println(bti.s);</span><br><span class="line">        System.out.println(bti.i);</span><br><span class="line">        System.out.println(bti.l);</span><br><span class="line">        System.out.println(bti.f);</span><br><span class="line">        System.out.println(bti.d);</span><br><span class="line">        System.out.println(bti.bool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0.0</span><br><span class="line">0.0</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>不同类型的变量初始化的值不同，byte, short, int, long 都会初始化为 0, float 和 double 初始化为 0.0，boolean 初始化为 false， char 初始化为空字符 “”。</p>
<p>不同类型所占用的存储空间不同</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1 字节</td>
</tr>
<tr>
<td>char</td>
<td>2 字节</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
</tr>
<tr>
<td>int</td>
<td>4 字节</td>
</tr>
<tr>
<td>long</td>
<td>8 字节</td>
</tr>
<tr>
<td>float</td>
<td>4 字节</td>
</tr>
<tr>
<td>double</td>
<td>8 字节</td>
</tr>
</tbody>
</table>
<p>Java 是一门面向对象的语言，但是基本类型是一个特例，在 Java SE5 中为基本类型提供了包装功能，将基本类型对应的引用类型称为包装器类型。可以将基本类型转换为对应的包装器类型，也可以在某些时候自动的将包装器类型转换为基本类型。基本类型和其对应的包装器类型对应如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>Void</td>
</tr>
</tbody>
</table>
<p>包装器对象可以进行和基本类型一样的操作，这是因为 Java SE5 的自动装箱和拆包机制，在需要的时候会将一个包装器对象转换为基本类型或者将一个基本类型封装成包装器对象。如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicAndWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">1</span>;</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer i3 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">1.2f</span>;</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        System.out.println(i3 == i2);</span><br><span class="line">        System.out.println(i1 + i2);</span><br><span class="line">        System.out.println(f1 + i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">2</span><br><span class="line">2.2</span><br></pre></td></tr></table></figure>
<p>可以看见包装器对象可以和基本类型进行算数运算和比较运算，但是有趣的是，就算创建两个完全相同的包装器对象，对它们使用 == 运算的结果也为 false。这是因为包装器对象和基本类型 == 运算时，会将包装器对象拆包成基本类型，这样比较的时候就相当于比较两个数值之间的比较，而两个类对象之间的 == 运算，比较的是两个类对象的地址，也就是查看两个类对象是否指向同一个区域。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型有五种：类，接口，数组，枚举，注解。</p>
<p>引用类型和基本类型不同，引用类型创建的变量称为引用，引用的值为对象，对象通过类创建。类是构造对象的模板或蓝图。由类构造对象的过程称为创建类的实例。</p>
<p>类可以是 Java 预定义的类，也可以是自定义的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个简单的类，通过该类可以定义了一个引用，指向由该类创建的对象。</p>
<p>创建它们的语法格式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure>
<p>通过持有对象的引用，可以访问该对象的方法或者域。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM 配置</title>
    <url>/2018/08/12/VIM-config/</url>
    <content><![CDATA[<p>VIM 配置</p>
<p>这个配置比较简单，只有有限的几个插件，涉及少数几个 VIM 命令，不同于其他 VIM 成熟的配置，如果你需要的是一个成熟的 VIM 配置，那么你应该去别的地方找找，如果你只需要一份简单的配置以便与后续的自定义，这个说不定就是你想要的。</p>
<p>VIM 显示界面</p>
<p><img src="./VIM图形.png" alt="VIM图形"></p>
<p>上述 VIM 样式是终端 VIM，对于 GUI VIM 也有一定的效果，但是不一定完全一样。</p>
<p>VIM 配置包括两部分，一部分是 VIM 插件，一部分 VIM 配置文件。</p>
<p>VIM 插件集中在 bundle 目录下，bundle 应该放在 <code>~/.vim/</code> 目录下，对于 windows 用户需要自行搜索插件存放目录。</p>
<p>VIM 配置文件 <code>.vimrc</code> 应该放在用户的根目录下，用于启动 VIM 时加载。</p>
<p>VIM 配置使用了以下几个插件</p>
<ul>
<li>Vundle 用于管理其他插件的插件</li>
<li>nerdtree 用于在 VIM 中显示目录树的插件 </li>
<li>gruvbox VIM 的主题插件</li>
<li>tabular 和 vim-markdown 是让 VIM 可以支持 Markdonw 的插件</li>
</ul>
<p>插件和配置文件可以在<a href="https://github.com/canxing/the-road-to-learning/tree/master/vim" target="_blank" rel="noopener">这里</a>找到</p>
]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM 配置</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax异步处理</title>
    <url>/2017/12/16/ajax%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="AJAX-异步处理"><a href="#AJAX-异步处理" class="headerlink" title="AJAX 异步处理"></a>AJAX 异步处理</h1><p>AJAX异步处理基本操作,参考教程<a href="http://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener">w3school</a></p>
<h2 id="AJAX是什么"><a href="#AJAX是什么" class="headerlink" title="AJAX是什么"></a>AJAX是什么</h2><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。<br>AJAX可以在页面不刷新的情况更新局部页面，也可以在页面加载过程中先加载重要部分在加载不那么重要的部分，提高页面加载速度</p>
<h2 id="AJAX工作流程"><a href="#AJAX工作流程" class="headerlink" title="AJAX工作流程"></a>AJAX工作流程</h2><h3 id="AJAX基本对象"><a href="#AJAX基本对象" class="headerlink" title="AJAX基本对象"></a>AJAX基本对象</h3><p> XMLHttpRequest是AJAX的基础，XMLHttpRequest 用于在后台与服务器交换数据</p>
<h4 id="1-XMLHttpRequest的创建"><a href="#1-XMLHttpRequest的创建" class="headerlink" title="1. XMLHttpRequest的创建"></a>1. XMLHttpRequest的创建</h4><p>现代浏览器内置XMLHttpRequest对象使用如下方式创建  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>
<p>老版本的IE浏览器不支持XMLHttpRequest对象，使用ActiveXObject对象创建:  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br></pre></td></tr></table></figure>
<p>根据浏览器的不同使用不同的方式创建对象  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-使用AJAX发送请求"><a href="#2-使用AJAX发送请求" class="headerlink" title="2. 使用AJAX发送请求"></a>2. 使用AJAX发送请求</h4><p>使用的方法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">open(method,url,<span class="keyword">async</span>)          规定请求类型，URL，是否异步处理请求</span><br><span class="line">    method:请求类型;GET/POST</span><br><span class="line">    url:要请求的连接;如www.google.com</span><br><span class="line">    <span class="keyword">async</span>:是否同步;<span class="literal">true</span>(异步)/<span class="literal">false</span>(同步)</span><br><span class="line">send(<span class="built_in">String</span>)                    发送请求到服务器</span><br><span class="line">    string:仅用于post请求</span><br><span class="line">setRequestHeader(header,value)  向请求添加HTTP头</span><br><span class="line">    header:规定头的名称</span><br><span class="line">    value:规定头的值</span><br></pre></td></tr></table></figure>
<h4 id="3-获取响应"><a href="#3-获取响应" class="headerlink" title="3. 获取响应"></a>3. 获取响应</h4><p>涉及属性如下:</p>
<pre><code>responseText                  获得字符串形式的相应数据
responseXML                   获得XML形式的响应数据
</code></pre><h4 id="4-onreadystatechange事件"><a href="#4-onreadystatechange事件" class="headerlink" title="4. onreadystatechange事件"></a>4. onreadystatechange事件</h4><p>onreadystatechange是当AJAX请求发送到服务器时，根据服务器的处理进度进行反馈的标志</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">readyState 属性               存储XMLHttpRequest的状态，从<span class="number">0</span>到<span class="number">4</span>变化</span><br><span class="line">      <span class="number">0</span>：请求为初始化</span><br><span class="line">      <span class="number">1</span>：服务器连接已建立</span><br><span class="line">      <span class="number">2</span>：请求已接收</span><br><span class="line">      <span class="number">3</span>：请求处理中</span><br><span class="line">      <span class="number">4</span>：请求已完成，且响应已就绪</span><br><span class="line">status</span><br><span class="line">      <span class="number">200</span>：“ok”</span><br><span class="line">      <span class="number">404</span>：paga not found</span><br><span class="line">onreadystatechange          存储函数名，在每次readyState变化时调用存储的函数</span><br></pre></td></tr></table></figure>
<h3 id="一个基本的请求相映模板"><a href="#一个基本的请求相映模板" class="headerlink" title="一个基本的请求相映模板"></a>一个基本的请求相映模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xmlhttp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlhttp.state == <span class="number">200</span> &amp;&amp; xmlhttp.readeyState == <span class="number">4</span>)&#123;</span><br><span class="line">      <span class="comment">//获取响应数据</span></span><br><span class="line">      <span class="keyword">var</span> responseT = xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">  xmlhttp.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/tree/master/java/spring_return_json" target="_blank" rel="noopener">一个使用ajax发送到服务器，服务器使用spring-mvc返回JSON数据并在页面显示的实例源码</a></p>
]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>containerd</title>
    <url>/2023/10/15/containerd/</url>
    <content><![CDATA[<h1 id="Containerd"><a href="#Containerd" class="headerlink" title="Containerd"></a>Containerd</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Containerd 的安装方式和安装 Docker 相似，Docker 内部操作的也是 Containerd，只不过 Docker 通过 Docker-cli 提供了一些面向用户的，更友好的接口。</p>
<p>设置仓库源</p>
<p>Ubuntu 系统使用下面命令设置仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">apt-get install -y containerd.io <span class="comment"># 安装最新版</span></span><br><span class="line">apt-get install -y containerd.io=1.6.24-1 <span class="comment"># 安装指定版本</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 apt-cache madison containerd.io 查看可安装的版本</p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用以下命令可以生成默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure>
<p>containerd 配置文件内容可以从以下网址获取</p>
<ul>
<li><a href="https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md" target="_blank" rel="noopener">https://github.com/containerd/containerd/blob/main/docs/man/containerd-config.toml.5.md</a></li>
<li><a href="https://github.com/containerd/containerd/issues/7937" target="_blank" rel="noopener">https://github.com/containerd/containerd/issues/7937</a></li>
<li><a href="https://github.com/containerd/containerd/blob/main/docs/cri/config.md" target="_blank" rel="noopener">https://github.com/containerd/containerd/blob/main/docs/cri/config.md</a></li>
</ul>
<h2 id="安装-crictl"><a href="#安装-crictl" class="headerlink" title="安装 crictl"></a>安装 crictl</h2><p>Docker 之所以为 Docker 是因为 Docker 在 containerd 之上提供了 Docker-cli，安装 containerd 之后还无法进行向 Docker 那样查看镜像，查看正在运行的容器。需要安装 crictl。</p>
<p>cri 是容器运行时接口，crictl 就是通过命令行操作容器运行时接口，只要满足是基于 cri 接口都可以通过 crictl 进行操作</p>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/crictl/" target="_blank" rel="noopener">安装文档</a></p>
<p>从 <a href="https://github.com/kubernetes-sigs/cri-tools/releases" target="_blank" rel="noopener">crictl release</a> 页面下载对应平台的压缩包，将解压后的可执行文件放在 <code>/usr/bin</code> 目录下</p>
<p>执行如下命令进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt; \EOF</span><br><span class="line">runtime-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">timeout: 2</span><br><span class="line">debug: <span class="literal">false</span></span><br><span class="line">pull-image-on-create: <span class="literal">false</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>接着通过 <code>crictl images</code> 查看已有镜像</p>
]]></content>
      <categories>
        <category>containerd</category>
      </categories>
      <tags>
        <tag>containerd</tag>
        <tag>容器</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/2018/11/26/docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><p>本文参考自 <code>&lt;&lt;Docker--从入门到实践&gt;&gt;</code>，该书<a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">github 地址</a>，<a href="https://gitee.com/docker_practice/docker_practice" target="_blank" rel="noopener">国内镜像</a></p>
<ul>
<li><a href="#docker基础">Docker基础</a><ul>
<li><a href="#基本概念">基本概念</a></li>
<li><a href="#镜像">镜像</a><ul>
<li><a href="#获取镜像">获取镜像</a></li>
<li><a href="#查看本地镜像">查看本地镜像</a></li>
<li><a href="#运行镜像">运行镜像</a></li>
<li><a href="#停止容器">停止容器</a></li>
<li><a href="#删除本地镜像">删除本地镜像</a></li>
<li><a href="#定制镜像">定制镜像</a></li>
<li><a href="#dockerfile指令">Dockerfile指令</a></li>
<li><a href="#导入导出镜像">导入导出镜像</a></li>
</ul>
</li>
<li><a href="#容器">容器</a><ul>
<li><a href="#启动容器">启动容器</a></li>
<li><a href="#查看容器信息">查看容器信息</a></li>
<li><a href="#终止容器">终止容器</a></li>
<li><a href="#进入容器">进入容器</a></li>
<li><a href="#删除容器">删除容器</a></li>
</ul>
</li>
<li><a href="#数据管理">数据管理</a><ul>
<li><a href="#数据卷">数据卷</a></li>
<li><a href="#挂载主机目录">挂载主机目录</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Docker 包含三个基本概念: 镜像，容器，仓库。镜像是模板，容器是根据镜像的定义生成的，仓库是存放镜像的地方。镜像在 VirtualBox 的概念相当于一个 OVA 文件，VirtualBox 可以导入这个 OVA 文件创建一个虚拟机，这个虚拟机就相当于容器的概念（并不是完全相似，容器在退出时会删除所有容器中的数据，每次启动容器就好像第一次启动，通过一些方法可以保存容器中的数据），存放 OVA 文件的地方就相当于一个仓库。</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序，库，资源，配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建之后也不会改变。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。命令格式为:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号] /][用户名/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>其中大部分参数可以省略，一个最简单的 <code>docker pull</code> 命令如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure>
<p>如果没有指定镜像的地址，那么默认地址为 Docker Hub 的地址，如果没有指定标签，那么默认标签为 latest。执行上面命令，会默认从 Docker Hub 拉取 hello-world:latest 镜像。</p>
<h3 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h3><p>通过 <code>docker imager ls</code> 命令可以查看本地安装的镜像</p>
<p>在本地运行上述命令得到的结果如下：</p>
<table>
<thead>
<tr>
<th>REPOSITORY</th>
<th>TAG</th>
<th>IMAGE ID</th>
<th>CREATED</th>
<th>SIZE</th>
</tr>
</thead>
<tbody>
<tr>
<td>hello-world</td>
<td>latest</td>
<td>4ab4c602aa5e</td>
<td>7 weeks ago</td>
<td>1.84kB</td>
<td></td>
</tr>
</tbody>
</table>
<p>上述命令会列出本地镜像的所有信息，包括镜像名称，镜像标签，镜像 ID，镜像创建时间和镜像大小。</p>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>获取到一个镜像之后，就可以利用这个镜像为基础启动一个容器。</p>
<p>使用 <code>docker run</code> 命令可以运行一个容器。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>在执行 <code>docker run</code> 命令时，会首先检查本地镜像，如果本地没有指定的镜像，会从指定的仓库拉取指定镜像。</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>启动一个容器之后可以通过 <code>docker container ls</code> 命令来查看容器的运行状态。</p>
<p>如果想要终止容器，使用 <code>docker container stop</code> 命令终止。对于已经停止的容器可以使用 <code>docker container start</code> 来重新启动。此外 <code>docker container restart</code> 命令会将一个正在运行的容器终止，然后重新启动。</p>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>删除本地镜像使用 <code>docker image rm</code>命令，其格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<p>其中镜像可以是镜像短 ID，镜像长 ID，镜像名或者镜像摘要</p>
<h3 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h3><p>Docker Hub 提供了很多镜像可以直接使用，对于在 Docker Hub 或者其他 Docker 仓库没有找到合适的镜像时，可以依赖某个镜像来创建符合自己需要的镜像。</p>
<p>这里使用 Dockerfile 来定制镜像。</p>
<p>这里定制的镜像以 Ngxin 镜像来基础进行创建，修改的内容为改变 Nginx 的 index.html 页面。首先创建 <code>mynginx</code> 目录，在 <code>mynginx</code> 目录中创建 <code>Dockerfile</code> 文件，Dockerfile 文件内容如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"&lt;h1&gt;Hello, Docker!&lt;/h1&gt;"</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<p>接着使用 <code>docker build -t nginx:v3 .</code> 命令来构建这个镜像，执行该命令输出如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"> ---&gt; dbfc48660aeb</span><br><span class="line">Step 2/2 : RUN <span class="built_in">echo</span> <span class="string">"&lt;h1&gt;Hello, Docker!&lt;/h1&gt;"</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e0233dda1b82</span><br><span class="line">Removing intermediate container e0233dda1b82</span><br><span class="line"> ---&gt; 135ca948fc71</span><br><span class="line">Successfully built 135ca948fc71</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure>
<p>接着使用 <code>docker image ls</code> 命令来查看本地镜像，可以看见本地镜像中已经创建好了 <code>nginx:v3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[canxing@debian docker] $ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v3                  135ca948fc71        40 seconds ago      109MB</span><br><span class="line">nginx               v2                  03fa889452ca        About an hour ago   109MB</span><br><span class="line">nginx               latest              dbfc48660aeb        2 weeks ago         109MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        7 weeks ago         1.84kB</span><br></pre></td></tr></table></figure>
<p>接着使用 <code>docker run --name web3 -d -p 80:80 nginx:v3</code> 命令来启动容器，在浏览器中输入 <code>localhost</code> 即可看见 Nginx 的 index.html 页面已经改变。</p>
<p>定制一个 Docker 镜像的关键在于 Dockerfile 文件，对于 Dockerfile 文件中的指令信息请看下面。</p>
<h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>声明制作的镜像是以哪个镜像为基础的</td>
<td><code>FROM &lt;仓库&gt;[:&lt;标签&gt;]</code></td>
<td>每个 Dockerfile 文件必须有一个 FROM 指令，并且该指令必须是第一条指令。如果只声明了仓库名没有声明标签，那么标签默认为 latest</td>
</tr>
<tr>
<td>RUN</td>
<td>用来执行命令行的命令</td>
<td><code>RUN &lt;命令&gt;</code> 或者 <code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></td>
<td></td>
</tr>
<tr>
<td>COPY</td>
<td>选择本地文件复制到 Docker 镜像</td>
<td><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code> 或者 <code>COPY [&quot;&lt;源路径1&gt;&quot;, ..., &quot;&lt;目标路径&gt;&quot;]</code></td>
<td>这里的源路径不是指本地路径，而是 Docker 构建的上下文路径</td>
</tr>
<tr>
<td>ADD</td>
<td>比 COPY 更高级的复制指令</td>
<td>同 COPY</td>
<td>可以使用 RUN 或者 COPY 代替</td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td><code>CMD &lt;命令&gt;</code> 或者 <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...]</code></td>
<td>在容器启动时执行的命令，和 RUN 不同，RUN 是在镜像构建过程执行的命令。CMD 命令在容器启动时可以输入新命令替代</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>定义容器的入口点，指定容器启动时执行的命令</td>
<td><code>ENTRYPOINT &lt;命令&gt;</code> 或者 <code>ENTRYPOINT [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code></td>
<td>和 CMD 不同，定义了 ENTRYPOINT 指令后，CMD 指令接受的都是参数，并且都会传递给 ENTRYPOINT 作为参数执行</td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量</td>
<td><code>ENV &lt;key&gt; &lt;value&gt;</code> 或者 <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></td>
<td>定义好环境变量后，在 ADD, COPY, ENV, EXPOSE, LABEL, USER, WORKDIR, VOLUME, STOPSIGNAL, ONBUILD 指令中都可以展开</td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></td>
<td>和 ENV 效果相同，设置环境变量，但是 ARG 设置的环境变量在容器启动时不存在</td>
</tr>
<tr>
<td>VOLUME</td>
<td>设置卷</td>
<td><code>VOLUME &lt;路径&gt;</code> 或者 <code>VOLUME [&quot;&lt;路径1&gt;, &lt;路径2&gt; ...&quot;]</code></td>
<td></td>
</tr>
<tr>
<td>EXPOSE</td>
<td>声明运行时容器提供服务的端口</td>
<td><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt; ...]</code></td>
<td>EXPOSE 只是声明容器打算使用的端口，并不会绑定宿主端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定工作目录，以后各层的当前目录就被改为指定的目录，如果命令不存在，WORKDIR 就会创建</td>
<td><code>WORKDIR &lt;工作目录路径&gt;</code></td>
</tr>
<tr>
<td>USER</td>
<td>指定用户</td>
<td><code>USER &lt;用户名&gt;</code></td>
<td>保证用户名存在</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>告诉 Docker 应该如何进行判断容器的状态是否正常</td>
<td><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code></td>
<td>如果基础镜像有健康检查可以使用 <code>HEALTHCHECK NONE</code> 屏蔽。HEALTHCHECK 是 Docker 1.12 引入的新指令</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当以当前镜像为基础，构建下一层镜像时才会被执行</td>
<td><code>ONBUILD &lt;其他指令&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="导入导出镜像"><a href="#导入导出镜像" class="headerlink" title="导入导出镜像"></a>导入导出镜像</h3><p>Docker 镜像可以本地导出再分享。导出命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image save -o &lt;<span class="built_in">source</span>&gt; &lt;仓库&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure>
<p>比如导出一个 ubuntu:base 镜像使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image save -o ~/ubuntu_base.tar ubuntu:base</span><br></pre></td></tr></table></figure>
<p>导入一个镜像使用 <code>docker image load</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image load -i ~/ubuntu_base.tar</span><br></pre></td></tr></table></figure>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像是静态的，容器是动态的。容器是基于镜像创建的，每个容器包含两层，底层是基于镜像的基础层，顶层是当前容器的容器存储层，容器运行于自己独立的<code>命名空间</code>，容器存储层的生命周期和容器的一样，当容器消亡时，容器存储层也随之消亡。下次启动的容器又会创建新的空间和容器存储层，因此不应该向容器存储层写入任何数据，存储数据应该使用数据卷或者宿主目录。</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动一个容器使用 <code>docker run</code> 命令，docker run 命令可以带很多参数，有几个常用的参数</p>
<ul>
<li>-i 打开容器的标准输入</li>
<li>-t 让 Docker 分配一个伪终端到容器的标准输入上</li>
<li>-d 保持容器后台运行</li>
<li>-p 指定宿主和容器之间的端口映射</li>
<li>-u 指定启动容器的用户名称或者 id，格式是 <code>&lt;name|uid&gt;[:&lt;group|gid&gt;]</code>。不指定，默认以 Dockerfile 中 <code>USER</code> 字段指定的用户启动</li>
<li>–name 指定容器运行的名称</li>
</ul>
<p>也可以使用 <code>docker container start</code> 命令启动一个已经终止了的容器。</p>
<h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><p>使用 <code>docker container ls</code> 可以查看运行的容器信息，<code>docker container ls -a</code> 可以查看所有容器信息，包括终止的。</p>
<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>终止容器使用 <code>docker container stop</code> 命令。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>如果在启动容器时使用了 <code>-d</code> 参数，那么容器会进入后台，在某些时候需要进入后台容器时，可以使用 <code>docker attach</code> 或者 <code>docker exec</code> 命令。</p>
<p>使用 <code>docker attach</code> 进入容器后退出会导致容器停止，而 <code>docker exec</code> 不会。建议使用 <code>docker exec</code>，停止容器使用 <code>docker container stop</code>。</p>
<p><code>docker exec</code> 需要知道容器的 id，可以通过 <code>docker container ls</code> 命令查看，然后通过 <code>docker exec -i -t &lt;id&gt;</code> 命令进入容器。</p>
<p>更多参数可以通过 <code>docker exec --help</code> 查看</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除容器使用 <code>docker container rm</code> 命令。同样需要知道容器的 id，如果需要删除正在运行的容器，需要加参数 <code>-f</code></p>
<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>容器运行与独立的空间，一个容器消亡时其容器存储层存储的数据也会丢失，对于容器中的数据管理只要有两种方式：数据卷和挂载主机目录</p>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，数据卷可以在容器之间共享和重用，对数据卷的修改会立马生效，对数据卷的更新不影响镜像，数据卷默认一直存在，即使容器被删除。</p>
<p>数据卷是一个特殊的目录，他的特殊之处在于这个目录完全由 Docker 进行管理。</p>
<p>创建一个数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker volume create my_vol</span><br></pre></td></tr></table></figure>
<p>查看数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my_vol</span><br></pre></td></tr></table></figure>
<p>查看数据卷详细信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker volume inspect my_vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2018-10-31T17:21:01+08:00"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my_vol/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my_vol"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>数据卷的位置不能自定义，数据卷存放在 Docker 目录下的 volumes 文件夹中。Docker 目录下存放了 Docker 镜像，数据卷等，可以通过修改 Docker 目录的方式转移数据卷的位置。</p>
<p>在 <code>/etc/docker/daemon.json</code> 文件夹中写入下面内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"graph"</span>: <span class="string">"/home/canxing/.docker/registry"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>graph 对应的路径就是 Docker 目录对应的路径，可以修改为实际路径。修改之后，使用 <code>systemctl restart docker</code> 重启 Docker。</p>
<p>删除数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker volume rm my_vol</span><br><span class="line">my_vol</span><br><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br></pre></td></tr></table></figure>
<p>挂载数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br><span class="line">$ docker run -it --mount <span class="built_in">source</span>=my-vol,target=/opt ubuntu:base</span><br></pre></td></tr></table></figure>
<p>可以在容器的 <code>/opt</code> 目录下添加文件，然后在数据卷本地位置上查看。</p>
<h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><p>Docker 允许挂载一个普通的主机目录到容器，因为这个主机目录不归 Docker 管理，因此主机目录的位置可以随意放置，但是这也会在某些情况导致该目录读取存在权限拒绝的情况。</p>
<p>在用户目录下创建一个目录，然后挂在到容器中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make vol</span><br><span class="line">$ docker run -it --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/root/vol,target=/opt ubuntu:base</span><br></pre></td></tr></table></figure>
<blockquote>
<p>挂在主机目录时，需要使用绝对路径，因此需要将 /root/vol 改为自己主机上的绝对路径</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>debian-环境搭建</title>
    <url>/2018/01/08/debian-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="使用usb-installer创建debian启动盘"><a href="#使用usb-installer创建debian启动盘" class="headerlink" title="使用usb installer创建debian启动盘"></a>使用usb installer创建debian启动盘</h2><p>选择系统类型时，选择debian系统无法正确的创建启动盘，要选择其他linux系统类型才能正常创建</p>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>三个挂载目录，/,/home，/opt，其中/home和/opt是原来使用的挂载目录，没有改变，只覆盖了/目录<br>debian桌面环境选择xfce桌面，核心功能模块</p>
<h2 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h2><p>安装完系统后，第一步就是联网，正常连接校园网，免去了回退ubuntu的烦恼</p>
<h2 id="设置镜像源"><a href="#设置镜像源" class="headerlink" title="设置镜像源"></a>设置镜像源</h2><p>debian在中国有两个主镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://security.debian.org/debian-security stretch/updates main contrib</span><br><span class="line">deb-src http://security.debian.org/debian-security stretch/updates main contrib</span><br><span class="line">deb http://ftp2.cn.debian.org/debian/ stretch main contrib non-free</span><br><span class="line">deb-src http://ftp2.cn.debian.org/debian/ stretch main contrib non-free</span><br><span class="line">deb http://ftp2.cn.debian.org/debian/ stretch-updates main contrib non-free</span><br><span class="line">deb-src http://ftp2.cn.debian.org/debian/ stretch-updates main contrib non-free</span><br></pre></td></tr></table></figure>
<p>debian的主镜像源在国内也可以正常访问<br>在/etc/apt/source.list文件中添加以下类似的源  </p>
<h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><p>切换管理员用户  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">apt-get install vim-gnome</span><br></pre></td></tr></table></figure>
<h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><p>linux下的中文输入法有很多，这里选择fcitx，其他的ibus和搜狗输入法都与各种原因没有安装上，很遗憾没有体验一次<br>切换管理员用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">apt install fcitx</span><br><span class="line">apt install im-config</span><br><span class="line">apt install fcitx-sunpinyin  这个中文输入可以自行更换，不一定只能是这个</span><br></pre></td></tr></table></figure>
<p>然后输入im-config进行配置，将下载的输入法添加到fcitx中就行了</p>
<p>如果 <code>im-config</code> 命令提示缺少什么就需要下载什么</p>
<p>设置完成之后无法显示输入法的提示框，先删除 <code>~/.config/fcitx</code> 目录，然后卸载已将安装的 <code>fcitx</code> 重新安装</p>
<h2 id="安装无线网卡驱动"><a href="#安装无线网卡驱动" class="headerlink" title="安装无线网卡驱动"></a>安装无线网卡驱动</h2><p>debian 不会自动安装无线网卡驱动，如果需要手动安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install firmware-iwlwifi</span><br><span class="line">modprobe -r iwlwifi ; modprobe iwlwifi</span><br></pre></td></tr></table></figure>
<h2 id="配置java环境"><a href="#配置java环境" class="headerlink" title="配置java环境"></a>配置java环境</h2><p>原来的java文件夹位于/opt/jdk下，因为没有覆盖/opt，所以不用重新下载</p>
<p>修改.bashrc文件，在哪个用户目录下修改.bashrc就只会影响该用户 </p>
<p>在最后添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/opt/jdk</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib</span><br></pre></td></tr></table></figure>
<p>修改完成后，使用输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ～/.baserc</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>如果看见java信息说明安装成功</p>
<p>但是注销后进入发现运行的java不是sunjdk，而是openjdk，直接卸载openjdk，发现由于依赖关系，debian自动又下载了一个gcj-jdk，将依赖的libreoffice卸载后，sunjdk运行成功</p>
<h2 id="配置maven环境"><a href="#配置maven环境" class="headerlink" title="配置maven环境"></a>配置maven环境</h2><p>同样修改.bashrc,在最后添加下面语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:/opt/maven/bin</span><br></pre></td></tr></table></figure>
<h2 id="配置eclipse"><a href="#配置eclipse" class="headerlink" title="配置eclipse"></a>配置eclipse</h2><p>eclipse也是放在/opt目录下，没有修改，但是无法运行，报错缺少java运行时的环境。</p>
<p>解决方法，修改eclipse目录下的eclipse.ini文件，在最开始添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-vm</span><br><span class="line">/opt/jdk/bin</span><br></pre></td></tr></table></figure>
<p>运行成功</p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>前往<a href="https://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="noopener">mysql下载页面</a>根据版本下载mysql包</p>
<p>在mysql包下载目录下打开终端，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -i mysql-apt-config_w.x.y-z_all.deb</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<p>下载mysql server，中途会选择版本，输入管理员密码</p>
<h3 id="修改mysql字符集，解决中文乱码问题"><a href="#修改mysql字符集，解决中文乱码问题" class="headerlink" title="修改mysql字符集，解决中文乱码问题"></a>修改mysql字符集，解决中文乱码问题</h3><p>编辑/etc/mysql/my.cnf，输入下面几句话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p>退出，使用service mysql stop 停止mysql 服务</p>
<p>然后在使用service mysql start 开启mysql服务</p>
<p>进入mysql</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &quot;%char%&quot;;</span><br></pre></td></tr></table></figure>
<p>查看字符集，如果都是utf8说明修改成功，如果失败，再去找找其他办法吧</p>
<h3 id="下载msyql-workbench"><a href="#下载msyql-workbench" class="headerlink" title="下载msyql-workbench"></a>下载msyql-workbench</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install mysql-workbench</span><br></pre></td></tr></table></figure>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install git</span><br></pre></td></tr></table></figure>
<h2 id="安装visual-studio-code"><a href="#安装visual-studio-code" class="headerlink" title="安装visual studio code"></a>安装visual studio code</h2><p>前往visual studio code官网，下载deb包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -i codeXXXXX.deb</span><br><span class="line">apt-get install -f 解决冲突问题</span><br></pre></td></tr></table></figure>
<h2 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h2><p>下载文件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>
<p>执行安装命令 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -i google-chrome-stableXXX.deb</span><br></pre></td></tr></table></figure>
<p>解决依赖问题 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -f</span><br></pre></td></tr></table></figure>
<p>根据选择的架构不同，安装的chrome版本不同</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>nvm安装命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>安装之后需要配置到用户环境变量 ~/.bashrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br></pre></td></tr></table></figure>
<p>下载最新的 Node</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure>
<p>hexo 安装命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="安装pip3"><a href="#安装pip3" class="headerlink" title="安装pip3"></a>安装pip3</h2><p>根据python版本，python2使用如下命令下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install python-pip</span><br></pre></td></tr></table></figure>
<p>python3 使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install python3-pip</span><br></pre></td></tr></table></figure>
<h2 id="安装jupyter-notebook"><a href="#安装jupyter-notebook" class="headerlink" title="安装jupyter notebook"></a>安装jupyter notebook</h2><p><a href="https://jupyter.readthedocs.io/en/latest/install.html" target="_blank" rel="noopener">jupyter官方安装指南</a></p>
<ol>
<li>更新 pip</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>下载 jupyter</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install jupyter</span><br></pre></td></tr></table></figure>
<p>安装 jupyter 之后因该是可以直接启动，但是输入命令 <code>jupyter notebook</code> 无法正常启动，重启后输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>可以正常启动</p>
<p><code>注意</code>:如果在第 2 步安装 jupyter 时出错，无法导入 name 为 ‘main’ 可以尝试使用以下命令修复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install --reinstall python3-requests</span><br></pre></td></tr></table></figure>
<h2 id="安装-idle3"><a href="#安装-idle3" class="headerlink" title="安装  idle3"></a>安装  idle3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install idle3</span><br></pre></td></tr></table></figure>
<h2 id="安装-shadowsocks-qt5-客户端"><a href="#安装-shadowsocks-qt5-客户端" class="headerlink" title="安装 shadowsocks-qt5 客户端"></a>安装 shadowsocks-qt5 客户端</h2><p>感谢网友提供的<a href="https://github.com/try1try/shadowsocks-qt5" target="_blank" rel="noopener">连接</a>安装成功</p>
<h2 id="安装-virtualbox"><a href="#安装-virtualbox" class="headerlink" title="安装 virtualbox"></a>安装 virtualbox</h2><p>[官方指南][<a href="https://www.virtualbox.org/wiki/Linux_Downloads]" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Linux_Downloads]</a></p>
<ol>
<li>先将virtualbox的源添加到主机，这里的mydist指的是你的系统名称</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb https://download.virtualbox.org/virtualbox/debian `&lt;mydist&gt;` contrib</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>添加密钥到主机</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -</span><br><span class="line">wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>更新源并下载virtualbox，并不是只能下载virtualbox5.2版本可以选择其他版本下载</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install virtualbox-5.2</span><br></pre></td></tr></table></figure>
<h2 id="安装-kazam"><a href="#安装-kazam" class="headerlink" title="安装 kazam"></a>安装 kazam</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install kazam</span><br></pre></td></tr></table></figure>
<h2 id="安装-dia"><a href="#安装-dia" class="headerlink" title="安装 dia"></a>安装 dia</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install dia</span><br></pre></td></tr></table></figure>
<p>安装dia有可能会遇到无法输入中文字符的问题，解决方法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 点击一个流程图下的图形</span><br><span class="line">2. 绘出图形</span><br><span class="line">3. 在图形上右键`-&gt;`Input Methods 选择X输入法</span><br></pre></td></tr></table></figure>
<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>如果是第一次使用ssh可以使用ssh-keygen生成密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>然后使用ssh-copy-id 将公钥发送给远程主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id username@ip-addr</span><br></pre></td></tr></table></figure>
<p>然后在远程主机上将公钥文件名称修改为authorized_keys</p>
<p>接着使用ssh登陆远程主机，如果不行你也许还要做这一步</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-add private-key</span><br></pre></td></tr></table></figure>
<p>将你的私钥保存起来</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 docker buildx 构建多 CPU 架构镜像</title>
    <url>/2022/07/13/docker%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="使用-docker-buildx-构建多-CPU-架构镜像"><a href="#使用-docker-buildx-构建多-CPU-架构镜像" class="headerlink" title="使用 docker buildx 构建多 CPU 架构镜像"></a>使用 docker buildx 构建多 CPU 架构镜像</h1><p>docker 版本大于等于 19.03 支持使用 docker buildx 方式构建多 CPU 架构镜像</p>
<h2 id="启动-docker-buildx"><a href="#启动-docker-buildx" class="headerlink" title="启动 docker buildx"></a>启动 docker buildx</h2><p>在最新的 docker 20.10.7 版本中，docker buildx 已经默认启动，可以通过 <code>docker buildx version</code> 查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@:~<span class="comment"># docker buildx version</span></span><br><span class="line">github.com/docker/buildx v0.5.1-docker 11057da37336192bfc57d81e02359ba7ba848e4a</span><br></pre></td></tr></table></figure>
<p>如果返回找不到命令，那么需要为当前版本 docker 开启这项功能。编辑 <code>/etc/docker/daemon.json</code> 文件，写入 <code>&quot;experimetal&quot;: true</code>，保存退出后重启 docker。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请备份 daemon.json 文件！！！</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&#123;"</span>experimetal<span class="string">": true&#125;"</span> &gt; /etc/docker/daemon.json;</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="开启-binfmt-misc"><a href="#开启-binfmt-misc" class="headerlink" title="开启 binfmt_misc"></a>开启 binfmt_misc</h2><p>通过一个特权容器来开启 Linux 系统上的 binfmt_misc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm --privileged docker/binfmt:a7996909642ee92942dcd6cff44b9b95f08dad64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>DockerHub 地址: <a href="https://hub.docker.com/r/docker/binfmt" target="_blank" rel="noopener">docker/binfmt</a></p>
</blockquote>
<p>查看是否设置正确</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@:~<span class="comment"># ls -al /proc/sys/fs/binfmt_misc/</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 0 Jul  7 06:27 .</span><br><span class="line">dr-xr-xr-x 1 root root 0 Jul  7 06:08 ..</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul  7 06:27 qemu-aarch64</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul  7 06:27 qemu-arm</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul  7 06:27 qemu-ppc64le</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul  7 06:27 qemu-riscv64</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul  7 06:27 qemu-s390x</span><br><span class="line">--w------- 1 root root 0 Jul  7 06:27 register</span><br><span class="line">-rw-r--r-- 1 root root 0 Jul  7 06:27 status</span><br></pre></td></tr></table></figure>
<h2 id="切换镜像构建为多架构构建器"><a href="#切换镜像构建为多架构构建器" class="headerlink" title="切换镜像构建为多架构构建器"></a>切换镜像构建为多架构构建器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker buildx create --use --name mybuilder</span><br></pre></td></tr></table></figure>
<p>验证构建器是否生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@:~<span class="comment"># docker buildx ls</span></span><br><span class="line">NAME/NODE    DRIVER/ENDPOINT             STATUS   PLATFORMS</span><br><span class="line">mybuilder *  docker-container                     </span><br><span class="line">  mybuilder0 unix:///var/run/docker.sock inactive </span><br><span class="line">default      docker                               </span><br><span class="line">  default    default                     running  linux/amd64, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/arm/v7, linux/arm/v6</span><br></pre></td></tr></table></figure>
<h2 id="在-amd64-机器上启动-arm-架构容器"><a href="#在-amd64-机器上启动-arm-架构容器" class="headerlink" title="在 amd64 机器上启动 arm 架构容器"></a>在 amd64 机器上启动 arm 架构容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@:~<span class="comment"># docker pull --platform arm64 nginx</span></span><br><span class="line">root@:~<span class="comment"># docker run -d -p 80:80 --platform arm64 nginx</span></span><br><span class="line">root@:~<span class="comment"># curl localhost</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>java-tcp套接字编程</title>
    <url>/2017/12/28/java-tcp%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="什么是套接字传送们维基百科"><a href="#什么是套接字传送们维基百科" class="headerlink" title="什么是套接字传送们维基百科"></a>什么是套接字<a href="https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97" target="_blank" rel="noopener">传送们维基百科</a></h1><p>java中的套接字屏蔽了许多细节，不需要关注更多的底层信息。<br>在java中套接字服务器可以使用java.net.ServerSocket创建<br>一个常用的构造方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="keyword">int</span>	port);</span><br></pre></td></tr></table></figure>
<p>port: 表示套接字服务器需要监听的本机的端口，常见的端口有 80 端口，3306 端口等，这个监听的端口不允许重复监听，建议使用靠后面的端口号<br>然后可以使用 <code>Socket client = server.accept()</code> 等待客户端的连接并返回一个 Socket 对象，通过这个 Socket 对象可以和客户端进行通信:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream out = client.getOutputStream();</span><br><span class="line">InputStream in = client.getInputStream();</span><br></pre></td></tr></table></figure>
<p>out 可以向客户端输出消息，in 可以接受客户端的消息（消息的输入和输出都是相对于内存而言的，如果是写入内存中，那么就是输入，如果是从内存中读出，那么就是输出）</p>
<p>服务器一般都是长时间运行服务多个客户端，所以服务器一般不会关闭，在客户端和服务器中端连接时，只需要关闭输入输出流就行了。</p>
<p>套接字客户端的创建使用 Socket 创建，需要指定要连接的 ip 地址和端口，这个端口要和套接字服务器监听的端口号相同，ip 地址要和套接字服务器所在主机的 ip 地址相同，linux 下可以使用 ifconfig 命令查看 ip 地址，如果是在本机进行套接字编程，可以使用 127.0.0.1 或者 localhost 确定本机 ip</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(Stirng ipAddress,<span class="keyword">int</span> port);</span><br></pre></td></tr></table></figure>
<p>创建套接字之后就可以获取输入输出流和服务器交流，这里的输入输出流是相对于客户端的输入输出，客户端的输入是服务器端的输出。</p>
<p>客户端不同于服务器，客户端关闭时需要关闭 Socket，使用 socket.close() 关闭</p>
<p>一个简单的服务器 Socket：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建套接字服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="keyword">int</span> port);</span><br><span class="line"><span class="comment">//套接字服务器一般不会关闭，所以使用死循环不同的获取连接，在获取客户端连接是一般要开线程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//获取客户端连接</span></span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    <span class="comment">//获取输入输出流,按情况获取，如果即需要输入也需要输出那么两个都需要获取，io可以包装成Reader和Writer</span></span><br><span class="line">    OutputStream out = socket.getOutputStream();<span class="comment">//获取输出流</span></span><br><span class="line">    InputStream in = socket.getInputStream();<span class="comment">//获取输入流</span></span><br><span class="line">    <span class="comment">//进行消息的获取或发送</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//关闭输入输出流</span></span><br><span class="line">    out.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的客户端套接字:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建客户端套接字</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(String serverIp,<span class="keyword">int</span> port);</span><br><span class="line"><span class="comment">//获取输入输出流（一般来说客户端都是会先获取输出流发送消息到服务器，服务器返回消息，客户端使用输入流获取）</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="comment">//进行消息的发送与接收,可以使用死循环，在循环使用特殊字符串之类的东西退出</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//flag;</span></span><br><span class="line">    <span class="comment">//发送和接受</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭输入输出流</span></span><br><span class="line">out.close();</span><br><span class="line">in.close();</span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/tree/master/java/socket" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>java8-lambda表达式</title>
    <url>/2018/01/04/java8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>测试环境 JDK 10 ，JUnit4</p>
<h1 id="如何使用-lambda-表达式"><a href="#如何使用-lambda-表达式" class="headerlink" title="如何使用 lambda 表达式"></a>如何使用 lambda 表达式</h1><ol>
<li>定义一个只含有一个抽象方法的接口 AbstractFuncOfSingle (只能是接口)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFuncOfSingle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入两个int类型的参数，返回一个类型的参数</p>
<ol start="2">
<li>定义一个方法，传入参数为 AbstractFuncOfSingle</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callAbstractFuncOfSingle</span><span class="params">(AbstractFuncOfSingle singleFunc, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = singleFunc.print(a, b);</span><br><span class="line">	System.out.println(result * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法中将方法参数 a，b 作为参数传入 <code>AbstractFuncOfSingle.print()</code> 方法，并使用 result 接收返回参数然后打印 </p>
<ol start="3">
<li>调用上述方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAbstractFuncOfSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line">	callAbstractFuncOfSingle((a, b)-&gt;&#123;</span><br><span class="line">		System.out.println(a + b);</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;, <span class="number">10</span>, <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 lambda 表达式创建一个内部类，打印 a + b 的和并返回 a + b 和</p>
<blockquote>
<p>如果接口的抽象方法具有多个参数，那么 lambda 的传入参数个数也要一一对应，<br>如果抽象方法具有返回值，在 lambda 表达式中也要有返回值，否则可以省略 return 语句<br>注意：lambda 表达式的参数类型和返回类型要和抽象方法的参数类型和返回类型相同</p>
</blockquote>
<h1 id="lambda-表达式和匿名内部类"><a href="#lambda-表达式和匿名内部类" class="headerlink" title="lambda 表达式和匿名内部类"></a>lambda 表达式和匿名内部类</h1><p>lambda 表达式是匿名内部类的一种简化形式，lambda 表达式只能书写于只有一个抽象方法的接口，匿名内部类可以书写具有多个抽象方法的接口和抽象类</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>java8-collect方法</title>
    <url>/2018/01/13/java8-collect%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="collect方法"><a href="#collect方法" class="headerlink" title="collect方法"></a>collect方法</h2><p>collect 方法是 Stream 中一个很重要的方法，通过这个方法可以将流中的数据格式转换为需要的形式，如，List，Set，Map，求流数据的总数，流中数据某条属性的平均值或者其他值，将流中的字符串拼接为一条字符串等。</p>
<p>收集器是 Stream 用于收集某种形式的数据信息，基本上所有的 Stream 的终端操作都可以使用 collect 方法来实现</p>
<h2 id="collect的定义"><a href="#collect的定义" class="headerlink" title="collect的定义"></a>collect的定义</h2><p>collect 方法有两种形式  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法原型<span class="number">1</span></span><br><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">			  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">			  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line">方法原型<span class="number">2</span></span><br><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里主要使用方法原型 2,这个方法原型接收一个实现了 Collector 接口的对象，Collector 接口有五个抽象方法，幸运的是 java8 封装了一些常用的方法供我们使用，这些常用方法封装在 <code>java.util.stream.Collectors</code> 对象中，这个对象含有多个静态方法，用来返回 Collector 对象  </p>
<h1 id="collect-方法示例"><a href="#collect-方法示例" class="headerlink" title="collect 方法示例"></a>collect 方法示例</h1><p>Apple.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">int</span> weight, String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//getter</span></span><br><span class="line">	<span class="comment">//setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Apple&gt; inventory = Arrays.asList(</span><br><span class="line">				<span class="keyword">new</span> Apple(<span class="number">10</span>,<span class="string">"green"</span>),</span><br><span class="line">				<span class="keyword">new</span> Apple(<span class="number">20</span>,<span class="string">"red"</span>),</span><br><span class="line">				<span class="keyword">new</span> Apple(<span class="number">12</span>,<span class="string">"red"</span>),</span><br><span class="line">				<span class="keyword">new</span> Apple(<span class="number">12</span>,<span class="string">"red"</span>),</span><br><span class="line">				<span class="keyword">new</span> Apple(<span class="number">25</span>,<span class="string">"green"</span>));</span><br><span class="line">		<span class="comment">//返回重量最重的苹果</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------返回重量最重的苹果----------------"</span>);</span><br><span class="line">		Optional&lt;Apple&gt; heaviestApple = inventory.stream().collect(Collectors.maxBy(Comparator.comparing(Apple::getWeight)));</span><br><span class="line">		System.out.println(heaviestApple);</span><br><span class="line">		<span class="comment">//返回重量最轻的苹果</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------返回重量最轻的苹果----------------"</span>);</span><br><span class="line">		Optional&lt;Apple&gt; lightestApple = inventory.stream().collect(Collectors.minBy(Comparator.comparing(Apple::getWeight)));</span><br><span class="line">		System.out.println(lightestApple);</span><br><span class="line">		<span class="comment">//返回苹果的总重量</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------返回苹果的总重量----------------"</span>);</span><br><span class="line">		<span class="keyword">int</span> sumInt = inventory.stream().collect(Collectors.summingInt(Apple::getWeight));</span><br><span class="line">		System.out.println(sumInt);</span><br><span class="line">		<span class="comment">//使用Collectors.averagingInt方法求苹果的平均重量</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------求苹果的平均重量-----------------"</span>);</span><br><span class="line">		<span class="keyword">double</span> averageWeight = inventory.stream().collect(Collectors.averagingDouble(Apple::getWeight));</span><br><span class="line">		System.out.println(averageWeight);</span><br><span class="line">		<span class="comment">//返回苹果的重量的各个数据</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------返回苹果重量的各个数据属性-----------------"</span>);</span><br><span class="line">		IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight));</span><br><span class="line">		System.out.println(intSummartStatistics);</span><br><span class="line">		<span class="comment">//将所有苹果颜色拼接为一个字符串</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------将所有苹果颜色拼接为一个字符串-----------------"</span>);</span><br><span class="line">		<span class="comment">//joining会自动将流中的数据拼接为字符串，在处理时需要保证流中的数据都是字符串</span></span><br><span class="line">		String appleColors = inventory.stream()</span><br><span class="line">			.map(Apple::getColor)	<span class="comment">//将流中的apple转换为apple的颜色</span></span><br><span class="line">			.collect(Collectors.joining(<span class="comment">/*将每一个颜色后面加上一个空格*/</span><span class="string">" "</span>));</span><br><span class="line">		System.out.println(appleColors);</span><br><span class="line">		<span class="comment">//返回苹果数量</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------返回苹果的总数量-----------------"</span>);</span><br><span class="line">		Long count = inventory.stream().collect(Collectors.counting());</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		<span class="comment">//分组</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------将苹果按照苹果颜色进行分组----------------"</span>);</span><br><span class="line">		Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor));</span><br><span class="line">		System.out.println(appleColorMap);</span><br><span class="line">		System.out.println(<span class="string">"-------------------将苹果按照苹果颜色和重量进行分组 	----------------"</span>);</span><br><span class="line">		System.out.println(inventory.stream().collect(Collectors.groupingBy(Apple::getColor,</span><br><span class="line">				Collectors.groupingBy(apple -&gt; &#123;</span><br><span class="line">					<span class="keyword">if</span>(apple.getWeight() &gt; <span class="number">10</span> &amp;&amp; apple.getWeight() &lt; <span class="number">20</span>) <span class="keyword">return</span> <span class="string">"一般"</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(apple.getWeight() &gt;= <span class="number">20</span> ) <span class="keyword">return</span> <span class="string">"很重"</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"轻"</span>;</span><br><span class="line">				&#125;))));</span><br><span class="line">		<span class="comment">//收集每个颜色的苹果有多少个</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------收集每个颜色的苹果有多少个----------------"</span>);</span><br><span class="line">		Map&lt;String, Long&gt; colorCount = inventory.stream().collect(Collectors.groupingBy(Apple::getColor,Collectors.counting()));</span><br><span class="line">		System.out.println(colorCount);</span><br><span class="line">		<span class="comment">//分区</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------根据苹果颜色进行分区----------------"</span>);</span><br><span class="line">		Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals(<span class="string">"red"</span>)));</span><br><span class="line">		System.out.println(colorPartition);</span><br><span class="line">		<span class="comment">//归约</span></span><br><span class="line">		System.out.println(<span class="string">"-------------------归约操作----------------"</span>);</span><br><span class="line">		System.out.println(inventory.stream().collect(Collectors.reducing(<span class="number">0</span>,Apple::getWeight,(a,b) -&gt; a + b)));</span><br><span class="line">		System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing((a,b) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">		&#125;)));</span><br><span class="line">		System.out.println(inventory.stream().map(Apple::getWeight).collect(Collectors.reducing(<span class="number">100</span>,(a,b) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">		&#125;)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了大多数 Collectors 的方法，还有一些类型的方法,如: averagingDouble,averagingInt,averagingLong 都是相同的。</p>
<p>Collectors 中的方法大致分为分组，分区，容器（返回list，set，map），简单的数值计算和其他</p>
<p>其中分组和分区是有区别的，分区可以看做是分组的特殊形式，分区只会有两个区别满足条件的（true）和不满足条件的（false），不管是分区还是分组，都可以再分,分组是根据返回的条件进行分组  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Apple&gt;&gt; appleColorMap = inventory.stream().collect(Collectors.groupingBy(Apple::getColor));</span><br></pre></td></tr></table></figure>
<p>这里就是根据苹果的颜色进行分组，map 中只会有两个主键，red 或者 green。如果将条件改为 Apple::getWeight，那么主键就会有 10,20,12,25，因为有两个重量为 12 的苹果，这两个苹果就会分在一组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean,List&lt;Apple&gt;&gt; colorPartition = inventory.stream().collect(Collectors.partitioningBy(apple -&gt; apple.getColor().equals(<span class="string">"red"</span>)));</span><br></pre></td></tr></table></figure>
<p>这里根据苹果颜色是不是红色进行分区，只会有两个主键，true 或者 false，true 分区里的苹果都是红色的，false 分区里的值都不是红色的，但是 partitioningBy 里面可以传第二个参数，可以对分区里面再进行<code>收集</code>（collect方法）操作</p>
<p>容器可以为三种，List，Set，Map 容器，只需要调用 Collectors.toXxxx() 方法就可以将流最后组装成一个容易</p>
<p>简单的数值计算可以直接通过流计算得出，例如 Stream.max() 方法和 Stream.collect(Collectors.maxBy()) 方法是相同的，在某些方面，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntSummaryStatistics intSummartStatistics = inventory.stream().collect(Collectors.summarizingInt(Apple::getWeight));</span><br></pre></td></tr></table></figure>
<p>可以返回多种数据的不同运算结果，还是很方便的</p>
<p>collect 方法接收一个 Collector 对象，而大多数的 Collector 对象都可以通过 Collectors 对象的静态工厂方法获取，如果有需要可以查阅手册</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>java8-使用流</title>
    <url>/2018/01/12/java8-%E4%BD%BF%E7%94%A8%E6%B5%81/</url>
    <content><![CDATA[<h1 id="流介绍"><a href="#流介绍" class="headerlink" title="流介绍"></a>流介绍</h1><p>流是java API的新成员，他允许你以声明的方式处理数据集合（通过查询语句，而不是临时编写一个实现）</p>
<h1 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h1><p>集合是流最容易上手的方式，Java8 中的集合支持一个新的stream方法，他会放回一个流对象（接口定义在java.util.stream.Stream）中  </p>
<p>使用流可以完成什么事？他可以让我们以一种流水线的方法处理集合数据  </p>
<p>像我们前面处理苹果集合时那样，可以实现一个方法来收集或处理某些数据，比如过滤颜色不是红色的苹果，收集苹果的重量列表，但是每一次都需要调用一个方法，流为我们处理这种“一系列”数据提供了一些方法，可以像工厂流水线的方法对流数据进行处理  </p>
<p>比如要收集颜色是红色苹果的重量集合，可以想这样写</p>
<pre><code>inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).map(Apple::getWeight).forEach(System.out::println);
</code></pre><p>这里先通过方法stream()生成一个流对象，再使用filter方法过滤掉颜色不是红色的苹果，接着通过map将所有颜色是红色的苹果的重量返回成一个<code>数值流</code>也就是剩下苹果重量的集合，接着调用forEach方法打印剩下苹果的重量。可以读作先过滤掉颜色不是红色的苹果，接着返回所有苹果重量的集合，然后打印<br>如果使用上一节自定义方法实现这些操作书写格式如下:</p>
<pre><code>inventory = filter(inventory,apple -&gt; apple.getColor().equals(&quot;red&quot;));
List&lt;Integer&gt; weights = map(inventory,Apple::getWeight);
forEach(weights, System.out::println);
</code></pre><p>可以看见流的可读性以及书写性都要高于自定义实现</p>
<h1 id="流方法"><a href="#流方法" class="headerlink" title="流方法"></a>流方法</h1><p>流的方法分为两类，一类是中间操作，一类是终端操作，中间操作是对流完成操作之后还会返回一个流对象，而终端操作的返回结果是任何不是流的值，前面的filter，map就是中间操作，forEach就是终端操作</p>
<h2 id="使用流方法对苹果库存进行操作"><a href="#使用流方法对苹果库存进行操作" class="headerlink" title="使用流方法对苹果库存进行操作"></a>使用流方法对苹果库存进行操作</h2><ol>
<li><p>使用forEach打印数据</p>
<pre><code>inventory.stream().forEach(System.out::println);
</code></pre></li>
<li><p>筛选颜色为红色的苹果</p>
<pre><code>inventory.stream().filter(apple -&gt; apple.getColor().equals(&quot;red&quot;)).forEach(System.out::println);
</code></pre></li>
<li><p>对苹果颜色进行排序，如果个颜色相同，根据重量大小由小到大排序</p>
<pre><code>Comparator&lt;Apple&gt; colorSort = (a1,a2) -&gt; a1.getColor().compareTo(a2.getColor());
Comparator&lt;Apple&gt; weightSort = (a1,a2) -&gt; a1.getWeight() - a2.getWeight();
inventory.stream().sorted(colorSort.thenComparing(weightSort)).forEach(System.out::println);
</code></pre></li>
<li><p>去除颜色和重量相同的苹果</p>
<pre><code>inventory.stream().distinct().forEach(System.out::println);
</code></pre></li>
<li><p>只获取前三个苹果</p>
<pre><code>inventory.stream().limit(3).forEach(System.out::println);
</code></pre></li>
<li><p>跳过前面两个苹果，只获取后面三个</p>
<pre><code>inventory.stream().skip(2).forEach(System.out::println);
</code></pre></li>
<li><p>不要第一个苹果也不要最后一个苹果</p>
<pre><code>inventory.stream().skip(1).limit(inventory.size() - 2).forEach(System.out::println);
</code></pre></li>
<li><p>将所有苹果的重量加10</p>
<pre><code>inventory.stream().peek(apple -&gt; apple.setWeight(apple.getWeight() + 10)).forEach(System.out::println);
</code></pre></li>
<li><p>查看有没有重量是20,颜色是红色的苹果</p>
<pre><code>System.out.println(inventory.stream().anyMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;)));
</code></pre></li>
<li><p>查看是不是所有苹果的重量是20,颜色是红色</p>
<pre><code>System.out.println(inventory.stream().allMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;)));
</code></pre></li>
<li><p>查看是不是没有苹果是红色的</p>
<pre><code>System.out.println(inventory.stream().noneMatch(apple -&gt; apple.getColor().equals(&quot;red&quot;)));
</code></pre></li>
<li><p>查看第一个苹果</p>
<pre><code>System.out.println(inventory.stream().findFirst());
</code></pre></li>
<li><p>返回苹果的总重量</p>
<pre><code>System.out.println(inventory.stream().map(Apple::getWeight).reduce(0, (a,b) -&gt; (a + b)));
</code></pre></li>
<li><p>返回苹果的最小重量</p>
<pre><code>System.out.println(inventory.stream().map(Apple::getWeight).min((n1,n2) -&gt; n1 - n2));
</code></pre></li>
<li><p>返回苹果的最大重量</p>
<pre><code>System.out.println(inventory.stream().map(Apple::getWeight).max((n1,n2) -&gt; n1 - n2));
</code></pre></li>
</ol>
<h2 id="流的终端操作"><a href="#流的终端操作" class="headerlink" title="流的终端操作"></a>流的终端操作</h2><pre><code>    方法                                                                                                            作用
boolean allMatch(Predicate&lt;? super T&gt; predicate)                                                    如果流对象都可以匹配谓词，返回true，否则返回false
boolean anyMatch(Predicate&lt;? super T&gt; predicate)                                                    如果流对象中有一个或多个匹配谓词，返回true，否则返回false
boolean noneMatch(Predicate&lt;? super T&gt; predicate)                                                    如果流对象中任何一个都没有匹配谓词，返回true，否则返回false
Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)                                                    自定义比较方法，返回流对象中比较方法比较出来的最大值
Oprional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)                                                    自定义比较方法，返回流对象中比较方法比较出来的最小值
Optional&lt;T&gt; findAny()                                                                                未知
Optional&lt;T&gt; findFirst()                                                                                返回流对象中的第一个值
long count()                                                                                        返回流中数据的个数
&lt;R,A&gt; R collect(Collecotr&lt;? super T,A,R&gt; collector)                                                    未知
&lt;R&gt; R collecot(Supplier&lt;R&gt; supplier,BiConsumer&lt;R,? super T&gt; accumulator,BiConsumer&lt;R,R&gt; combiner)    未知
void forEach(Consumer&lt;? super T&gt; action)                                                            未知
void forEachOrDered(Consumer&lt;? super T&gt; action)                                                        未知
Oprional&lt;T&gt; reduce&lt;T identity,BinaryOperator&lt;T&gt; accumulator)                                        未知
&lt;U&gt; U reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)            未知
Object[] toArray()                                                                                    未知
&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)                                                            未知
</code></pre><h2 id="流的中间操作"><a href="#流的中间操作" class="headerlink" title="流的中间操作"></a>流的中间操作</h2><pre><code>        方法                                                                                                            作用
    distinct()                                                            去重，流中的对象需要实现equlas方法
    filter(Predicate&lt;? super T&gt; predicate)                                按照规则过滤，满足规则的留下，不满足的去掉
    limit(long maxSize)                                                    返回数据的最大个数，10表示返回10个数据，5表示返回5个
    map(Function&lt;? super T,? extends R&gt; mapper)                            将每个流对象作为函数的参数，并且将返回值填充流对象
    flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)    将每个流对象作为函数的参数，但是只返回一个流对象    
    peek(Consumer&lt;? super T&gt; action)                                    可以在流处理时对每个流数据进行操作，并返回Stream对象
    skip(long n)                                                        跳过n个数据，n等于10,表示跳过前面10个数据，和limit方法一起使用效果更好
    sorted()                                                            默认排序，排序类需要实现默认排序接口
    sorted(Comparator&lt;? super T&gt; comparator)                            使用自定义排序对流数据进行排序
值得注意的是flatMap方法，这个方法和map方法不同，map方法会将每一个流对象都作用于Function&lt;? super T,? extends R&gt;返回一个R对象，flatMap方法也会将所有的流对象作用于Function的方法，但是只会返回一个`流对象`，这个方法可以用作一个流中的对象的属性是集合，并且需要将所有流对象为集合的属性收集起来的情况，比如收集几个字符串中所有不重复的字符。
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>java8-函数式接口</title>
    <url>/2018/01/05/java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在上一次使用自定义的函数接口来使用lambda表达式，每一个lambda都要自定义一个已知的接口来实现，这样比较麻烦，如果可以使用通用的函数式接口，那么会方便很多。幸运的是java8中新增了一些通用的函数式接口供我们使用。下面就来看看吧。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口 —《java核心技术卷I基础知识第10版》<br>一言蔽之，只有一个抽象方法的接口称为函数式接口 —《java8实战》</p>
<p>java8提供了一系列通用的函数式接口，位于java.util.function包中<br><img src="函数式接口.png" alt="函数式接口图片"><br>    可以看见这个包中只有含有接口，没有任何的抽象类，类，这些接口都需于函数接口，不要慌张，这些接口大部分表达的意思相同，只有少量的区别</p>
<h2 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h2><p>函数式接口的抽象方法的签名基本上就是lambda表达式的签名。我们将这种抽象方法叫做函数描述符<br>lambda表达式的参数和返回值都要和函数式接口的签名对应，比如说函数式接口ApplePredicate的签名就是接收一个Apple类型的参数返回一个boolean类型的参数<br>所以基本上满足接收一个Apple类型返回一个boolean类型的lambda表达式都可以看作是ApplePredicate的实现<br>    下面来介绍几个函数式接口</p>
<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>翻译过来为消费者，接收一个参数没有返回值。<br>源码接口如下：</p>
<pre><code>public interface Consumer&lt;T&gt; {
    void accept(T t);
}
</code></pre><h3 id="使用Consumer来实现一个List的遍厉"><a href="#使用Consumer来实现一个List的遍厉" class="headerlink" title="使用Consumer来实现一个List的遍厉"></a>使用Consumer来实现一个List的遍厉</h3><pre><code>public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) {
    for(T t : inventory) {
        consumer.accept(t);
    }
}
//使用forEach遍历列表
forEach(redApples,apple -&gt; System.out.println(apple));
</code></pre><h3 id="其他Consumer系列接口"><a href="#其他Consumer系列接口" class="headerlink" title="其他Consumer系列接口"></a>其他Consumer系列接口</h3><blockquote>
<pre><code> 接口                                    抽象方法  
DoubleConsumer                     void accept(double value);  
IntConsumer                        void accept(int value);  
LongConsumer                       void accept(long value);  
ObjDoubleConsumer&lt;T&gt;               void accept(T t,double value);  
ObjIntConsumer&lt;T&gt;                  void accept(T t,int value);  
ObjLongConsumer&lt;T&gt;                 void accept(T t,int long value);  
BiConsumer&lt;T,U&gt;                    void accept(T t,U u);  
</code></pre></blockquote>
<h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>谓词，用来描述或判断客体性质等(百度百科),这里用来表示判断<br>    Predicate接口有5个方法，包括4个默认方法，1个抽象方法，默认方法以后再说，这里主要关注抽现方法<br>    接口源码如下,接收一个泛型参数，返回一个boolean型数据，至于根据什么返回，怎么判断交给用户来实现</p>
<pre><code>public interface Predicate&lt;T&gt;{
    boolean test(T t);
}
</code></pre><p>使用Predicate来实现过滤</p>
<pre><code>public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Predicate&lt;T&gt; pred){
    List&lt;T&gt; result = new ArrayList&lt;&gt;();
    for(T t : inventory)
        if(pred.test(t))
            result.add(t);
    return result;
}
</code></pre><p>筛选红色苹果</p>
<pre><code>List&lt;Apple&gt; redApples = filter(inventory,(Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;));
forEach(redApples,apple -&gt; System.out.println(apple));
</code></pre><h3 id="其他Predicate系列接口"><a href="#其他Predicate系列接口" class="headerlink" title="其他Predicate系列接口"></a>其他Predicate系列接口</h3><pre><code>    接口                                抽象方法
DoublePredicate                    boolean test(double value);
IntPredicate                       boolean test(int value);
LongPredicate                      boolean  test(long value);
BiPredicate&lt;T,U&gt;                   boolean test(T t,U u);
</code></pre><p>DoublePredicate,LongPredicate,IntPredicate分别是用来判断double,long,int类型，由于double,long,int类型在使用泛型时会有一个自动装箱拆箱的过程，这是为了提高效率实现的三个类,使用上和Predicate没有什么区别</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>函数，接收一个参数返回一个值</p>
<pre><code>public interface Function&lt;T,R&gt;{
    R apply(T t);
}
</code></pre><p>使用Function来实现遍历列表，并对列表进行某种操作，操作后返回一个值</p>
<pre><code>public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){
    List&lt;R&gt; result = new ArrayList&lt;&gt;();
    for(T t : inventory)
        result.add(func.apply(t));
    return result;
}
</code></pre><p>使用map来将列表中的所有苹果的重量返回并用列表返回</p>
<pre><code>List&lt;Integer&gt; weights = map(inventory,(Apple apple) -&gt; apple.getWeight());
</code></pre><h3 id="其他Function系列接口"><a href="#其他Function系列接口" class="headerlink" title="其他Function系列接口"></a>其他Function系列接口</h3><pre><code>    接口                            抽象方法
DoubleFunction&lt;R&gt;                    R apply(double value);
IntFunction&lt;R&gt;                       R apply(int value);
LongFunction&lt;R&gt;                      R apply(long value);
ToDoubleFunction&lt;T&gt;                  double apply(T value);
ToIntFunction&lt;T&gt;                     int apply(T value);
ToLongFunction&lt;T&gt;                    long apply(T value);
BiFunction&lt;T,U,R&gt;                    R apply(T t,U u);
ToDoubleBiFunction&lt;T,U&gt;              double apply(T t,U u);
ToIntBiFunction&lt;T,U&gt;                 int apply(T t,U u);
ToLongBuFunction&lt;T,U&gt;                long apply(T t,U u);
</code></pre><p>可以看见大多数接口都是为了解决基本类型的封箱拆箱进行优化的接口</p>
<h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><pre><code>供应商，没有参数，只有返回值。少有使用，这里只提供接口
    接口                            抽象方法
Supplier&lt;T&gt;                        T get();
BooleanSupplier                    boolean get();
DoubleSupplier                    double get();
IntSupplier                        int get();
LongSupplier                    long get();
</code></pre><h2 id="其他函数式接口"><a href="#其他函数式接口" class="headerlink" title="其他函数式接口"></a>其他函数式接口</h2><p>java.util.function包中还有几个使用Operator结尾的接口，现在还不太明白如何使用，以后再加。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>java8-复合lambda表达式</title>
    <url>/2018/01/11/java8-%E5%A4%8D%E5%90%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>java8中的函数式借口提供了允许你进行复合的方法，可以把多个lambda表达式复合成更复杂的表达式,就好像与操作(and)，或操作(or)，非操作(not)，以及组合操作</p>
<h1 id="Predicate系列的组合操作"><a href="#Predicate系列的组合操作" class="headerlink" title="Predicate系列的组合操作"></a>Predicate系列的组合操作</h1><pre><code>接口                        相关方法
Predicate&lt;T&gt;            Predicate&lt;T&gt; negate()
                        Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)
                        Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)

                        DoublePredicate negate()
DoublePredicate            DoublePredicate and(DoublePredicate other)
                        DoublePredicate or(DoublePredicate other)

                        IntPredicate negate()
IntPredicate            IntPredicate and(IntPredicate other)
                        IntPredicate or(IntPredicate other)

                        LongPredicate negate()
LongPredicate            LongPredicate and(LongPredicate other)
                        LongPredicate or(LongPredicate other)

                        BiPredicate&lt;T,U&gt; negate()
BiPredicate&lt;T,U&gt;        BiPredicate&lt;T,U&gt; and(BiPredicate&lt;? super T,? super U&gt; other)
                        BiPredicate&lt;T,U&gt; or(BiPredicate&lt;? super T,? super U&gt; other)
</code></pre><p>Predicate系列的每个借口都含有and,or,not操作，可以和其他相同的借口进行组合<br>对于苹果类，根据苹果的颜色和重量筛选符合要求的苹果可以有</p>
<pre><code>//筛选颜色为红色的苹果
Predicate&lt;Apple&gt; redApple = (Apple apple) -&gt; apple.getColor().equals(&quot;red&quot;);
//筛选苹果重量大于15的苹果
Predicate&lt;Apple&gt; weightApple = apple -&gt; apple.getWeight() &gt; 15;
//对苹果的颜色和重量筛选进行复合，筛选出即是红色重量有大于15的苹果
List&lt;Apple&gt; filterApples = filter(inventory,redApple.and(weightApple));

//筛选出是红色或者重量大于15的苹果
filterApples = filter(inventory,redApple.or(weightApple));

//筛选出既不是颜色既不是红色重量也不大于15的苹果
filterApples = filter(inventory,redApple.negate().or(weightApple.negate()));
</code></pre><h1 id="Function系列的组合操作"><a href="#Function系列的组合操作" class="headerlink" title="Function系列的组合操作"></a>Function系列的组合操作</h1><pre><code>接口                        相关方法
Function&lt;T,R&gt;            Function&lt;T,V&gt; addThen(Function&lt;? super R,? extends V&gt; after)
                        Function&lt;V,R&gt; compose(Function&lt;? super V,? extends T&gt; before)

BiFunction&lt;T,U,R&gt;        BiFunction&lt;T,U,V&gt; addThen(Function&lt;? super R,? extends V&gt; after)
</code></pre><p>Function系列的接口只有Function&lt;T,R&gt;和BiFunction&lt;T,U,R&gt;可以进行复合操作<br>    Function的意思是函数，作为函数，具有参数和返回值，类似于f(x) = x + 1,<br>    那么Function&lt;T,V&gt;的addThen方法可以理解为将我的返回值作为别的函数的参数，在别的函数中进行函数运算。<br>    如果说有两个函数 f(x) = x + 1 和 g(y) = y + 2，那么addThen可以将f(x)的返回值作为g(x)的参数传递进去，类似于g(f(x)) = f(x) + 2 = (x + 1) + 2这种<br>    同样compose方法可以将别的函数的返回值作为自己的参数进行函数运算  </p>
<p>BiFunction&lt;T,U,R&gt;和Function&lt;T,R&gt;不同的是，他具有三个泛型参数，以及他的addThen方法接收的是一个Function&lt;? super V,? extends T&gt;对象<br>    同样也是将BiFunction的运算结果作为Function的参数，返回Function的运算结果</p>
<p>使用Function接口实现为苹果的重量加20，并返回一个列表</p>
<pre><code>//获取苹果的重量
Function&lt;Apple,Integer&gt; getWeight = Apple::getWeight;
//将一个数字加上20,在这里这个数字表示重量
Function&lt;Integer,Integer&gt; addWeight = weight -&gt; weight + 20;

//使用Function的addThen方法将所有苹果的重量加上20并返回一个列表
List&lt;Integer&gt; weights = map(inventory,getWeight.andThen(addWeight));
//使用Function的compose方法将所有苹果的重量加上20并返回一个列表
weights = map(inventory,addWeight.compose(getWeight));
</code></pre><h1 id="Consumer系列接口"><a href="#Consumer系列接口" class="headerlink" title="Consumer系列接口"></a>Consumer系列接口</h1><pre><code>接口                        相关方法
Consumer&lt;T&gt;                Consumer&lt;T&gt; addThen(Consumer&lt;? super T&gt; after)
DoubleConsumer            DoubleConsumer addThen(DoubleConsumer after)
IntConsumer                IntConsumer addThen(IntConsumer after)
LongConsuemr            LongConsumer addThen(LongConsumer after)
BiConsumer&lt;T,U&gt;            BiConsumer&lt;T,U&gt; addThen(BiConsumer&lt;? super T,? super U&gt; after)
</code></pre><p>Consumer系列的接口只接收一个泛型参数的都可以使用addThen方法，接收两个参数的只有BiConsumer接口可以使用addThen方法<br>    关于addThen方法，很显然，在经过当前的Consumer对象的处理之后，可以继续被某个Consumer对象处理<br>    使用Consumer将苹果的重量在原有的基础上乘2再加上10  </p>
<pre><code>//将苹果的重量乘2
Consumer&lt;Apple&gt; two = apple -&gt; apple.setWeight(apple.getWeight() * 2); 
//将苹果的重量加10
Consumer&lt;Apple&gt; add = apple -&gt; apple.setWeight(apple.getWeight() + 10);
//使用组合将苹果的重量先乘2再加10
forEach(inventory,two.andThen(add));
</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>java8-方法引用</title>
    <url>/2018/01/07/java8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用"></a>什么是方法引用</h1><p>方法引用是lambd表达式的一种特殊形式。看起来更易读更自然</p>
<p>如果想要对苹果的重量进行排序我们可以这样写:</p>
<pre><code>inventory.sort((a1,a2) -&gt; a1.getWeight() - a2.getWeight());
</code></pre><p>使用方法引用之后是这样的</p>
<pre><code>inventory.sort(Apple::getWeight);
</code></pre><h1 id="方法引用的语法格式"><a href="#方法引用的语法格式" class="headerlink" title="方法引用的语法格式"></a>方法引用的语法格式</h1><ol>
<li>指向静态方法的引用<pre><code>Class::staticMethod
</code></pre></li>
<li>指向现有对象的实例方法的方法引用<pre><code>object::instanceMethod
</code></pre></li>
<li>指向任意类型实例方法的方法引用<pre><code>Class::instanceMethod
</code></pre></li>
</ol>
<h2 id="语法简述"><a href="#语法简述" class="headerlink" title="语法简述"></a>语法简述</h2><h3 id="指向静态方法的引用"><a href="#指向静态方法的引用" class="headerlink" title="指向静态方法的引用"></a>指向静态方法的引用</h3><p>类的静态方法必须满足函数描述符，也就是Class.staticMethod的参数和返回值要和函数描述符一致</p>
<h4 id="对于Function-lt-Integer-Integer-gt-function-Class-staticMethod"><a href="#对于Function-lt-Integer-Integer-gt-function-Class-staticMethod" class="headerlink" title="对于Function&lt;Integer,Integer&gt; function = Class::staticMethod;"></a>对于Function&lt;Integer,Integer&gt; function = Class::staticMethod;</h4><p>Class的staticMethod的静态方法定义应该是:</p>
<pre><code>public static intstaticMethod(int number){
    //一个返回int类型的代码块
}
</code></pre><h4 id="对于Consumer-consumer-Class-staticMethod"><a href="#对于Consumer-consumer-Class-staticMethod" class="headerlink" title="对于Consumer consumer = Class:staticMethod;"></a>对于Consumer<integer> consumer = Class:staticMethod;</integer></h4><p>Class的staticMethod的静态方法定义应该是:</p>
<pre><code>public static void staticMethod(int number){
    //没有返回值的代码块
}
</code></pre><h4 id="对于Predicate-pred-Class-staticMethod"><a href="#对于Predicate-pred-Class-staticMethod" class="headerlink" title="对于Predicate pred = Class::staticMethod;"></a>对于Predicate<integer> pred = Class::staticMethod;</integer></h4><p>Class.staticMethod的静态方法定义应该是:</p>
<pre><code>public static boolean staticMethod(int number){
    //返回boolean类型的代码块
}
</code></pre><h4 id="对于Supplier-supplier-Class-staticMethod"><a href="#对于Supplier-supplier-Class-staticMethod" class="headerlink" title="对于Supplier supplier = Class::staticMethod;"></a>对于Supplier<integer> supplier = Class::staticMethod;</integer></h4><p>Class.staticMethod的静态方法定义应该是:</p>
<pre><code>public static int staticMethod(){
    //返回int类型的代码块
}
</code></pre><h3 id="指向现有对象的实例方法的方法引用"><a href="#指向现有对象的实例方法的方法引用" class="headerlink" title="指向现有对象的实例方法的方法引用"></a>指向现有对象的实例方法的方法引用</h3><p>类的实例方法必须满足函数描述符，也就是对象调用的方法的参数和返回值要和函数描述法一致</p>
<h4 id="对于Function-lt-Class-Integer-gt-function-object-instanceMethod"><a href="#对于Function-lt-Class-Integer-gt-function-object-instanceMethod" class="headerlink" title="对于Function&lt;Class,Integer&gt; function = object::instanceMethod;"></a>对于Function&lt;Class,Integer&gt; function = object::instanceMethod;</h4><p>Class的实例方法定义应该是:</p>
<pre><code>public int instanceMethod(){
    //返回int类型的代码块
}
</code></pre><p>如果是BiFunction&lt;Class,Integer,Integer&gt; function = object::instanceMethod;<br>Class的实例方法定义应该是:</p>
<pre><code>public int instacneMethod(int number){
    //返回int类型的代码块
}
</code></pre><p>下同</p>
<h4 id="对于Consumer-lt-Class-Integer-gt-consumer-object-instanceMethod"><a href="#对于Consumer-lt-Class-Integer-gt-consumer-object-instanceMethod" class="headerlink" title="对于Consumer&lt;Class,Integer&gt; consumer = object::instanceMethod;"></a>对于Consumer&lt;Class,Integer&gt; consumer = object::instanceMethod;</h4><p>Class的实例方法定义应该是:</p>
<pre><code>public void instacneMethod(int number){
    //没有返回值的代码块
}
</code></pre><h4 id="对于Predicate-predicate-object-instanceMethod"><a href="#对于Predicate-predicate-object-instanceMethod" class="headerlink" title="对于Predicate predicate = object::instanceMethod;"></a>对于Predicate<class> predicate = object::instanceMethod;</class></h4><p>Class的实例方法定义应该是:</p>
<pre><code>public boolean instanceMethod(){
    //返回boolean类型的代码块
}
</code></pre><h4 id="对于Suplier-supplier-object-instanceMethod"><a href="#对于Suplier-supplier-object-instanceMethod" class="headerlink" title="对于Suplier supplier = object::instanceMethod;"></a>对于Suplier<integer> supplier = object::instanceMethod;</integer></h4><p>Class的实例方法定义应该是:</p>
<pre><code>public int instanceMethod(){
    //返回int类型的代码块

对于第三种格式，函数描述符至少含有一个参数，也就是说必须有一个参数用来调用方法
</code></pre><h4 id="对于Function-lt-Class-Integer-gt-function-Class-instanceMethod"><a href="#对于Function-lt-Class-Integer-gt-function-Class-instanceMethod" class="headerlink" title="对于Function&lt;Class,Integer&gt; function = Class::instanceMethod;"></a>对于Function&lt;Class,Integer&gt; function = Class::instanceMethod;</h4><p>Class的实例方法定义应该是:</p>
<pre><code>public int instanceMethod(){
    //返回int类型的代码块
}
</code></pre><h4 id="对于Function-lt-Class-Integer-Integer-gt-function-Class-instanceMethod"><a href="#对于Function-lt-Class-Integer-Integer-gt-function-Class-instanceMethod" class="headerlink" title="对于Function&lt;Class,Integer,Integer&gt; function = Class::instanceMethod;"></a>对于Function&lt;Class,Integer,Integer&gt; function = Class::instanceMethod;</h4><pre><code>Class的实例方法定义应该是:

public int instanceMethod(int number){
    //返回int类型的代码块
}
</code></pre><h4 id="对于Consumer-consumer-Class-instanceMethod"><a href="#对于Consumer-consumer-Class-instanceMethod" class="headerlink" title="对于Consumer consumer = Class::instanceMethod;"></a>对于Consumer<class> consumer = Class::instanceMethod;</class></h4><p>Class的实例方法定义应该是:</p>
<pre><code>public void instanceMethod(){
    //没有返回值的代码块
}
</code></pre><h4 id="对于Comparator-lt-Class-Class-gt-comparator-Class-instanceMethod"><a href="#对于Comparator-lt-Class-Class-gt-comparator-Class-instanceMethod" class="headerlink" title="对于Comparator&lt;Class,Class&gt; comparator = Class::instanceMethod;"></a>对于Comparator&lt;Class,Class&gt; comparator = Class::instanceMethod;</h4><p>Class的实例方法定义应该是:</p>
<pre><code>public int instanceMethod(Class clazz){
    //比较两个数大小的代码块，最后返回一个数用来表示大于，小于，等于
}
</code></pre><h1 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h1><pre><code>使用方法引用来完成列表苹果的筛选，排序，输出，增加重量，返回对应的苹果重量列表
Apple.java
public class Apple {
    private int weight;
    private String color;
    //getter setter
}
Main.java

public class Main {
    public static void main(String[] args) {
        List&lt;Apple&gt; inventory = Arrays.asList(
                new Apple(10,&quot;green&quot;),
                new Apple(20,&quot;red&quot;),
                new Apple(12,&quot;red&quot;),
                new Apple(25,&quot;green&quot;));
        List&lt;String&gt; strs = Arrays.asList(
                &quot;red&quot;,&quot;green&quot;,&quot;red&quot;,&quot;black&quot;
                );
        //筛选
        List&lt;Apple&gt; redApples = filter(inventory,Apple::getColor,&quot;red&quot;);
        forEach(redApples,System.out::println);

        List&lt;String&gt; red = filter(strs,String::toString,&quot;red&quot;);
        forEach(red,System.out::println);

        //将所有苹果的重量表示为一个列表
        List&lt;Integer&gt; appleWeight = map(inventory,Apple::getWeight);
        forEach(appleWeight,System.out::println);

        //将所有苹果的重量加10
        addWeight(inventory,Apple::getWeight,Apple::setWeight,10);
        forEach(inventory,System.out::println);

        //排序
        inventory.sort(Comparator.comparing(Apple::getColor));
        forEach(inventory,System.out::println);
    }
    public static &lt;T&gt; void forEach(List&lt;T&gt; inventory,Consumer&lt;T&gt; consumer) {
        for(T t : inventory) {
            consumer.accept(t);
        }
    }
    public static &lt;T&gt; void addWeight(List&lt;T&gt; inventory,ToIntFunction&lt;T&gt; func,ObjIntConsumer&lt;T&gt; consumer,int added) {
        for(T t : inventory) {
            consumer.accept(t,func.applyAsInt(t) + added);
        }
    }
    public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; inventory,Function&lt;T,R&gt; func){
        List&lt;R&gt; result = new ArrayList&lt;&gt;();
        for(T t : inventory) {
            result.add(func.apply(t));
        }
        return result;
    }
    public static &lt;T,R&gt; List&lt;T&gt; filter(List&lt;T&gt; inventory,Function&lt;T,R&gt; func,Object obj){
        List&lt;T&gt; result = new ArrayList&lt;&gt;();
        for(T t : inventory) {
            if(func.apply(t).equals(obj)) {
                result.add(t);
            }
        }
        return result;
    }
}
</code></pre><p>可以看见方法引用的可读性是要强于lanbda表达式的，如：<br>    List<apple> redApples = filter(inventory,Apple::getColor,”red”);<br>    可以读作:筛选苹果库存中颜色为红色的苹果<br>    inventory.sort(Comparator.comparing(Apple::getColor));<br>    可以读作:库存根据苹果的颜色进行排序<br>但是方法引用在某些方面的比较复杂的，比如要将所有苹果的重量加10,需要使用两个方法引用<br>    addWeight(inventory,Apple::getWeight,Apple::setWeight,10);  </apple></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>json数据</title>
    <url>/2017/12/16/json%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h1><p>JSON：JavaScript 对象表示法（JavaScript Object Notation）。<br>JSON 是存储和交换文本信息的语法。类似 XML。<br>JSON 比 XML 更小、更快，更易解析。<br>参考<a href="http://www.w3school.com.cn/json/index.asp" target="_blank" rel="noopener">w3school</a></p>
<h1 id="JSON实例"><a href="#JSON实例" class="headerlink" title="JSON实例"></a>JSON实例</h1><pre><code>{
    &quot;employees&quot;: [
        { &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; },
        { &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; },
        { &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; }
    ]
}
</code></pre><h2 id="使用python表示JSON实例"><a href="#使用python表示JSON实例" class="headerlink" title="使用python表示JSON实例"></a>使用python表示JSON实例</h2><pre><code>one = {&quot;firstName&quot;:&quot;Bill&quot;,&quot;lastName&quot;:&quot;Gates&quot;}
two = {&quot;firstName&quot;:&quot;George&quot;,&quot;lastName&quot;:&quot;Bush&quot;}
three = {&quot;firstName&quot;:&quot;Thomas&quot;,&quot;lastName&quot;:&quot;Carter&quot;}
employees = [one,two,three]
o = {&quot;employess&quot;:employees}
</code></pre><h2 id="使用java表示JSON实例"><a href="#使用java表示JSON实例" class="headerlink" title="使用java表示JSON实例"></a>使用java表示JSON实例</h2><pre><code>Map&lt;String,String&gt; one = new HashMap&lt;&gt;();
Map&lt;String,String&gt; two = new HashMap&lt;&gt;();
Map&lt;String,String&gt; three = new HashMap&lt;&gt;();
one.put(&quot;firstName&quot;,&quot;Bill&quot;);
one.put(&quot;lastName&quot;,&quot;Gates&quot;);
two.put(&quot;firstName&quot;,&quot;George&quot;);
two.put(&quot;lastName&quot;,&quot;Bush&quot;);
three.put(&quot;firstName&quot;,&quot;Thomas&quot;);
three.put(&quot;lastName&quot;,&quot;Carter&quot;);
List&lt;Map&lt;String,String&gt;&gt; employees = new LinkedList&lt;&gt;(Arrays.asList(one,two,three));
Map&lt;String,List&lt;Map&lt;String,String&gt;&gt;&gt; o = new HashMap&lt;&gt;();
o.put(&quot;employees&quot;,employees);
</code></pre><p>可以发现JSON并没有什么神奇的地方，只不过是一群人定义的字符床规范格式而已，用的人多了就成了标准</p>
<h2 id="将JSON转换为javascript对象"><a href="#将JSON转换为javascript对象" class="headerlink" title="将JSON转换为javascript对象"></a>将JSON转换为javascript对象</h2><blockquote>
<p>javascript 可以使用内置eval()函数将JSON数据生成原生的javascript对象<br>var obj = eval(“(“ + JSON + “)”);</p>
</blockquote>
<h2 id="JSON值有以下几种"><a href="#JSON值有以下几种" class="headerlink" title="JSON值有以下几种"></a>JSON值有以下几种</h2><blockquote>
<p>数字(整数或浮点数)<br>字符串(双引号中)<br>逻辑值(true或false)<br>数组(在方括号中)<br>对象(在花括号中)<br>null</p>
</blockquote>
<p>使用本地JSON构建javascript对象实例可以在w3school找到，这里给出一个使用java:spring-mvc返回json对象并转换成javascript对象的实例<a href="https://github.com/canxing/spring-mvc-return-object-as-json" target="_blank" rel="noopener">spring-mvc返回JSOn数据参考源码</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 安装---单节点安装</title>
    <url>/2023/04/11/kubernetes%20%E5%AE%89%E8%A3%85---%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="kubernetes-安装—单节点安装"><a href="#kubernetes-安装—单节点安装" class="headerlink" title="kubernetes 安装—单节点安装"></a>kubernetes 安装—单节点安装</h1><ul>
<li><a href="#kubernetes-安装---单节点安装">kubernetes 安装—单节点安装</a><ul>
<li><a href="#前提条件">前提条件</a></li>
<li><a href="#安装步骤">安装步骤</a></li>
<li><a href="#多网卡问题">多网卡问题</a></li>
<li><a href="#附录">附录</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>多块网卡安装 kubernetes 请先看<a href="#多网卡问题">多网卡问题</a></p>
</blockquote>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>Ubuntu Linux 或者 CentOS</p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li><p>参考 <a href="!--￼11--">基础环境准备</a></p>
</li>
<li><p>主节点配置</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --pod-network-cidr=192.168.0.0/16 \</span><br><span class="line">  --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers \</span><br><span class="line">  --ignore-preflight-errors=NumCPU</span><br></pre></td></tr></table></figure>
<p> 这里使用的网络方案为 Calico 因此 <code>--pod-network-cidr</code> 等于  <code>192.168.0.0/16</code> 更多网络方案点击<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">这里</a>和<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">这里</a></p>
<blockquote>
<p>如果计算机 CPU 只有一个，需要加参数来忽略错误 –ignore-preflight-errors=NumCPU</p>
<p>可以通过 –kubernetes-version 指定要安装的 kubernetes 版本，比如 –kubernetes-version v1.14.1</p>
<p>如果没有先拉取启动所需要的镜像，那么因为网络关系，需要指定拉取镜像的仓库地址，需要追加参数 –image-repository，比如 –image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</p>
<p>kubernetes 从 1.10 开始没有开放 10255 端口用于监控，如果需要监控需要配置</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;   <span class="built_in">echo</span> <span class="string">'readOnlyPort: 10255'</span> &gt;&gt; /var/lib/kubelet/config.yaml</span><br><span class="line">&gt;   systemctl restart kubelet</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p> 按照 kubeadm 的要求设置</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p> 安装网络插件</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml</span><br><span class="line">kubectl create -f https://docs.projectcalico.org/manifests/custom-resources.yaml</span><br></pre></td></tr></table></figure>
<p> master 节点参与调度（多节点可选，单节点必选）</p>
<p> kubeadm 安装的 kubernetes 环境默认情况下 Master 节点不会参与调度，想要让 Master 节点参与调度需要使用下面命令</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者通过节点名称让 Master 不参与调度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; kubectl taint nodes &lt;master-node-name&gt; node-role.kubernetes.io/master=:NoSchedule</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>加入集群（可选）</p>
<p> 将一个节点加入集群需要进行<a href="!--￼12--">基础环境准备</a>，之后使用下面命令将节点添加到集群</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm join &lt;master-ip&gt; --token &lt;join-token&gt; --discovery-token-unsafe-skip-ca-verification</span><br></pre></td></tr></table></figure>
<p> <code>&lt;master-ip&gt;</code> Kubernetes 集群 master 节点所在的 ip 地址，例如: 192.168.17.139:6443</p>
<p> <code>&lt;join-token&gt;</code> 为加入 Kubernetes 集群所需要的 token，可以通过 <code>kubeadm token list</code> 查看，如果没有，可以通过 <code>kubeadm token create</code> 创建 token</p>
</li>
<li><p>额外配置（可选）</p>
<p> 上述安装配置无法对集权状态进行监控，如需监控功能需要将 10255 端口添加到配置文件，设置方式如下。配置文件在 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令生效后生成，使用 <code>kubeadm reset</code> 之后该文件会被删除。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'readOnlyPort: 10255'</span> &gt;&gt; /var/lib/kubelet/config.yaml</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="多网卡问题"><a href="#多网卡问题" class="headerlink" title="多网卡问题"></a>多网卡问题</h2><blockquote>
<p>实验环境最好不要使用多网卡机器，容易出现各种问题</p>
</blockquote>
<ol>
<li><p>安装 kubernetes</p>
<p> 在 <code>安装步骤-&gt; 2. 主节点配置</code>中使用 <code>kubeadm init</code> 来安装 kubernetes，在安装过程中，kubeadm 会自动寻找可用的网卡做为 kubernetes 的服务 ip。如果计算机存在多张网卡，那么有可能选择的网卡并不是预期的网卡。为了解决这个问题，kubeadm 提供了 <code>--apiserver-advertise-address</code> 参数来指定网卡的 ip，完整命令如下:</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address &lt;targetIP&gt; --pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure>
<blockquote>
<p> –pod-network-cidr=192.168.0.0/16 为 calico 网络插件指定的网段</p>
</blockquote>
<p> 对于想要加入 kubernetes 集群的节点来，如果有多网卡，也可以使用该参数来指定加入的网卡</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm join &lt;k8s-master-ip&gt; --token &lt;token&gt; --apiserver-advertise-address &lt;targetIP&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络插件选择网卡</p>
<p> 除了 kubernetes 以外，网络插件也需要选择网卡来保证节点间容器的通信，不同的网络插件对于网卡的选择不同，具体请查看实际网络插件的文档。这里以 <code>calico</code> 网络插件为例。<a href="https://docs.projectcalico.org/v3.7/reference/node/configuration#ip-autodetection-methods" target="_blank" rel="noopener">calico 官方文档</a></p>
<p> calico 对于网卡的选择使用的默认策略是 <code>first-found</code>，也就是第一块找到的可用的网卡，如果每个节点选择的网卡对应的 ip 不在同一网段，那么很可能出现某一节点上的 pod ping 不通另一节点上的 pod。</p>
<p> 对于这种情况，可以根据不同方式来自行选择网卡，这里使用的网卡选择策略是 <code>interface</code>，根据正则表达式来选择网卡，不同的网卡选择策略还是看<a href="https://docs.projectcalico.org/v3.7/reference/node/configuration#ip-autodetection-methods" target="_blank" rel="noopener">calico 官方文档</a>。</p>
<p> 在 <code>kube-system</code> 命令空间下，找到 <code>守护进程集(daemonse) calico-node</code>，其中包含两个 container，为 <code>calico-node</code> container 增加两个环境变量 <code>IP_AUTODETECTION_METHOD</code> 和 <code>IP6_AUTODETECTION_METHOD</code>，值为 <code>interface=eth0</code>。保存即可，和下面类似</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="string">....</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">IP_AUTODETECTION_METHOD</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">interface=eth0</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">IP6_AUTODETECTION_METHOD</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">interface=eth0</span></span><br><span class="line"><span class="string">....</span></span><br></pre></td></tr></table></figure>
<p> 这个环境变量的意思是 calico 选择网卡，根据正则表达式去匹配每个节点上网卡名称，找到的第一个网卡就作为 pod 通信的网卡。这里要选择的网卡就是包含 <code>eht0</code> 的网卡。</p>
<p> 与此相反，可以使用 <code>skip-interface</code> 来进行配置要跳过哪些网卡</p>
</li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://docs.projectcalico.org/getting-started/kubernetes/quickstart" target="_blank" rel="noopener">calico 安装指南</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 安装---基础环境准备</title>
    <url>/2023/04/07/kubernetes%20%E5%AE%89%E8%A3%85---%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="kubernetes-安装—基础环境准备"><a href="#kubernetes-安装—基础环境准备" class="headerlink" title="kubernetes 安装—基础环境准备"></a>kubernetes 安装—基础环境准备</h1><ul>
<li><a href="#kubernetes-安装---基础环境准备">kubernetes 安装—基础环境准备</a><ul>
<li><a href="#前提条件">前提条件</a></li>
<li><a href="#环境初始化">环境初始化</a><ul>
<li><a href="#设置仓库源">设置仓库源</a></li>
<li><a href="#系统配置">系统配置</a></li>
<li><a href="#安装-docker">安装 Docker</a></li>
<li><a href="#安装-kubeadm">安装 kubeadm</a></li>
<li><a href="#初始化-kubernetes-设置可选">初始化 Kubernetes 设置（可选）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>Ubuntu Linux 或者 CentOS</p>
<h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><h3 id="设置仓库源"><a href="#设置仓库源" class="headerlink" title="设置仓库源"></a>设置仓库源</h3><p>CentOS 系统在<code>/etc/yum.repos.d/</code>目录下，使用下面命令设置仓库源<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可选的，更换基础源为阿里云源，注意备份同名的镜像源文件</span></span><br><span class="line"><span class="comment"># Centos 7 使用下面命令更换阿里云源</span></span><br><span class="line">curl -o CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="comment"># Centos 8 使用下面命令更新阿里云源</span></span><br><span class="line">curl -o CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line"></span><br><span class="line">curl -o docker-ce.repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum repolist</span><br></pre></td></tr></table></figure></p>
<p>Ubuntu 系统使用下面命令设置仓库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line"></span><br><span class="line">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - </span><br><span class="line"></span><br><span class="line">sudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>
<h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><ol>
<li><p>关闭交换空间（如果有）</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -ri <span class="string">"s/.*.swap.*/#&amp;/"</span> /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用 SELinux（如果有）</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i --follow-symlinks <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/sysconfig/selinux</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙（如果有）</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置内核参数</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'net.bridge.bridge-nf-call-ip6tables = 1'</span> &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'net.bridge.bridge-nf-call-iptables = 1'</span> &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'net.ipv4.ip_forward = 1'</span> &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">modprobe br_netfilter</span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 hostname （单机可选，多节点需要设置防止冲突）</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hostnamectl <span class="built_in">set</span>-hostname master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ubuntu-server 18.04 在执行上述命令之前需要执行 <code>sed -i &quot;s|preserve_hostname: false|preserve_hostname: true|g&quot; /etc/cloud/cloud.cfg</code> 防止重启 hostname 失效。桌面版本不用设置</p>
</blockquote>
</li>
</ol>
<h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><blockquote>
<p><a href="https://github.com/kubernetes/kubernetes/" target="_blank" rel="noopener">kubernetes github</a> 上的 CHANGELOG 记录了 kubernetes 对 Docker 版本的要求，建议选好对应的 kubernetes 版本再安装 Docker。例如如果希望安装 Kubernetes 1.15，那么查看 <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.15.md" target="_blank" rel="noopener">CHANGELOG-1.15.md</a>，可以查看到 Kuberentes 1.15 对 Docker 的最低版本要求是 1.13.1。</p>
</blockquote>
<p>CentOS 安装<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce <span class="comment"># 安装最新版</span></span><br><span class="line">yum install -y docker-ce-18.06.3.ce-3.el7 <span class="comment"># 安装 18.06.3 版本</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用 <code>yum list all docker-ce --showduplicates | sort -r</code> 查看可安装的版本</p>
</blockquote>
<p>Ubuntu 安装<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install -y docker-ce <span class="comment"># 安装最新版</span></span><br><span class="line">apt-get install -y docker-ce=5:18.09.7~3-0~ubuntu-bionic <span class="comment"># 安装指定版本</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用 <code>apt-cache madison docker-ce</code> 查看可安装的版本</p>
</blockquote>
<p>Docker 设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'&#123;"insecure-registries": ["0.0.0.0/0"]&#125;'</span> &gt;&gt; /etc/docker/daemon.json</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="安装-kubeadm"><a href="#安装-kubeadm" class="headerlink" title="安装 kubeadm"></a>安装 kubeadm</h3><p>CentOS 安装<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y kubeadm <span class="comment"># 安装最新的 kubeadm</span></span><br><span class="line">yum install -y kubeadm-1.14.1-0 <span class="comment"># 安装 kubeadm 1.14.1</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用 <code>yum list all kubeadm --showduplicates | sort -r</code> 查看可安装的版本</p>
</blockquote>
<p>Ubuntu 安装<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install -y kubeadm <span class="comment"># 安装最新的 kubeadm</span></span><br><span class="line">apt-get install -y kubeadm=1.14.1-00 <span class="comment"># 安装 kubeadm 1.14.1</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用 <code>apt-cache madison kubeadm</code> 查看可安装的版本</p>
</blockquote>
<p>配置 kubelet</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubelet 使用的 cgroup 要和 Docker 的 cgroup 一致</span></span><br><span class="line">sed -i <span class="string">'0,/"$/s/"$/ --cgroup-driver=cgroupfs"/'</span> /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure>
<h3 id="初始化-Kubernetes-设置（可选）"><a href="#初始化-Kubernetes-设置（可选）" class="headerlink" title="初始化 Kubernetes 设置（可选）"></a>初始化 Kubernetes 设置（可选）</h3><p>使用 <code>kubeadm config images list</code> 查看初始化所需要的镜像，当前版本为 1.14.1，需要的镜像有<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver:v1.14.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.14.1</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.14.1</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.14.1</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.3.10</span><br><span class="line">k8s.gcr.io/coredns:1.3.1</span><br><span class="line"># kubernetes-dashboard 镜像，使用的 dashboard ui 不同版本也不同</span><br><span class="line">k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span><br></pre></td></tr></table></figure></p>
<p>编写脚本从阿里云拉取镜像再 tag</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">images=( <span class="comment"># 这里的镜像列表是 kubeadm config images list 查看的列表去掉 k8s.gcr.io/ 得到的</span></span><br><span class="line">kube-apiserver:v1.14.1</span><br><span class="line">kube-controller-manager:v1.14.1</span><br><span class="line">kube-scheduler:v1.14.1</span><br><span class="line">kube-proxy:v1.14.1</span><br><span class="line">pause:3.1</span><br><span class="line">etcd:3.3.10</span><br><span class="line">coredns:1.3.1</span><br><span class="line">kubernetes-dashboard-amd64:v1.10.1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">  docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="variable">$imageName</span> k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb-学习记录</title>
    <url>/2018/07/24/mongodb-note/</url>
    <content><![CDATA[<h1 id="MongoDB-学习记录"><a href="#MongoDB-学习记录" class="headerlink" title="MongoDB 学习记录"></a>MongoDB 学习记录</h1><ul>
<li><a href="#什么是MongoDB">什么是 MongoDB</a></li>
<li><a href="#MongoDB的组织形式">MongoDB 的组织形式</a></li>
<li><a href="#MongoDB有几种数据结构">MongoDB 有几种数据结构</a></li>
<li><a href="#如何创建数据库">如何创建数据库</a></li>
<li><a href="#那么怎么样才可以创建集合">那么怎么样才可以创建集合</a></li>
<li><a href="#如何删除集合和数据库">如何删除集合和数据库</a></li>
<li><a href="#如何查看帮助文档">如何查看帮助文档</a></li>
<li><a href="#如何插入文档">如何插入文档</a><ul>
<li><a href="#插入一条数据">插入一条数据</a></li>
<li><a href="#插入多条数据">插入多条数据</a></li>
</ul>
</li>
<li><a href="#如何查询插入的数据">如何查询插入的数据</a><ul>
<li><a href="#查询全部数据">查询全部数据</a></li>
<li><a href="#如何仅查询需要的字段">如何仅查询需要的字段</a></li>
<li><a href="#如何根据条件进行查询">如何根据条件进行查询</a></li>
<li><a href="#如何查询stars大于50的数据">如何查询 <code>stars</code> 大于 50 的数据</a></li>
<li><a href="#如何多条件查询">如何多条件查询</a></li>
<li><a href="#如何查询满足其中一个条件的数据">如何查询满足其中一个条件的数据</a></li>
<li><a href="#如何按照stars从大到小从小到大排序">如何按照 <code>stars</code> 从大到小，从小到大排序</a></li>
<li><a href="#如何实现分页">如何实现分页</a></li>
<li><a href="#如何实现分组">如何实现分组</a></li>
</ul>
</li>
<li><a href="#如何删除数据">如何删除数据</a><ul>
<li><a href="#如何删除一条数据">如何删除一条数据</a></li>
<li><a href="#如何删除多条数据">如何删除多条数据</a></li>
</ul>
</li>
<li><a href="#如何更新数据">如何更新数据</a><ul>
<li><a href="#如何更新一条数据">如何更新一条数据</a></li>
<li><a href="#如何更新多条数据">如何更新多条数据</a></li>
<li><a href="#如何更新数据中的文档数据">如何更新数据中的文档数据</a><ul>
<li><a href="#如何删除文档类型数据中的域">如何删除文档类型数据中的域</a></li>
<li><a href="#如何在文档类型数据中插入新的数据">如何在文档类型数据中插入新的数据</a></li>
</ul>
</li>
<li><a href="#如何更新数组中的数据">如何更新数组中的数据</a><ul>
<li><a href="#如何往数组中插入新的数据">如何往数组中插入新的数据</a></li>
<li><a href="#如何删除数组中的数据">如何删除数组中的数据</a></li>
<li><a href="#如何向数组中插入另一个数组的内容">如何向数组中插入另一个数组的内容</a></li>
<li><a href="#如何向数组中插入不重复数据">如何向数组中插入不重复数据</a></li>
<li><a href="#如何删除数组中的多个元素">如何删除数组中的多个元素</a></li>
</ul>
</li>
<li><a href="#如何创建索引">如何创建索引</a><ul>
<li><a href="#创建升序索引">创建升序索引</a></li>
<li><a href="#创建降序索引">创建降序索引</a></li>
</ul>
</li>
<li><a href="#如何查看创建索引">如何查看创建索引</a></li>
<li><a href="#如何删除创建的索引">如何删除创建的索引</a></li>
</ul>
</li>
</ul>
<h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h2><p>MongoDB 是一个 NoSQL 数据库，和 MySQL 等关系型数据库不一样 MongoDB 更简单易用。MongoDB 是 NoSQL 的一种。</p>
<h2 id="MongoDB的组织形式"><a href="#MongoDB的组织形式" class="headerlink" title="MongoDB的组织形式"></a>MongoDB的组织形式</h2><p>MongoDB 中可以有多个<code>数据库</code>，每个数据库中可以有多个<code>集合</code>，每个集合有多个<code>文档</code>（文档就相当于 MySQL 中的表，但是表中的数据都有相同的域，文档中的每一条数据不一定有相同的域），每个文档都有<code>域</code>，这些域可能存在也可能不存在，在实际使用中每个文档应该有相同的域。</p>
<p>MongoDB 的组织形式图解:  </p>
<p><img src="./MongoDB结构.png" alt="MongoDB结构"></p>
<p>MongoDB 和 MySQL 的对对比：  </p>
<p><img src="./MongoDB和MySQL的对比.png" alt="MongoDB和MySQL的对比"></p>
<h2 id="MongoDB有几种数据结构"><a href="#MongoDB有几种数据结构" class="headerlink" title="MongoDB有几种数据结构"></a>MongoDB有几种数据结构</h2><p>MongoDB 中以下几种数据结构：</p>
<ul>
<li>数字</li>
<li>字符串</li>
<li>布尔</li>
<li>日期</li>
<li>数组</li>
<li>文档（JavaScript 中的对象）</li>
</ul>
<h2 id="如何创建数据库"><a href="#如何创建数据库" class="headerlink" title="如何创建数据库"></a>如何创建数据库</h2><p>MongoDB 中的数据库不用手动创建，只需要使用 <code>use &lt;collection&gt;</code> 就可以选择数据库，如何没有这个数据库，在创建一个集合的同时也会创建数据库</p>
<h2 id="那么怎么样才可以创建集合"><a href="#那么怎么样才可以创建集合" class="headerlink" title="那么怎么样才可以创建集合"></a>那么怎么样才可以创建集合</h2><p>使用以下命令就可以创建一个集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.createCollection(<span class="string">"collectionName"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="如何删除集合和数据库"><a href="#如何删除集合和数据库" class="headerlink" title="如何删除集合和数据库"></a>如何删除集合和数据库</h2><p>使用以下命令可以删除一个集合，其中 <code>&lt;collection&gt;</code> 表示选中的集合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.&lt;collection&gt;.drop()</span><br></pre></td></tr></table></figure>
<p>删除数据库可以使用以下命令删除，注意，这个 db 是由 <code>use &lt;database&gt;</code> 选中的数据库</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>
<h2 id="如何查看帮助文档"><a href="#如何查看帮助文档" class="headerlink" title="如何查看帮助文档"></a>如何查看帮助文档</h2><p>在 Mongo shell 中直接使用 <code>help</code> 命令可以查看在线帮助文档</p>
<p>使用 <code>db.help()</code> 可以查看数据库相关的帮助文档</p>
<p>使用 <code>db.&lt;collectionname&gt;.help()</code> 可以查看数据库集合的相关帮助文档</p>
<h2 id="如何插入文档"><a href="#如何插入文档" class="headerlink" title="如何插入文档"></a>如何插入文档</h2><p>查看 <code>db.&lt;collectionname&gt;.help()</code> 可以看见 MongoDB 定义了三种方式来插入文档，有 <code>insert</code>,<code>insertOne</code>,<code>insertMany</code>，其中 <code>insert</code> 用处最多，具备有 <code>insertOne</code> 和 <code>insertMany</code> 的功能。</p>
<p><code>insertOne</code> 用于向数据库中插入单条数据的情况，<code>insertMany</code> 用于一条命令向数据库中插入多条数据。</p>
<h3 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.insert(&#123;</span><br><span class="line">    title: <span class="string">'mongodb 的使用'</span>,</span><br><span class="line">    author: <span class="string">'canxing'</span>,</span><br><span class="line">    publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">31</span>),</span><br><span class="line">    content : <span class="string">'mongodb 插入语句的实现'</span>,</span><br><span class="line">    stars : <span class="number">10</span>,</span><br><span class="line">    comment : []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.insert([</span><br><span class="line">&#123;</span><br><span class="line">    title: <span class="string">'mongodb 插入多条数据的使用'</span>,</span><br><span class="line">    author: <span class="string">'canxing'</span>,</span><br><span class="line">    publishDate : <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">33</span>),</span><br><span class="line">    content : <span class="string">"mongodb 插入多条数据的实现"</span>,</span><br><span class="line">    stars: <span class="number">12</span>,</span><br><span class="line">    comment : []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    title: <span class="string">'mongodb 插入多条数据的使用2'</span>,</span><br><span class="line">    author:<span class="string">'canxing'</span>,</span><br><span class="line">    publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">34</span>),</span><br><span class="line">    content: <span class="string">"mongodb 插入多条数据的实现2"</span>,</span><br><span class="line">    stars: <span class="number">2</span>,</span><br><span class="line">    comment : []</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="如何查询插入的数据"><a href="#如何查询插入的数据" class="headerlink" title="如何查询插入的数据"></a>如何查询插入的数据</h2><p>首先保证数据库中已经插入了下面这些数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.insert([</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">'mongodb 数据库的创建'</span>,</span><br><span class="line">        author: &#123;</span><br><span class="line">            firstName: <span class="string">'liu'</span>,</span><br><span class="line">            lastName: <span class="string">'xin'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">12</span>),</span><br><span class="line">        content: <span class="string">'mongodb 数据库的创建'</span>,</span><br><span class="line">        stars: <span class="number">30</span>,</span><br><span class="line">        comment:[</span><br><span class="line">            <span class="string">'aaaa'</span>,</span><br><span class="line">            <span class="string">'bbbb'</span>,</span><br><span class="line">            <span class="string">'cccc'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"走两步"</span>,</span><br><span class="line">        author: &#123;</span><br><span class="line">            firstName: <span class="string">"tom"</span>,</span><br><span class="line">            lastName: <span class="string">"jerry"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">8</span>, <span class="number">23</span>),</span><br><span class="line">        content: <span class="string">"随便走两步"</span>,</span><br><span class="line">        stars: <span class="number">32</span>,</span><br><span class="line">        comment: [</span><br><span class="line">            <span class="string">'dddd'</span>,</span><br><span class="line">            <span class="string">'eeee'</span>,</span><br><span class="line">            <span class="string">'ffff'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"葫芦娃救爷爷"</span>,</span><br><span class="line">        author: &#123;</span><br><span class="line">            firstName: <span class="string">"忘了"</span>,</span><br><span class="line">            lastName: <span class="string">"忘了"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">10</span>, <span class="number">23</span>),</span><br><span class="line">        content: <span class="string">"7个葫芦娃轮流救爷爷，结果都被抓了"</span>,</span><br><span class="line">        stars: <span class="number">11000</span>,</span><br><span class="line">        comment: [</span><br><span class="line">            <span class="string">'gggggggggg'</span>,</span><br><span class="line">            <span class="string">'hhhhhhhhhhh'</span>,</span><br><span class="line">            <span class="string">'iiiiiiiiiii'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="查询全部数据"><a href="#查询全部数据" class="headerlink" title="查询全部数据"></a>查询全部数据</h3><blockquote>
<p>要想查询的结果可读性更强，可以试试 pretty 方法 db.blog.find().pretty()</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find()</span><br></pre></td></tr></table></figure>
<h3 id="如何仅查询需要的字段"><a href="#如何仅查询需要的字段" class="headerlink" title="如何仅查询需要的字段"></a>如何仅查询需要的字段</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find(&#123;&#125;, &#123;<span class="attr">title</span>:<span class="number">1</span>, <span class="attr">author</span>:<span class="number">1</span>, <span class="attr">publishDate</span>:<span class="number">1</span>, <span class="attr">_id</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>查询的第一个参数是筛选条件，<code>{}</code> 表示不过滤直接查询，也就是查询所有的数据，第二个参数设置需要显示的域，要显示的设置为 1, 不显示的设置为 0, <code>_id</code> 域默认显示，不想显示需要手动指定。</p>
<h3 id="如何根据条件进行查询"><a href="#如何根据条件进行查询" class="headerlink" title="如何根据条件进行查询"></a>如何根据条件进行查询</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;)  <span class="comment">//根据博客名称进行查询</span></span><br><span class="line">db.blog.find(&#123;<span class="attr">author</span>: &#123;<span class="attr">firstName</span>: <span class="string">"liu"</span>, <span class="attr">lastName</span>: <span class="string">"xin"</span>&#125;&#125;)  <span class="comment">//根据作者进行查询</span></span><br><span class="line">db.blog.find(&#123;<span class="attr">comment</span>: <span class="string">'dddd'</span>&#125;)  <span class="comment">//根据评论进行查询</span></span><br></pre></td></tr></table></figure>
<p>上面展示了三种根据条件进行查询的方式，这种方式类似于 MySQL 中的 where 字句但是也有不同。</p>
<p>第一条查询语句使用 <code>{title: &quot;mongodb 数据库的创建&quot;}</code> 来筛选，返回所有数据中满足 <code>title</code> 域对应的值等于 <code>mongodb 数据库的创建</code> 的语句。</p>
<p>第二条查询语句使用 <code>{author: {firstName: &quot;liu&quot;, lastName: &quot;xin&quot;}}</code> 来筛选，注意，这个 <code>author</code> 是一个文档类型，查询的时候需要该文档类型中的所有域都相等。</p>
<p>第三条查询语句使用 <code>{comment: &#39;dddd&#39;}</code> 来筛选，<code>comment</code> 是一个数组类型，查询时可以使用这种方式，表示查询的数组中含有 <code>dddd</code> 元素的数据，也可以使用 <code>db.blog.find({comment: [&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;]})</code> 来查询，使用后一种方式时要使用匹配该数组中的所有元素才行。</p>
<h3 id="如何查询stars大于-50-的数据"><a href="#如何查询stars大于-50-的数据" class="headerlink" title="如何查询stars大于 50 的数据"></a>如何查询stars大于 50 的数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">stars</span>: &#123;<span class="attr">$gt</span>: <span class="number">50</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>在 MongoDB 中 <code>&gt;</code>,<code>&lt;</code>, 都不能使用，要使用特殊符号来表示这些。符号如下:</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>大于</td>
<td>$gt</td>
</tr>
<tr>
<td>小于</td>
<td>$lt</td>
</tr>
<tr>
<td>不等于</td>
<td>$ne</td>
</tr>
<tr>
<td>大于等于</td>
<td>$gte</td>
</tr>
<tr>
<td>小于等于</td>
<td>$lte</td>
</tr>
</tbody>
</table>
<p>用法和示例类似</p>
<h3 id="如何多条件查询"><a href="#如何多条件查询" class="headerlink" title="如何多条件查询"></a>如何多条件查询</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">stars</span>: <span class="number">32</span>, <span class="attr">title</span>: <span class="string">"走两步"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>要查询同时满足多个条件的数据，只需要如示例添加条件就行了。</p>
<h3 id="如何查询满足其中一个条件的数据"><a href="#如何查询满足其中一个条件的数据" class="headerlink" title="如何查询满足其中一个条件的数据"></a>如何查询满足其中一个条件的数据</h3><p>如果要求返回匹配多个条件中的一个条件的数据，需要使用关键字 <code>$or</code>，相当于 or 语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">$or</span>: [&#123;<span class="attr">stars</span>: <span class="number">32</span>&#125;, &#123;<span class="attr">stars</span>: <span class="number">30</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="如何按照stars从大到小从小到大排序"><a href="#如何按照stars从大到小从小到大排序" class="headerlink" title="如何按照stars从大到小从小到大排序"></a>如何按照stars从大到小从小到大排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find(&#123;&#125;).sort(&#123;<span class="attr">stars</span>:<span class="number">1</span>&#125;)  <span class="comment">//升序</span></span><br><span class="line">db.blog.find(&#123;&#125;).sort(&#123;<span class="attr">stars</span>:<span class="number">-1</span>&#125;) <span class="comment">//降序</span></span><br></pre></td></tr></table></figure>
<h3 id="如何实现分页"><a href="#如何实现分页" class="headerlink" title="如何实现分页"></a>如何实现分页</h3><p>MongoDB 中也有 limit 方法，但是这个 limit 和 MySQL 中的 limit 不同，这个 limit 只会返回指定条数的数据，不能指定从什么位置开始读取。要实现和 MySQL 中的 limit 相同的功能，需要同时使用 skip 和 limit。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.find(&#123;&#125;).skip(<span class="number">1</span>).limit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>skip 表示跳过多条数据，limit 表示只读取多条数据，这里跳过第一条，只读取一条，那么就会读取所有数据的第二条。</p>
<h3 id="如何实现分组"><a href="#如何实现分组" class="headerlink" title="如何实现分组"></a>如何实现分组</h3><p>在 MySQL 中，分组首先要有一个字段，按照这个字段的不同分成不同的组。MongoDB 中也是一样，需要某一个域作为参数，返回这个参数的不同的值。</p>
<p>分组要 <code>aggregate</code> 方法和 <code>$group</code> 操作符，在 <code>$group</code> 操作符中，使用 <code>_id</code> 来说明分组的 key 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.aggregate([&#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">'$stars'</span>&#125;&#125;]) <span class="comment">//按照 stars 字段进行分组</span></span><br></pre></td></tr></table></figure>
<h2 id="如何删除数据"><a href="#如何删除数据" class="headerlink" title="如何删除数据"></a>如何删除数据</h2><p>删除数据可以使用 <code>remove</code>,<code>deleteOne</code> 和 <code>deleteMany</code> 中的某一个。</p>
<h3 id="如何删除一条数据"><a href="#如何删除一条数据" class="headerlink" title="如何删除一条数据"></a>如何删除一条数据</h3><p>如果只想删除一条数据，使用 <code>deleteOne</code>，它会删除满足条件的第一条语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.deleteOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="如何删除多条数据"><a href="#如何删除多条数据" class="headerlink" title="如何删除多条数据"></a>如何删除多条数据</h3><p>删除多条数据使用 <code>deleteMany</code> 是很不错的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.deleteMany(&#123;<span class="attr">stars</span>: &#123;<span class="attr">$gt</span>: <span class="number">30</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>删除单条数据使用 <code>deleteOne</code>，删除多条数据使用 <code>deleteMany</code>，至于 <code>remove</code> 一般情况下不需要使用，毕竟 <code>deleteMany</code> 既可以删除一条也可以删除多条。</p>
<h2 id="如何更新数据"><a href="#如何更新数据" class="headerlink" title="如何更新数据"></a>如何更新数据</h2><p>更新数据使用 <code>update</code>,<code>updateOne</code> 和 <code>updateMany</code>。</p>
<h3 id="如何更新一条数据"><a href="#如何更新一条数据" class="headerlink" title="如何更新一条数据"></a>如何更新一条数据</h3><p>更新一条数据使用 <code>updateOne</code> 方法，<code>updateOne</code> 方法会更新第一个匹配的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="attr">stars</span>: <span class="number">50</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>updateOne</code> 接收两个参数，第一个参数是要修改数据的查询条件，和查询时使用的条件一样，第二个参数表示要更新的数据。<em> 注意 </em>：如果没有使用 <code>$set</code> 那么这条数据就只有一个域那就是 <code>{stars:50}</code>，使用 <code>$set</code> 之后才会修改指定的域，不然就是覆盖整条数据。</p>
<h3 id="如何更新多条数据"><a href="#如何更新多条数据" class="headerlink" title="如何更新多条数据"></a>如何更新多条数据</h3><p>更新多条数据使用 <code>updateMany</code>，使用 <code>update</code> 也可以，可是使用 <code>update</code> 需要额外添加 <code>{multi: true}</code>，有些时候会忘记添加，忘记添加就相当于使用 <code>updateOne</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateMany(&#123;<span class="attr">$or</span>: [&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">title</span>: <span class="string">"走两步"</span>&#125;]&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="attr">stars</span>: <span class="number">1000</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="如何更新数据中的文档数据"><a href="#如何更新数据中的文档数据" class="headerlink" title="如何更新数据中的文档数据"></a>如何更新数据中的文档数据</h3><p>在我们插入的数据中有 <code>author</code> 域，该域是一个文档类型，和普通数据类型不同，如何修改，删除，添加里面的数据</p>
<h4 id="如何删除文档类型数据中的域"><a href="#如何删除文档类型数据中的域" class="headerlink" title="如何删除文档类型数据中的域"></a>如何删除文档类型数据中的域</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$unset</span>: &#123;<span class="string">'author.lastName'</span>: <span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这里使用了 <code>$unset</code>，这个操作会删除一个域，<code>&#39;author.lastName&#39;</code> 表示 <code>author</code> 文档的 <code>lastName</code> 属性，1 表示删除。<code>$unset</code> 不仅可以删除一个文档中的域，也可以删除一个域。</p>
<h4 id="如何在文档类型数据中插入新的数据"><a href="#如何在文档类型数据中插入新的数据" class="headerlink" title="如何在文档类型数据中插入新的数据"></a>如何在文档类型数据中插入新的数据</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="string">'author.lastName'</span>: <span class="string">'xin'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>上述操作不仅可以插入新的数据，也可以用来更新数据</p>
<h3 id="如何更新数组中的数据"><a href="#如何更新数组中的数据" class="headerlink" title="如何更新数组中的数据"></a>如何更新数组中的数据</h3><p>和数组有关的操作符看<a href="https://docs.mongodb.com/manual/reference/operator/update-array/" target="_blank" rel="noopener">这里</a></p>
<h4 id="如何往数组中插入新的数据"><a href="#如何往数组中插入新的数据" class="headerlink" title="如何往数组中插入新的数据"></a>如何往数组中插入新的数据</h4><p>往数组中插入新的数据使用 <code>$push</code> 操作符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$push</span>: &#123;<span class="attr">comment</span>: <span class="string">'zzzzzzzzzz'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="如何删除数组中的数据"><a href="#如何删除数组中的数据" class="headerlink" title="如何删除数组中的数据"></a>如何删除数组中的数据</h4><p>删除数组中的数据使用 <code>$pop</code> 操作符和 <code>$pull</code> 操作符。<code>$pop</code> 操作符用于删除并返回数组中的第一个或最后一个元素。<code>$pull</code> 操作符用于精确删除数组中匹配的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$pop</span>:&#123;<span class="attr">comment</span>:<span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>其中 <code>{comment: 1}</code> 中的 1 表示弹出并删除最后一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>:<span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$pull</span>: &#123;<span class="attr">comment</span>: <span class="string">'bbbb'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="如何向数组中插入另一个数组的内容"><a href="#如何向数组中插入另一个数组的内容" class="headerlink" title="如何向数组中插入另一个数组的内容"></a>如何向数组中插入另一个数组的内容</h4><p>如果直接使用 <code>$push</code> 向数组中插入一个数组的话，都将数组作为一个元素插入，而不是将数组中的所有元素依次插入。</p>
<p>为了将一个数组中的所有元素都插入到数组中，需要使用 <code>$each</code> 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>:<span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$push</span>: &#123;<span class="attr">comment</span>: &#123;<span class="attr">$each</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="如何向数组中插入不重复数据"><a href="#如何向数组中插入不重复数据" class="headerlink" title="如何向数组中插入不重复数据"></a>如何向数组中插入不重复数据</h4><p>mongodb 没有提供编程语言中集合类型相似的数据结构，只有数组，为了不插入重复数据，可以使用 <code>$addToSet</code> 关键字，或者在输出的时候去重。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.log.updateOne(&#123;title: &quot;mongodb 数据库的创建&quot;&#125;, &#123;$addToPush: &#123;comment: &#123;$each: [7, 7, 7, 7]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="如何删除数组中的多个元素"><a href="#如何删除数组中的多个元素" class="headerlink" title="如何删除数组中的多个元素"></a>如何删除数组中的多个元素</h4><p>只使用 <code>$pusll</code> 关键字无法删除数组中的多个元素，只能删除一个元素，要删除多个使用 <code>$in</code> 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">titile</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$pull</span> : &#123;<span class="attr">comment</span>: &#123;<span class="attr">$in</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><p>使用文档中某个域创建索引，使用该域进行查询时可以加快查询速度</p>
<h3 id="创建升序索引"><a href="#创建升序索引" class="headerlink" title="创建升序索引"></a>创建升序索引</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.createIndex(&#123;<span class="attr">title</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="创建降序索引"><a href="#创建降序索引" class="headerlink" title="创建降序索引"></a>创建降序索引</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.createIndex(&#123;<span class="attr">title</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="如何查看创建索引"><a href="#如何查看创建索引" class="headerlink" title="如何查看创建索引"></a>如何查看创建索引</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.getIndexes()</span><br></pre></td></tr></table></figure>
<h2 id="如何删除创建的索引"><a href="#如何删除创建的索引" class="headerlink" title="如何删除创建的索引"></a>如何删除创建的索引</h2><p>删除对应索引，删除索引时的名称不是创建索引时的名称，而是使用 <code>getIndexes</code> 查看的 <code>name</code> 属性的名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.blog.dropIndex(<span class="string">'title_1'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 自定义模块</title>
    <url>/2018/08/23/ngxin-customize-module/</url>
    <content><![CDATA[<p>Nginx 有核心模块和第三方模块，我们也可以自定义模块来使用。Nginx 就像一个小型的编程语言，要添加自定义模块就要满足一些 Nginx 的编写要求，就像 C 语言必须有一个 main 函数一样。</p>
<p>这里大部分的内容來自于《Nginx 开发从入门到精通》，只不过整理了一下以满足我自己的思考方式，更详细的内容可以访问 <a href="http://tengine.taobao.org/book/chapter_03.html" target="_blank" rel="noopener">《Nginx 开发从入门到精通》</a>。<code>ngx_http_hello_module.c</code> 为主要模块，<code>config</code> 是添加自定义模块到 Nginx 时使用的。</p>
<p>模块所有代码在<a href="https://github.com/canxing/the-road-to-learning/tree/master/nginx/module" target="_blank" rel="noopener">这里</a></p>
<h2 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h2><p>Nginx 都是以指令的形式进行配置的，所以我们的自定义模块也需要自定义指令来实现功能。自定义指令需要借助于 <code>ngx_command_t</code> 结构体。<code>ngx_command_t</code> 结构体定义在 <code>src/core/ngx_conf_file.h</code> 文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_command_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_str_t</span>             name;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line">    <span class="keyword">char</span>               *(*<span class="built_in">set</span>)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf);</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            conf;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            offset;</span><br><span class="line">    <span class="keyword">void</span>                 *post;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>src/core/ngx_core.h</code> 文件中将使用 <code>ngx_command_t</code> 来表示 <code>struct ngx_command_s</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_command_s</span>         <span class="title">ngx_command_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>这是关于自定义指令的描述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span> ngx_http_hello_commands[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_string(<span class="string">"hello_string"</span>),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1,</span><br><span class="line">        ngx_http_hello_string,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(<span class="keyword">ngx_http_hello_loc_conf_t</span>, hello_string),</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_string(<span class="string">"hello_counter"</span>),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,</span><br><span class="line">        ngx_http_hello_counter,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(<span class="keyword">ngx_http_hello_loc_conf_t</span>, hello_counter),</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ngx_null_command</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>name</strong> 表示指令的名称，定义好后在 Nginx 配置文件中就可以直接使用该名称作为指令，比如在配置文件中可以使用 <code>hello_string</code> 来配置。</li>
<li><strong>type</strong> 为指令接受参数的条件。条件由两部分构成：位置和参数个数。 </li>
</ul>
<p>位置由以下参数表示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>    NGX_DIRECT_CONF</td>
<td>可以出现在配置文件中最外层。例如已经提供的配置指令 daemon, master_process 等。</td>
</tr>
<tr>
<td>    NGX_MAIN_CONF</td>
<td>http, mail, events, error_log 等。</td>
</tr>
<tr>
<td>    NGX_ANY_CONF</td>
<td>该配置指令可以出现在任意配置级别上。</td>
</tr>
<tr>
<td>    NGX_HTTP_MAIN_CONF</td>
<td>可以直接出现在 http 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_SRV_CONF</td>
<td>可以出现在 http 里面的 server 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_LOC_CONF</td>
<td>可以出现在 http server 块里面的 location 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_UPS_CONF</td>
<td>可以出现在 http 里面的 upstream 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_SIF_CONF</td>
<td>可以出现在 http 里面的 server 配置指令里的 if 语句所在的 block 中。</td>
</tr>
<tr>
<td>    NGX_HTTP_LMT_CONF</td>
<td>可以出现在 http 里面的 limit_except 指令的 block 中。</td>
</tr>
<tr>
<td>    NGX_HTTP_LIF_CONF</td>
<td>可以出现在 http server 块里面的 location 配置指令里的 if 语句所在 block 中。</td>
</tr>
</tbody>
</table>
<p>参数个数由以下参数表示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NGX_CONF_NOARGS</td>
<td>配置指令不接受任何参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE1</td>
<td>配置指令接受 1 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE2</td>
<td>配置指令接受 2 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE3</td>
<td>配置指令接受 3 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE4</td>
<td>配置指令接受 4 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE5</td>
<td>配置指令接受 5 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE6</td>
<td>配置指令接受 6 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE7</td>
<td>配置指令接受 7 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_MULTI</td>
<td>配置指令接受多个参数，即个数不定。</td>
</tr>
<tr>
<td>NGX_CONF_BLOCK</td>
<td>配置指令可以接受的值是一个配置信息。也就是一对大括号扩起来的内容。里面可以再包括很多个配置指令。比如常见的 server 指令就是这个属性。</td>
</tr>
<tr>
<td>NGX_CONF_FLAG</td>
<td>配置指令可以接受的值是 on 或者 off，最终会被转成 bool 值。</td>
</tr>
<tr>
<td>NGX_CONF_ANY</td>
<td>配置指令可以接受的任意的参数值</td>
</tr>
</tbody>
</table>
<p>上面这些参数可以使用 <code>|</code> 进行组合，比如上面配置中 <code>NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1</code> 就表示定义在 http server 块中的 location 配置指令中，接受 0 个或者 1 个参数。</p>
<ul>
<li><strong><em>set</em></strong> 是一个函数指针，为该指令的处理函数，因为指令如何处理只有定义这个指令的人最清楚。</li>
</ul>
<p>函数处理成功时返回 <code>NGX_OK</code>，否则返回 <code>NGX_CONF_ERROR</code> 或者一个自定义的错误信息的字符串。</p>
<p>函数调用时会传入三个参数：</p>
<ol>
<li>cf: 该参数里面保存从配置文件读取到的原始字符串以及相关的一些信息。特别注意的是这个参数的 args 字段是一个 ngx_str_t 类型的数组，该数组的首个元素是这个配置指令本身，第二个元素是指令的第一个参数，第三个元素是第二个参数，依次类推。</li>
<li>cmd: 这个配置指令对应的 ngx_command_t 结构。</li>
<li>conf: 就是定义的存储这个配置值的结构体。</li>
</ol>
<p>为了方便对配置指令参数的读取，Nginx 默认提供了一些对标准类型的参数进行读取的函数，可以直接复制给 set 字段使用。</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ngx_conf_set_flag_slot</td>
<td>读取 NGX_CONF_FLAG 类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_str_slot</td>
<td>读取字符串类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_str_array_slot</td>
<td>读取字符串数组类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_keyval_slot</td>
<td>读取键值对类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_num_slot</td>
<td>读取整数类型（有符号）的参数</td>
</tr>
<tr>
<td>ngx_conf_set_size_slot</td>
<td>读取 size_t 类型的参数，也就是无符号数。</td>
</tr>
<tr>
<td>ngx_conf_set_off_slot</td>
<td>读取 off_t 类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_msec_slot</td>
<td>读取毫秒值类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_sec_slot</td>
<td>读取秒值类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_bufs_slot</td>
<td>读取的参数值是 2 个，一个是 buf 的个数，一个是 buf 的大小。</td>
</tr>
<tr>
<td>ngx_conf_set_enum_slot</td>
<td>读取枚举类型的参数，将其转换成 ngx_uint_t 类型。</td>
</tr>
<tr>
<td>ngx_conf_set_bitmask_slot</td>
<td>读取参数的值，并将这些参数以 bit 位的形式存储。</td>
</tr>
</tbody>
</table>
<p>下面是对 hello_string 进行处理的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_http_hello_counter</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_http_hello_loc_conf_t</span>* local_conf;</span><br><span class="line">    local_conf = conf;</span><br><span class="line">    <span class="keyword">char</span>* rv = <span class="literal">NULL</span>;</span><br><span class="line">    rv = ngx_conf_set_flag_slot(cf, cmd, conf);</span><br><span class="line">    ngx_conf_log_error(NGX_LOG_EMERG, cf, <span class="number">0</span>, <span class="string">"hello_counter:%d"</span>, local_conf-&gt;hello_counter);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数返回的是指令接收的参数，使用 ntx_http_hello_loc_conf_t 只是为了打印一下输出。</p>
<p>ngx_http_hello_loc_conf_t 的定义如下。在传入 set 函数指针时，conf 指向的就是这个结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_str_t</span> hello_string;</span><br><span class="line">    <span class="keyword">ngx_int_t</span> hello_counter;</span><br><span class="line">&#125;<span class="keyword">ngx_http_hello_loc_conf_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>conf</em></strong> 该字段被NGX_HTTP_MODULE类型模块所用 (我们编写的基本上都是NGX_HTTP_MOUDLE，只有一些nginx核心模块是非NGX_HTTP_MODULE)，该字段指定当前配置项存储的内存位置。实际上是使用哪个内存池的问题。因为http模块对所有http模块所要保存的配置信息，划分了main, server和location三个地方进行存储，每个地方都有一个内存池用来分配存储这些信息的内存。这里可能的值为 NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET或NGX_HTTP_LOC_CONF_OFFSET。当然也可以直接置为0，就是NGX_HTTP_MAIN_CONF_OFFSET。</li>
<li><strong><em>offset</em></strong>: 指定该配置项值的精确存放位置，一般指定为某一个结构体变量的字段偏移。因为对于配置信息的存储，一般我们都是定义个结构体来存储的。那么比如我们定义了一个结构体A，该项配置的值需要存储到该结构体的b字段。那么在这里就可以填写为offsetof(A, b)。</li>
<li>该字段存储一个指针。可以指向任何一个在读取配置过程中需要的数据，以便于进行配置读取的处理。大多数时候，都不需要，所以简单地设为0即可。</li>
</ul>
<p><strong><em>需要注意的是，就是在ngx_http_hello_commands这个数组定义的最后，都要加一个ngx_null_command作为结尾。</em></strong></p>
<h2 id="模块上下文"><a href="#模块上下文" class="headerlink" title="模块上下文"></a>模块上下文</h2><p>模块上下文和 <code>ngx_http_module_t</code> 有关，这个结构体的定义在 <code>src/http/ngx_http_config.h</code> 文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_int_t</span>   (*preconfiguration)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>   (*postconfiguration)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>       *(*create_main_conf)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">char</span>       *(*init_main_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *conf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>       *(*create_srv_conf)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">char</span>       *(*merge_srv_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *prev, <span class="keyword">void</span> *conf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>       *(*create_loc_conf)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">char</span>       *(*merge_loc_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *prev, <span class="keyword">void</span> *conf);</span><br><span class="line">&#125; <span class="keyword">ngx_http_module_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个变量实际上是提供一组回调函数指针，这些函数有在创建存储配置信息的对象的函数，也有在创建前和创建后会调用的函数。这些函数都将被nginx在合适的时间进行调用。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>preconfiguration</td>
<td>在创建和读取该模块的配置信息之前被调用。</td>
</tr>
<tr>
<td>postconfiguration</td>
<td>在创建和读取该模块的配置信息之后被调用。</td>
</tr>
<tr>
<td>create_main_conf</td>
<td>调用该函数创建本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。</td>
</tr>
<tr>
<td>init_main_conf</td>
<td>调用该函数初始化本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串</td>
</tr>
<tr>
<td>create_srv_conf</td>
<td>调用该函数创建本模块位于 http server block 的配置信息存储结构，每个 server block 会创建一个。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。</td>
</tr>
<tr>
<td>merge_srv_conf</td>
<td>因为有些配置指令既可以出现在 http block，也可以出现在 http server block 中。那么遇到这种情况，每个 server都会有自己存储结构来存储该 server 的配置，但是在这种情况下 http block 中的配置与 server block 中的配置信息发生冲突的时候，就需要调用此函数进行合并，该函数并非必须提供，当预计到绝对不会发生需要合并的情况的时候，就无需提供。当然为了安全起见还是建议提供。该函数执行成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。</td>
</tr>
<tr>
<td>create_loc_conf</td>
<td>调用该函数创建本模块位于 location block 的配置信息存储结构。每个在配置中指明的 location 创建一个。该函数执行成功，返回创建的配置对象。失败的话，返回 NULL。</td>
</tr>
<tr>
<td>merge_loc_conf</td>
<td>与 merge_srv_conf 类似，这个也是进行配置值合并的地方。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。</td>
</tr>
</tbody>
</table>
<p>Nginx 里面的配置信息都是上下一层层的嵌套的，对于具体某个 location 的话，对于同一个配置，如果当前层次没有定义，那么就使用上层的配置，否则使用当前层次的配置。</p>
<p>下面为该自定义模块的上下文定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span> ngx_http_hello_module_ctx = &#123;</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    ngx_http_hello_init,</span><br><span class="line"></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">    ngx_http_hello_create_loc_conf,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述配置说明了在创建和读取该模块的配置信息之后调用初始化函数，并且在 location 块中配配置信息存储结构。</p>
<p>ngx_http_hello_init 函数定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_hello_init(<span class="keyword">ngx_conf_t</span> *cf) </span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_handler_pt *h;</span><br><span class="line">    <span class="keyword">ngx_http_core_main_conf_t</span> *cmcf;</span><br><span class="line"></span><br><span class="line">    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</span><br><span class="line">    </span><br><span class="line">    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *h = ngx_http_hello_handler;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ngx_http_hello_handler 函数定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_hello_handler(<span class="keyword">ngx_http_request_t</span> *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_int_t</span> rc;</span><br><span class="line">    <span class="keyword">ngx_buf_t</span> *b;</span><br><span class="line">    <span class="keyword">ngx_chain_t</span> out;</span><br><span class="line">    <span class="keyword">ngx_http_hello_loc_conf_t</span>* my_conf;</span><br><span class="line">    u_char ngx_hello_string[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span> content_length = <span class="number">0</span>;</span><br><span class="line">    ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"ngx_http_hello_handler is called!"</span>);</span><br><span class="line"></span><br><span class="line">    my_conf = ngx_http_get_module_loc_conf(r, ngx_http_hello_module);</span><br><span class="line">    <span class="keyword">if</span> (my_conf-&gt;hello_string.len == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"hello string is empty!"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_conf-&gt;hello_counter == NGX_CONF_UNSET || my_conf-&gt;hello_counter == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ngx_sprintf(ngx_hello_string, <span class="string">"%s"</span>, my_conf-&gt;hello_string.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ngx_sprintf(ngx_hello_string, <span class="string">"%s Visited Times:%d"</span>, my_conf-&gt;hello_string.data, </span><br><span class="line">                ++ngx_hello_visited_times);</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"hello_string:%s"</span>, ngx_hello_string);</span><br><span class="line">    content_length = ngx_strlen(ngx_hello_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_HTTP_NOT_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_discard_request_body(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_str_set(&amp;r-&gt;headers_out.content_type, <span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;method == NGX_HTTP_HEAD) &#123;</span><br><span class="line">        r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">        r-&gt;headers_out.content_length_n = content_length;</span><br><span class="line">        <span class="keyword">return</span> ngx_http_send_header(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_buf_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    out.buf = b;</span><br><span class="line">    out.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    b-&gt;pos = ngx_hello_string;</span><br><span class="line">    b-&gt;last = ngx_hello_string + content_length;</span><br><span class="line">    b-&gt;memory = <span class="number">1</span>;</span><br><span class="line">    b-&gt;last_buf = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">    r-&gt;headers_out.content_length_n = content_length;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_send_header(r);</span><br><span class="line">    <span class="keyword">if</span> (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) &#123;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ngx_http_output_filter(r, &amp;out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h2><p>上面分别说了指令的配置以及模块的上下文定义，关于模块本身的定义说的不多。</p>
<p>对于开发一个模块来说，我们都需要定义一个 <code>ngx_module_t</code> 类型的变量来说明这个模块本身的信息，从某种意义上来说，这是这个模块最重要的一个信息，它告诉了 Nginx 这个模块的一些信息，上面定义的配置信息，还有模块上下文信息，都是通过这个结构来告诉 Nginx 系统的，也就是加载模块的上层代码，都需要通过定义的这个结构，来获取这些信息。</p>
<p><code>ngx_module_t</code> 的定义在 <code>src/core/ngx_module.h</code> 文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            ctx_index;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>                 *name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare0;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            version;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>           *signature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                 *ctx;</span><br><span class="line">    <span class="keyword">ngx_command_t</span>        *commands;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_module)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                (*exit_master)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook0;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook1;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook2;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook3;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook4;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook5;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook6;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook7;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MODULE_V1                                                         \</span></span><br><span class="line">    NGX_MODULE_UNSET_INDEX, NGX_MODULE_UNSET_INDEX,                           \</span><br><span class="line">    <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, nginx_version, NGX_MODULE_SIGNATURE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MODULE_V1_PADDING  0, 0, 0, 0, 0, 0, 0, 0</span></span><br></pre></td></tr></table></figure>
<p>在 <code>src/core/ngx_core.h</code> 中有如下定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span>          <span class="title">ngx_module_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>Nginx 为了简化配置，将前面 7 个配置使用 <code>NGX_MODULE_V1</code> 宏来表示，后 8 个配置使用 <code>NGX_MODULE_V1_PADDING</code> 宏来表示。因此只需要配置 10 个参数就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ngx_module_t</span> ngx_http_hello_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_hello_module_ctx,   <span class="comment">//该模块的上下文</span></span><br><span class="line">    ngx_http_hello_commands,      <span class="comment">//该模块的指令集合</span></span><br><span class="line">    NGX_HTTP_MODULE,              <span class="comment">//该模块的种类</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//在 master 初始化的函数</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//模块初始化函数</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//初始化工作进程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//初始化线程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//离开线程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//离开工作进程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//离开 master</span></span><br><span class="line">    NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模块挂载"><a href="#模块挂载" class="headerlink" title="模块挂载"></a>模块挂载</h2><p>定义好一个模块之后还需要把模块挂载到相应的请求处理阶段上，Nginx 有 11 个请求处理阶段，其中有 4 个阶段不能配置，剩下 7 个可以进行挂载。在 <code>ngx_http_hello_module_ctx</code> 中传入的指针函数 <code>ngx_http_hello_init</code> 就是用来挂载到相应模块上的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_hello_init(<span class="keyword">ngx_conf_t</span> *cf) </span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_handler_pt *h;</span><br><span class="line">    <span class="keyword">ngx_http_core_main_conf_t</span> *cmcf;</span><br><span class="line"></span><br><span class="line">    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</span><br><span class="line">    </span><br><span class="line">    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *h = ngx_http_hello_handler;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ngx_http_conf_get_module_main_conf</code> 根据 conf 结构和模块得到主配置，然后使用 ngx_array_push 在 <code>NGX_HTTP_CONTENT_PHASE</code> 阶段进行挂载。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个模块可以有多个指令，Nginx 使用 <code>ngx_command_t</code> 来描述一个指令，比如指令名称，指令所在位置，指令参数，指令处理函数，指令存储空间以及指令参数在哪个结构体的哪个属性等。</p>
<p>为了将指令的参数在回调函数中可以被明白的解析，需要定义一个结构体来存储传入的参数，这里使用的结构体是 <code>ngx_http_hello_loc_conf_t</code>，其中 hello_string 指令的参数通过 offsetof(ngx_http_hello_loc_conf_t, hello_string) 传入 <code>ngx_http_hello_loc_conf_t</code> 的 hello_string 属性。封装好后 Nginx 会将 ngx_http_hello_loc_conf_t 传入处理回调函数，因为 C 语言的原因，所以传入的指针为 void* 类型的指针，在处理函数中需要进行转换。hello_string 指令的处理函数为 <code>ngx_http_hello_string</code>，hello_counter 指令的处理函数为 <code>ngx_http_hello_counter</code>。</p>
<p>指令在不同阶段可能进行各种初始化工作，Nginx 定义了 <code>ngx_http_module_t</code> 结构体来描述一个指令的上下文环境。可以根据情况来进行上下文的初始化。</p>
<p>最后需要使用 <code>ngx_module_t</code> 结构体来描述该模块本身的信息，模块本身的信息需要传入模块上下文，模块的指令，模块的类型，以及各种钩子函数等。值得注意的是，Nginx 提供了两个宏来减少配置操作，分别时 <code>NGX_MODULE_V1</code> 和 <code>NGX_MODULE_V1_PADDING</code>。</p>
<p>hello 模块在模块上下文定义中，在配置读取和创建结束之后传入了 <code>ngx_http_hello_init</code> 函数，该函数会将模块挂载到 <code>NGX_HTTP_CONTENT_PHASE</code>，并且将 <code>ngx_hettp_hello_handler</code> 函数作为主要的处理函数。</p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>python-简单爬虫</title>
    <url>/2018/06/30/python-reptile/</url>
    <content><![CDATA[<h1 id="python-简单爬虫"><a href="#python-简单爬虫" class="headerlink" title="python 简单爬虫"></a>python 简单爬虫</h1><blockquote>
<p>这不是一篇完整的爬虫教程，这是一篇使用python完成简单爬虫的使用过程记录。<br>使用 python3 以及第三方库 requests 和 lxml 以及 xpath 技术来爬取一些网页数据<br>这里只是用了 GET 请求，没有使用 POST 请求</p>
</blockquote>
<h2 id="第三方库和技术介绍"><a href="#第三方库和技术介绍" class="headerlink" title="第三方库和技术介绍"></a>第三方库和技术介绍</h2><p>requests: 这里使用 requests 来请求一个网页，并将响应结果封装在一个对象中返回</p>
<p>lxml: 使用 lxml 中的 etree 库对响应的 HTML 页面进行解析</p>
<p>xpath: 一种解析 xml 文档的技术，也可以解析 HTML 页面。在w3c可以找到文档</p>
<h2 id="过程介绍"><a href="#过程介绍" class="headerlink" title="过程介绍"></a>过程介绍</h2><ol>
<li>使用 <code>requests.get</code> 函数请求对应的<code>URL</code></li>
<li>如果请求正常并有返回，将返回结果通过<code>etree.HTML</code>处理</li>
<li>使用<code>xpath</code>技术对<code>etree.HTML</code>处理过的对象进行解析，获取对应的数据</li>
<li>数据存储</li>
</ol>
<h2 id="请求页面"><a href="#请求页面" class="headerlink" title="请求页面"></a>请求页面</h2><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>使用<code>requests.get(url)</code>方式可以请求对应的<code>url</code>内容，并将响应结果封装在一个对象中返回，但是直接使用这种方式的请求头中包含这个<code>&quot;User-Agent&quot;:&quot;python-requests/2.19.1&quot;</code><br>有些服务器会通过这个请求头得知这是一个python爬虫请求从而拒绝响应。为了正常访问，需要传入一个请求头来覆盖这个属性，从而骗过请求服务器。</p>
<p>在<code>firefox</code>浏览器中通过请求<code>http://httpbin.org/get</code>可以获得本机的请求头，下面是我请求的该链接的部分内容</p>
<p><img src="httpbing-request.png" alt="本机请求httpbin.org"></p>
<p>将请求中的<code>User-Agent</code>对应的属性作为键值对形式传入<code>requests.get()</code>的<code>headers</code>参数，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">header = &#123;<span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"</span>&#125;</span><br><span class="line">response = requests.get(url, headers=header)</span><br></pre></td></tr></table></figure>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>如果你想要传入查询参数，只需要以键值对的形式传入<code>requests.get</code>中的<code>params</code>，下面的查询键为’user’，对应的值为’tom’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="string">"user"</span>:<span class="string">"tom"</span>&#125;</span><br><span class="line">response = requests.get(url, params=data)</span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line">如果你有多个查询值也可以添加多个键值对</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">data = &#123;<span class="string">"user"</span>:<span class="string">"tom"</span>,<span class="string">"pwd"</span>:<span class="string">"jerry"</span>&#125;</span><br><span class="line">response = requests.get(url, params=data)</span><br></pre></td></tr></table></figure>
<h3 id="请求超时设置"><a href="#请求超时设置" class="headerlink" title="请求超时设置"></a>请求超时设置</h3><p>对<code>requests.get</code>函数的<code>timeout</code>参数传入一个数字可以设置请求的最长时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.get(url, timeout=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><p>使用<code>response = requests.get()</code>之后就获取了响应结果，这时可以对响应做一些处理</p>
<h3 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h3><p><code>response.status_code</code>返回请求的响应码，正常情况下返回<code>200</code></p>
<h3 id="字符设置"><a href="#字符设置" class="headerlink" title="字符设置"></a>字符设置</h3><p>响应返回的结果不一定可以正常显示，对<code>response.encoding</code>属性进行赋值可以修改返回的字符集，一般设置为<code>utf-8</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response.encoding = <span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p><code>response.text</code>将数据以文本形式返回，文本形式的字符集和字符设置有关，如果没有设置则返回响应数据设置的字符集</p>
<p><code>response.content</code>将数据以字节形式返回，使用这种方式返回就不用担心返回的数据出现乱码问题</p>
<h2 id="一个完整的请求实例"><a href="#一个完整的请求实例" class="headerlink" title="一个完整的请求实例"></a>一个完整的请求实例</h2><p>请求一个<code>url</code>并将响应结果以文本的形式返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_agent = <span class="string">"User-Agent"</span></span><br><span class="line">my_user_agent = <span class="string">"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"</span></span><br><span class="line">header = &#123;user_agent: my_user_agent&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(url, data=None)</span> :</span></span><br><span class="line">    <span class="string">'''根据url请求一个html页面并返回'''</span></span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        r = requests.get(url, headers=header, params=data)</span><br><span class="line">        r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> r.text</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"返回页面信息失败"</span>)</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"请求链接失败"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="xpath处理"><a href="#xpath处理" class="headerlink" title="xpath处理"></a>xpath处理</h2><p>使用<code>lxml</code>中的<code>etree</code>库中的<code>HTML</code>函数可以将一个<code>HTML</code>页面转换为一个对象，对该对象使用<code>xpath</code>语法即可获取对应的数据。有关更多的<code>xpath</code>技术点击<a href="http://www.w3school.com.cn/xpath/" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.HTML(html)</span><br><span class="line">html.xpath(xpath)</span><br></pre></td></tr></table></figure>
<p>对于使用<code>xpath</code>语法来获取数据，在<code>firefox</code>浏览器中使用<a href="https://addons.mozilla.org/zh-CN/firefox/addon/try-xpath/?src=search" target="_blank" rel="noopener">这个</a>插件，可以在线使用<code>xpath</code>语法来匹配</p>
<p>注意:使用<code>xpath</code>语法返回的数据都是以列表形式返回</p>
<p><a href="https://github.com/canxing/code-repository/blob/master/python/reptile/tencent_job_reptile.py" target="_blank" rel="noopener">一个完整的可以爬取腾讯社招技术类的所有招聘信息的爬虫程序</a></p>
]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>reptile</tag>
      </tags>
  </entry>
  <entry>
    <title>shell基础</title>
    <url>/2018/11/28/shell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Shell-基础"><a href="#Shell-基础" class="headerlink" title="Shell 基础"></a>Shell 基础</h1><blockquote>
<p>Shell 脚本的第一行用于指定该脚本用什么解释器执行。通过命令 <code>cat /etb/shells</code> 可以查看当前系统安装了哪些解释器，<br>然后在脚本第一行输入 <code>#! /bin/bash</code> 指定解释器，<code>/bin/bash</code> 是通过查看 <code>/etc/shells</code> 文件得到的，不同的机器上可能有不同的脚本</p>
</blockquote>
<ul>
<li><a href="#变量">变量</a><ul>
<li><a href="#定义变量">定义变量</a></li>
<li><a href="#使用变量">使用变量</a></li>
<li><a href="#只读变量">只读变量</a></li>
<li><a href="#删除变量">删除变量</a></li>
<li><a href="#变量类型">变量类型</a></li>
<li><a href="#字符串变量">字符串变量</a><ul>
<li><a href="#获取字符串长度">获取字符串长度</a></li>
<li><a href="#提取子字符串">提取子字符串</a></li>
</ul>
</li>
<li><a href="#数组变量">数组变量</a></li>
</ul>
</li>
<li><a href="#传递参数">传递参数</a></li>
<li><a href="#运算符">运算符</a><ul>
<li><a href="#算数运算符">算数运算符</a></li>
<li><a href="#关系运算符">关系运算符</a></li>
<li><a href="#布尔运算符">布尔运算符</a></li>
<li><a href="#逻辑运算符">逻辑运算符</a></li>
<li><a href="#字符串运算符">字符串运算符</a></li>
<li><a href="#文件测试运算符">文件测试运算符</a></li>
</ul>
</li>
<li><a href="#控制流">控制流</a><ul>
<li><a href="#if-else">if-else</a></li>
<li><a href="#for">for</a></li>
<li><a href="#while">while</a></li>
<li><a href="#until">until</a></li>
</ul>
</li>
<li><a href="#函数">函数</a></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>在 Shell 中定义变量，不需要指定变量类型，也不需要修饰变量。直接使用 <code>变量名=值</code> 的形式即可对变量进行赋值。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">"canxinglook.cn"</span></span><br></pre></td></tr></table></figure>
<p><strong><em> 和其他编程语言不同的是，Shell 定义变量时，= 左右两边不能有空格 </em></strong></p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>要使用一个定义过的变量，只要在变量前加 <code>$</code> 即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"i am <span class="variable">$your_name</span>"</span></span><br><span class="line"><span class="built_in">echo</span> i am <span class="variable">$your_name</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br><span class="line"><span class="built_in">echo</span> i am <span class="variable">$&#123;your_name&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"i am<span class="variable">$&#123;your_name&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>变量名称外可以加花括号，加不加都行，但是在某些情况下，需要加花括号对变量边界加以限制</p>
<blockquote>
<p>为了保持统一，建议使用变量都加上花括号</p>
</blockquote>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>Shell 提供了 <code>readonly</code> 关键字将一个变量声明为只读变量，声明之后的变量值将不能在改变。</p>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>Shell 使用 <code>unset</code> 关键字删除一个变量，<code>unset</code> 关键字不能删除只读变量。删除之后的变量可以重新赋值。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">"canxinglook.cn"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">unset</span> your_name</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br><span class="line">your_name=<span class="string">"tom"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行 Shell 时，会存在三种变量:</p>
<ol>
<li>局部变量: 在脚本或命令中定义，仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问</li>
<li>环境变量: 所有程序，包括 Shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。</li>
<li>Shell 变量: Shell 变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行。</li>
</ol>
<h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><p>字符串是 Shell 编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。虽然单引号和双引号都可以表示一个字符串，但是在使用上还存在一些不同。</p>
<p>单引号的限制:</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
<p>在字符串定义上，尽量使用双引号不要使用单引号。</p>
<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>使用 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;#&lt;string&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>即可获取字符串长度，其中 <code>&lt;string&gt;</code> 为字符串。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">'abcdefg'</span></span><br><span class="line">len=<span class="variable">$&#123;#your_name&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;len&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><p>提取子字符串使用 <code>${&lt;string&gt;:&lt;startIndex&gt;:&lt;offset&gt;}</code> 从 string 的 startIndex 位置开始提取 offset 个字符返回。其中 <code>&lt;string&gt;</code> 为被提取的字符串;<code>&lt;startIndex&gt;</code> 为提取开始位置，字符串的第一个字符下标为 0; <code>&lt;offset&gt;</code> 为提取个数，包括开始位置的那个字符串。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">'abcdefg'</span></span><br><span class="line">subStr=<span class="variable">$&#123;your_name:1:2&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;subStr&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>Shell 中定义一个数组可以使用下面三种方式。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_name=(<span class="string">"abc"</span> <span class="string">"defg"</span> <span class="string">"1234"</span>)</span><br><span class="line"></span><br><span class="line">array_name=(</span><br><span class="line"><span class="string">"111"</span></span><br><span class="line"><span class="string">"222"</span></span><br><span class="line"><span class="string">"333"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">array_name=()</span><br><span class="line">array_name[0]=<span class="string">"aaaaa"</span></span><br><span class="line">array_name[1]=<span class="string">"bbbbbb"</span></span><br><span class="line">array_name[2]=<span class="string">"ccccc"</span></span><br><span class="line">array_name[3]=<span class="string">"ddddddd"</span></span><br></pre></td></tr></table></figure>
<p>Shell 使用一对括号 <code>()</code> 来定义一个数组，数组中的每个元素使用空格分割。数组元素下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或表达式，其值应该大于或等于 0。</p>
<p>获取数组元素使用 <code>{&lt;array-name&gt;[&lt;index&gt;]}</code>，其中 <code>&lt;array-name&gt;</code> 为一个数组变量，<code>&lt;index&gt;</code> 表示数组下标。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_name=(<span class="string">"aaaaaa"</span>, <span class="string">"bbbbb"</span> <span class="string">"cccccc"</span> <span class="string">"ddddddddd"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[2]&#125;</span></span><br></pre></td></tr></table></figure>
<p>获取数组中的所有元素使用 <code>{&lt;array-name&gt;[@]}</code> 或者 <code>{&lt;array-name&gt;[*]}</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_name=(<span class="string">"aaaaaa"</span>, <span class="string">"bbbbb"</span> <span class="string">"cccccc"</span> <span class="string">"ddddddddd"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[*]&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>获取数组长度使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;#&lt;array-name&gt;[@]&#125;</span></span><br><span class="line"><span class="variable">$&#123;#&lt;array-name&gt;[*]&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;array-name&gt;</code> 为数组变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array_name=(<span class="string">"aaaaaa"</span>, <span class="string">"bbbbb"</span> <span class="string">"cccccc"</span> <span class="string">"ddddddddd"</span>)</span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line">len=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;length&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;len&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>在执行 Shell 脚本时，可以向脚本传递参数，脚本内获取参数的方式为 <code>$n</code>，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，0 为执行脚本的名称。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的名称为 <span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的第一个参数为 <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的第二个参数为 <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的第三个参数为 <span class="variable">$3</span>"</span></span><br></pre></td></tr></table></figure>
<p>执行脚本命令 <code>./test 1 2 3</code></p>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行脚本的名称为 ./test.sh</span><br><span class="line">执行脚本的第一个参数为 1</span><br><span class="line">执行脚本的第二个参数为 2</span><br><span class="line">执行脚本的第三个参数为 3</span><br></pre></td></tr></table></figure>
<p>另外 Shell 还有几个特殊字符用来处理参数</p>
<table>
<thead>
<tr>
<th>参数说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程 ID</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的 ID</td>
</tr>
<tr>
<td>$@</td>
<td>与 <code>$*</code> 相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>现实 Shell 使用的当前选项，与 set 命令相同</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态，0 表示没有错误，其他任何值表示有错误。</td>
</tr>
</tbody>
</table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>Shell 不支持原生的数学运算，但是可以通过其他命令来实现，最常用的就是 <code>expr</code></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expr $a + $b</code></td>
<td>加法运算</td>
</tr>
<tr>
<td><code>expr $a - $b</code></td>
<td>减法运算</td>
</tr>
<tr>
<td><code>expr $a \* $b</code></td>
<td>乘法运算</td>
</tr>
<tr>
<td><code>expr $a / $b</code></td>
<td>除法运算</td>
</tr>
<tr>
<td><code>expr $a % %b</code></td>
<td>取余运算</td>
</tr>
</tbody>
</table>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>相等返回 true，不相等返回 false</td>
<td><code>[ $a -eq $b ]</code></td>
</tr>
<tr>
<td>-ne</td>
<td>不相等返回 true，相等返回 false</td>
<td><code>[ $a -ne $b ]</code></td>
</tr>
<tr>
<td>-gt</td>
<td>大于返回 true，不大于返回 false</td>
<td><code>[ $a -gt $b ]</code></td>
</tr>
<tr>
<td>-lt</td>
<td>小于返回 true，不小于返回 false</td>
<td><code>[ $a -lt $b ]</code></td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于返回 true，小于返回 false</td>
<td><code>[ $a -ge $b ]</code></td>
</tr>
<tr>
<td>-le</td>
<td>小于等于返回 true，大于返回 false</td>
<td><code>[ $a -le $b ]</code></td>
</tr>
</tbody>
</table>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非运算</td>
<td><code>[ !false ]</code></td>
</tr>
<tr>
<td>-o</td>
<td>或运算</td>
<td><code>[ $a -lt 200 -o $b -ge 10 ]</code></td>
</tr>
<tr>
<td>-a</td>
<td>与运算</td>
<td><code>[ $a -lt 200 -a $b -ge 10 ]</code></td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>and</td>
<td><code>[[ $a -lt 200 &amp;&amp; $b -ge 10 ]]</code></td>
</tr>
<tr>
<td>_</td>
<td></td>
<td>_</td>
<td>or</td>
<td>`[[ $a -lt 200</td>
<td></td>
<td>$b -ge 10 ]]`</td>
</tr>
</tbody>
</table>
<h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>相等返回 true，不相等返回 false</td>
<td><code>[ $a = $b ]</code></td>
</tr>
<tr>
<td>!=</td>
<td>不相等返回 true，相等返回 false</td>
<td><code>[ $a != $b ]</code></td>
</tr>
<tr>
<td>-z</td>
<td>字符串长度为 0 返回 true，不为 0 返回 false</td>
<td><code>[ -z $a ]</code></td>
</tr>
<tr>
<td>-n</td>
<td>字符串长度不为 0 返回 true，为 0 返回 false</td>
<td><code>[ -n $a ]</code></td>
</tr>
<tr>
<td>str</td>
<td>字符串不为空返回 true</td>
<td><code>[ $a ]</code></td>
</tr>
</tbody>
</table>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>如果文件是块设备文件，返回 true。</td>
<td><code>[ -b $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-c</td>
<td>如果文件是字符设备文件，返回 true。</td>
<td><code>[ -c $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-d</td>
<td>如果文件是目录，返回 true。</td>
<td><code>[ -d $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-f</td>
<td>如果文件是普通文件，返回 true。</td>
<td><code>[ -f $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-g</td>
<td>如果文件设置了SGID 位，返回 true。 `</td>
<td>[ -g $file ]` 返回 false。</td>
</tr>
<tr>
<td>-k</td>
<td>如果文件设置了粘着位，返回 true。</td>
<td><code>[ -k $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-p</td>
<td>如果文件是有名管道，返回 true。</td>
<td><code>[ -p $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-u</td>
<td>如果文件设置了 SUID 位，返回 true。</td>
<td><code>[ -u $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-r</td>
<td>如果文件可读，返回 true。</td>
<td><code>[ -r $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-w</td>
<td>如果文件可写，则返回 true。</td>
<td><code>[ -w $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-x</td>
<td>如果文件可执行，返回 true。</td>
<td><code>[ -x $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-s</td>
<td>如果文件不为空，返回 true。</td>
<td><code>[ -s $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-e</td>
<td>如果文件（包括目录）存在，返回 true。</td>
<td><code>[ -e $file ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><blockquote>
<p>和其他编程语言一样可以使用 break 和 continue 来跳出循环</p>
</blockquote>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>if 语句语法如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">elif</span> condition3</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command3</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command4</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if 语句以 <code>if condition1; then</code> 开始，<code>fi</code> 结束，<code>elif</code> 和 <code>else</code> 都是可选的。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for 语句语法如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;var&gt; <span class="keyword">in</span> item1 item2 item3 ... itemn</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>遍历一个数组需要使用 <code>${array[@]}</code> 获取所有数组元素</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">array=(<span class="string">'111'</span> <span class="string">'222'</span> <span class="string">'333'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;item&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while 语句语句如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>实例如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$i</span> -le 5 ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    i=`expr <span class="variable">$i</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>until 语句执行一些语句直到条件为 true 时停止</p>
<p>until 语法如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>case 语句为多选择语句，类似其他语句中的 switch 语句。case 语句语法如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;val&gt; <span class="keyword">in</span> </span><br><span class="line">    &lt;val1&gt;)</span><br><span class="line">        command1</span><br><span class="line">        ;;</span><br><span class="line">    &lt;val2&gt;)</span><br><span class="line">        command2</span><br><span class="line">        ;;</span><br><span class="line">    &lt;val3&gt;)</span><br><span class="line">        command3</span><br><span class="line">        ;;</span><br><span class="line">        ...</span><br><span class="line">        *)</span><br><span class="line">        commandn</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义函数的语法如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">function</span>] funname [()] &#123;</span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line">    [<span class="built_in">return</span> value;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中带有 <code>[]</code> 都是可选的</p>
<p>要调用函数直接使用函数名称即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span> () &#123;</span><br><span class="line">    <span class="built_in">read</span> num</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$&#123;num&#125;</span> <span class="keyword">in</span> </span><br><span class="line">        1) <span class="built_in">echo</span> <span class="string">"你选择了 1"</span></span><br><span class="line">            ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;num&#125;</span>"</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func</span><br></pre></td></tr></table></figure>
<p>如果要传递参数到函数中，只需要在函数名称后加上参数即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span> () &#123;</span><br><span class="line">    //<span class="built_in">command</span></span><br><span class="line">&#125;</span><br><span class="line">func 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p>要从函数内部获取传入的参数，需要借助几个特殊字符。</p>
<table>
<thead>
<tr>
<th>参数说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程 ID</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的 ID</td>
</tr>
<tr>
<td>$@</td>
<td>与 <code>$*</code> 相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>现实 Shell 使用的当前选项，与 set 命令相同</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态，0 表示没有错误，其他任何值表示有错误。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-mvc返回json数据</title>
    <url>/2017/12/16/spring-mvc%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>在使用spring-mvc过程中遇到很多问题，记录下来方便查看</p>
<p>开发环境如下:</p>
<p>eclipse Oxygen Release (4.7.0)</p>
<p>java1.8</p>
<p>spring 4.3.3</p>
<p>freemarker 2.3.26(这个不是必须的)</p>
<h2 id="maven依赖包如下："><a href="#maven依赖包如下：" class="headerlink" title="maven依赖包如下："></a>maven依赖包如下：</h2><pre><code>&lt;!-- spring mvc返回json所需依赖  --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
        &lt;version&gt;2.7.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.7.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- freemarker 引擎，有了这个就不需要使用jstl了，只需要使用freemarker表达式就行了 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
        &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
        &lt;version&gt;2.3.26-incubating&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- spring 核心 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- springmvc 核心 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!-- spring bean 核心 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
        &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
        &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><h2 id="web-xml-配置"><a href="#web-xml-配置" class="headerlink" title="web.xml 配置:"></a>web.xml 配置:</h2><pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动顺序，让这个Servlet随Servletp容器一起启动。 --&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!--会拦截URL中带“/”的请求。 --&gt;
&lt;/servlet-mapping&gt;
</code></pre><h2 id="spring-mvc配置"><a href="#spring-mvc配置" class="headerlink" title="spring-mvc配置:"></a>spring-mvc配置:</h2><pre><code>&lt;mvc:annotation-driven /&gt;
&lt;context:component-scan base-package=&quot;canxing.web&quot; /&gt;
</code></pre><h2 id="spring-mvc配置freemarker"><a href="#spring-mvc配置freemarker" class="headerlink" title="spring-mvc配置freemarker:"></a>spring-mvc配置freemarker:</h2><pre><code>&lt;!-- freemarker 配置文件 --&gt;
&lt;!-- freemarker config --&gt;
&lt;bean id=&quot;freemarkerConfig&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/freemarker/&quot; /&gt;
&lt;/bean&gt;

&lt;!-- View resolvers can also be configured with ResourceBundles or XML files.
    If you need different view resolving based on Locale, you have to use the
    resource bundle resolver. --&gt;
&lt;bean id=&quot;viewResolver&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
    &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt;
&lt;/bean&gt;
</code></pre><h2 id="JSONController-java"><a href="#JSONController-java" class="headerlink" title="JSONController.java:"></a>JSONController.java:</h2><pre><code>@Controller
public class JSONController {
    @RequestMapping(path=&quot;/json&quot;,produces=&quot;application/json&quot;)
    public @ResponseBody User index() {//使用@RespnseBody将返回的对象转化为JSON数据
        System.out.println(&quot;index start&quot;);
        User user = new User();
        user.setUsername(&quot;canxing&quot;);
        user.setPassword(&quot;123&quot;);
        System.out.println(&quot;index end&quot;);
        return user;
    }
    @RequestMapping(path=&quot;/&quot;)
    public String test() {
        return &quot;test&quot;;
    }
}
</code></pre><h2 id="User-java："><a href="#User-java：" class="headerlink" title="User.java："></a>User.java：</h2><pre><code>//类不需要进行处理，只是一个普通的pojo类
public class User{
        private String username;
        private String password;
        public String getUsername() {
            return username;
        }
        public void setUsername(String username) {
            this.username = username;
        }
        public String getPassword() {
            return password;
        }
        public void setPassword(String password) {
            this.password = password;
        }
        @Override
        public String toString() {
            return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;;
        }
    }
</code></pre><h2 id="test-flt"><a href="#test-flt" class="headerlink" title="test.flt:"></a>test.flt:</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>freemarker test <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params"></span>)</span></span></span><br><span class="line">			&#123;</span><br><span class="line"><span class="javascript">				xmlhttp=<span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">				  &#123;<span class="comment">// code for Firefox, Mozilla, IE7, etc.</span></span></span><br><span class="line"><span class="javascript">				  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line">				  &#125;</span><br><span class="line"><span class="javascript">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject)</span></span><br><span class="line"><span class="javascript">				  &#123;<span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="javascript">				  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span></span><br><span class="line">				  &#125;</span><br><span class="line"><span class="javascript">				<span class="keyword">if</span> (xmlhttp!=<span class="literal">null</span>)</span></span><br><span class="line">				  &#123;</span><br><span class="line">				  xmlhttp.onreadystatechange=state_Change;</span><br><span class="line"><span class="javascript">				  xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"http://localhost:8080/spring_web_test/json"</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">				  xmlhttp.send(<span class="literal">null</span>);</span></span><br><span class="line">				  &#125;</span><br><span class="line"><span class="javascript">				<span class="keyword">else</span></span></span><br><span class="line">				  &#123;</span><br><span class="line"><span class="javascript">				  alert(<span class="string">"Your browser does not support XMLHTTP."</span>);</span></span><br><span class="line">				  &#125;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">state_Change</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">"("</span> + xmlhttp.responseText + <span class="string">")"</span>);</span></span><br><span class="line"><span class="javascript">				<span class="built_in">document</span>.getElementById(<span class="string">"username"</span>).innerHTML=obj.username</span></span><br><span class="line"><span class="javascript">				<span class="built_in">document</span>.getElementById(<span class="string">"password"</span>).innerHTML=obj.password</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>freemarker test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		username : <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">'username'</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		password : <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">'password'</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">'button'</span> <span class="attr">onclick</span>=<span class="string">"loadXMLDoc()"</span>&gt;</span>adfads<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/spring-mvc-return-object-as-json" target="_blank" rel="noopener">spring-mvc返回JSOn数据参考源码</a></p>
<h3 id="寻找答案中遇到的问题"><a href="#寻找答案中遇到的问题" class="headerlink" title="寻找答案中遇到的问题"></a>寻找答案中遇到的问题</h3><ol>
<li>依赖问题，spring 默认的对象转化为 json 的 jar 包依赖，网上多是直接使用并没有说明依赖</li>
<li>还是依赖问题，spring 和 jackson 之间版本的兼容性太差，稍微更改以下 jackson 或者 spring 的版本就会导致 NoSuchMethodError 错误，据说这里可以看见<a href="https://jira.spring.io/browse/SPR/?selectedTab=com.atlassian.jira.jira-projects-plugin:summary-panel" target="_blank" rel="noopener">版本支持</a>，但是看不懂</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ajax</tag>
        <tag>json</tag>
        <tag>spring-mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下gpg的基本使用</title>
    <url>/2017/12/10/ubuntu%E4%B8%8Bgpg%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="什么是gpg"><a href="#什么是gpg" class="headerlink" title="什么是gpg"></a>什么是gpg</h1><blockquote>
<p>课程实验需要使用pgp对文件进行加密解密操作，pgp是一套用于消息加密、验证的应用程序，采用IDEA的散列算法作为加密与验证之用,但是pgp是商业软件不能自由使用，所以有自由软件基金会开发一个pgp的替代品，取名GnuPG，这就是gpg。</p>
</blockquote>
<h2 id="安装gpg"><a href="#安装gpg" class="headerlink" title="安装gpg"></a>安装gpg</h2><blockquote>
<p>在ubuntu16.04下gpg已经安装好了，可以使用如下命令<br><em><code>gpg -h</code></em><br>如果输出有gpg的帮助文档，那么就有gpg，如果没有可以前往 <a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">gnupg官网</a> 页面下载</p>
</blockquote>
<h2 id="gpg-基本使用"><a href="#gpg-基本使用" class="headerlink" title="gpg 基本使用"></a>gpg 基本使用</h2><blockquote>
<h2 id="1-生成密钥"><a href="#1-生成密钥" class="headerlink" title="1.生成密钥"></a>1.生成密钥</h2><blockquote>
<p>  输入以下命令开始生成密钥对  </p>
<ul>
<li><code>gpg --gen-key</code> *<br><br>选择密钥种类，默认选择1,使用RSA and RSA算法，表示加密和签名都使用RSA算法<br><br>然后选择要使用的密钥长度默认为2048,密钥长度越长，越安全，由于是课程实验，所以使用默认值<br><br>选择密钥的有效期，由于是课程实验，所以选择永不过期，如果是要上传到服务器上，按情况自行选择有效期<br><br>系统确认<br><br>输入真实姓名<br><br>电子邮箱<br><br>注释<br><br>然后生成用户标识<br><br>然后系统最后确认<br><br>接着系统让你设置一个私钥密钥，用来保护私钥<br><br>接着系统生成密钥，需要大量的随机字节，按系统提示等一下就会生成密钥<br></li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<h2 id="2-检查密钥"><a href="#2-检查密钥" class="headerlink" title="2.检查密钥"></a>2.检查密钥</h2><blockquote>
<p>   查看本机密钥<br><br>    <em><code>gpg --list-keys</code></em></p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="3-输出密钥"><a href="#3-输出密钥" class="headerlink" title="3.输出密钥"></a>3.输出密钥</h2><blockquote>
<p>   输出公钥<br><br>   <em><code>gpg -a -o public-key.txt --export [用户标识(可以是密钥id，就是使用gpg --list-key 查看到的密钥id)]</code></em></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>  输出私钥<br><br>   <em><code>gpg -a -o private-key.txt --export-secret-keys</code></em></p>
</blockquote>
</blockquote>
<blockquote>
<p>##4.上出公钥</p>
<blockquote>
<p>   由于是课程实验，所以并没有上传（其实是不知道什么原因，无法上传到服务器)</p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="5-导入密钥"><a href="#5-导入密钥" class="headerlink" title="5.导入密钥"></a>5.导入密钥</h2><blockquote>
<p>  <em><code>gpg --import [密钥文件]</code></em><br><br>   也可以到公钥服务器上寻找(未验证)<br><br>   <em><code>gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户id]</code></em> <br><br>   <strong>注意：</strong><br><br>       使用手动导入公钥会出现无法认证的问题，可以使用<br><br>       <em><code>gpg --fingerpring</code></em> <br><br>       打印指纹，指纹是每对密钥生成的时候生成的，查看指纹后可以通过电话或者其他方式到提供者验证指纹<br><br>       然后使用以下命令<br><br>       <em><code>gpg --sign-key [公钥id]</code></em><br><br>       或者使用如下命令删除<br><br>       <em><code>gpg --delete-keys [公钥id]</code></em><br></p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="6-公钥加密"><a href="#6-公钥加密" class="headerlink" title="6.公钥加密"></a>6.公钥加密</h2><blockquote>
<p> <em><code>gpg -r [用户id] -o [输出文件] -e [加密文件]</code></em><br><br>   -r 接受者的公钥的id，可以是邮箱<br><br>   -o 输出加密后的文件名<br><br>   -e 要执行加密操作的数据<br></p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="7-解密"><a href="#7-解密" class="headerlink" title="7.解密"></a>7.解密</h2><blockquote>
<p> <em><code>gpg [解密文件]</code></em><br><br>  gpg 有一个默认选择 -d 默认使用你的私钥解密别人使用你的公钥解密传送过来的数据</p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8.数字签名"></a>8.数字签名</h2><blockquote>
<p>   <em><code>gpg -s [文件名]</code></em> 生成一份签名<br><br>    <em><code>gpg --clearsign [文件名]</code></em> 生成一份明文签名<br><br>    <em><code>gpg -a -b [文件名]</code></em> 生成一份分离的明文签名(去掉-a就是二进制签名)<br></p>
</blockquote>
</blockquote>
<blockquote>
<h2 id="9-验证签名"><a href="#9-验证签名" class="headerlink" title="9.验证签名"></a>9.验证签名</h2><blockquote>
<p>   <em><code>gpg --verify</code></em> [被签名的文件]<br></p>
</blockquote>
</blockquote>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/07/gpg.html</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.williamlong.info/archives/3439.html" target="_blank" rel="noopener">http://www.williamlong.info/archives/3439.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pgp</tag>
      </tags>
  </entry>
  <entry>
    <title>基于github+hexo的个人博客</title>
    <url>/2017/12/09/%E5%9F%BA%E4%BA%8Egithub-hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="基于github-hexo的个人博客"><a href="#基于github-hexo的个人博客" class="headerlink" title="基于github+hexo的个人博客"></a>基于github+hexo的个人博客</h1><h2 id="1-本地环境配置"><a href="#1-本地环境配置" class="headerlink" title="1. 本地环境配置"></a>1. 本地环境配置</h2><blockquote>
<p>操作系统为 ubuntu16.04</p>
</blockquote>
<h3 id="1-git"><a href="#1-git" class="headerlink" title="1. git"></a>1. git</h3><blockquote>
<p>使用 <code>sudo apt install git</code>下载git</p>
</blockquote>
<h3 id="2-node-js"><a href="#2-node-js" class="headerlink" title="2. node.js"></a>2. node.js</h3><blockquote>
<p>安装命令 <code>wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code></p>
</blockquote>
<blockquote>
<p> <code>nvm install stable</code></p>
</blockquote>
<h3 id="3-hexo"><a href="#3-hexo" class="headerlink" title="3. hexo"></a>3. hexo</h3><blockquote>
<p><code>npm install -g hexo-cli</code> 安装hexo</p>
</blockquote>
<blockquote>
<p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo安装</a></p>
</blockquote>
<h2 id="2-github-配置"><a href="#2-github-配置" class="headerlink" title="2. github 配置"></a>2. github 配置</h2><blockquote>
<p>前往github主页新建一个仓库，仓库名为 xxx.github.io(到时候通过xxx.github.io就可以访问个人博客，xxx最好是和github账户名相同，不同不知道是否可以)</p>
</blockquote>
<h2 id="3-创建本地文件资源"><a href="#3-创建本地文件资源" class="headerlink" title="3.创建本地文件资源"></a>3.创建本地文件资源</h2><blockquote>
<p>在/home/canxing/目录下创建保存博客资源文件夹</p>
</blockquote>
<blockquote>
<p><code>makir myblog</code></p>
</blockquote>
<blockquote>
<p>使用hexo初始化</p>
</blockquote>
<blockquote>
<p><code>hexo init ~/myblog</code></p>
</blockquote>
<blockquote>
<p>进入myblog文件夹</p>
</blockquote>
<blockquote>
<p>生成hexo所需要的文件目录</p>
</blockquote>
<blockquote>
<p><code>npm install</code></p>
</blockquote>
<blockquote>
<p>使用 <code>hexo s</code> 命令开启hexo服务，并通过localhost:4000 就可以访问一个初始的模板</p>
</blockquote>
<h2 id="4-配置hexo"><a href="#4-配置hexo" class="headerlink" title="4. 配置hexo"></a>4. 配置hexo</h2><blockquote>
<p>hexo文件夹根目录下的_config.yml 文件为hexo的配置文件<br><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">官方配置参数</a><br><a href="http://blog.junyu.io/posts/0004-hexo-config-settings.html" target="_blank" rel="noopener">参考配置说明</a></p>
</blockquote>
<blockquote>
<p>部分参数说明如下</p>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>title:网站主标题</li>
<li>subtitle: 子标题</li>
<li>description: 网站描述</li>
<li>author: 作者</li>
<li>language: zh_CN</li>
<li>timezone: 时区，没有设置为本地时区设置</li>
<li>url: 你的网站域名</li>
<li>root: 根路径</li>
<li>permalink:生成的链接的格式</li>
<li>theme:生成的博客系统样式，就是视图表示，可以前往<a href="https://hexo.io/themes/#responsive" target="_blank" rel="noopener">hexo样式</a>选择喜欢的样式然后使用git clone到本地</li>
<li>deploy: 部署选项，包括部署类型，仓库url，分支等<blockquote>
<ul>
<li>type: git</li>
<li>repo: 仓库url</li>
<li>branch: 一般是master</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
</blockquote>
<h2 id="5-hexo预览和部署"><a href="#5-hexo预览和部署" class="headerlink" title="5. hexo预览和部署"></a>5. hexo预览和部署</h2><blockquote>
<ol>
<li><code>hexo s</code>开启hexo服务器，在网页中可以输入localhost:4000可以查看预览</li>
<li><code>hexo g</code>生成新的文件资源</li>
<li><code>hexo d</code>部署到github上，部署路径为_config.yml文件中的deploy的选项</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述一-链表</title>
    <url>/2017/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%80-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表由一系列不必在内存中相连的结构组成，每一个结构单元均含有表元素和指向包含该元素后继元素的结构的指针</p>
<p>如图所示<br><img src="有头节点的链表.png" alt="带头节点的链表"></p>
<p>链表可以有两种表现形式，一种是带有头节点的链表(如上图所示)，另一种是不带有头节点的链表，一般来说带有头节点的链表很多时候处理起来比不带头节点的方便，因此这里选择带有头节点的链表展示</p>
<p>链表定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件中定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ElementType</span> <span class="title">ElementType</span>;</span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">(List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLast</span><span class="params">(Position P,List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(ElementType X,List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">(ElementType X,List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,List L,Position P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Header</span><span class="params">(List L)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">First</span><span class="params">(List L)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(List L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在具体的实现文件中定义每个节点中的数据，这里选择int类型的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElementType</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	Position Next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="主要功能实现"><a href="#主要功能实现" class="headerlink" title="主要功能实现"></a>主要功能实现</h2><p>链表中稍微复杂的功能主要集中在删除和插入操作，删除和插入功能主要涉及到链表指针的移动以及内存的分配和释放</p>
<p><img src="链表的删除.png" alt="链表的删除"></p>
<p>当链表删除时，就需要调整指针，将删除节点的前驱节点的后继指针指向删除节点的后继节点，并释放删除节点所占用的内存空间</p>
<p><img src="链表的插入.png" alt="链表的插入"></p>
<p>当链表插入元素时，需要分配内存空间，创建一个新的节点，并将指定节点的后继指针指向新增节点，再把新增节点的后继指针指向原来指定节点的后继节点</p>
<h3 id="链表插入操作实现代码"><a href="#链表插入操作实现代码" class="headerlink" title="链表插入操作实现代码"></a>链表插入操作实现代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,List L,Position P)</span></span>&#123;</span><br><span class="line">	Position ptr ;</span><br><span class="line">	ptr = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">	<span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	ptr-&gt;Element = X;</span><br><span class="line">	ptr-&gt;Next = P-&gt;Next;</span><br><span class="line">	P-&gt;Next = ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表删除操作实现代码"><a href="#链表删除操作实现代码" class="headerlink" title="链表删除操作实现代码"></a>链表删除操作实现代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(List L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L == <span class="literal">NULL</span> || L-&gt;Next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	Position ptr = <span class="literal">NULL</span>;</span><br><span class="line">	Position temp = <span class="literal">NULL</span>;</span><br><span class="line">	ptr = L-&gt;Next;</span><br><span class="line">	L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		temp = ptr;</span><br><span class="line">		ptr = ptr-&gt;Next;</span><br><span class="line">		temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述七-开放定址散列表</title>
    <url>/2018/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%83-%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="什么是开放定址法"><a href="#什么是开放定址法" class="headerlink" title="什么是开放定址法"></a>什么是开放定址法</h2><p>开放定址法是另一种不用链表解决散列表冲突问题的方法，在开放定址散列算法系统中，如果发生冲突，那么就要尝试选择另外的单元，直到找出空的单元为止</p>
<h2 id="冲突解决的方法"><a href="#冲突解决的方法" class="headerlink" title="冲突解决的方法"></a>冲突解决的方法</h2><ol>
<li>线性探测法</li>
<li>平方探测法</li>
<li>双散列</li>
</ol>
<p>这里使用平方探测法进行示例，平方探测法在第一次冲突时将第一次哈希值的结果加上 F(i)，如果还是冲突，那么 i 加 1 ,再次使用第一次哈希值加上 F(i) 以此循环; F(i) = i * i(i = 1)</p>
<h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> Index Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>* <span class="title">HashTable</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function">HashTable <span class="title">InitializeTable</span><span class="params">(<span class="keyword">int</span> TableSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyTable</span><span class="params">(HashTable H)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType key,HashTable H)</span></span>;</span><br><span class="line"><span class="function">HashTable <span class="title">Insert</span><span class="params">(ElementType key,HashTable H)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Index <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> key,<span class="keyword">int</span> TableSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> KindOfEntry&#123;Legitimate,Empty,Deleted&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	<span class="keyword">enum</span> KindOfEntry Info;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> <span class="title">Cell</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> TableSize;</span><br><span class="line">	<span class="keyword">int</span> Capacity;</span><br><span class="line">	Cell* TheCells;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在哈希表中，保存有哈希表的表长，当前表的容量，以及存储单元，每个存储单元保存实际存储的值，以及存储单元的信息，包括已经存储，没有存储和原来有存储现在被删除三种信息</p>
<h2 id="哈希表的插入"><a href="#哈希表的插入" class="headerlink" title="哈希表的插入"></a>哈希表的插入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HashTable <span class="title">Insert</span><span class="params">(ElementType key,HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">	<span class="keyword">int</span> index = Hash(key,H-&gt;TableSize);</span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//检查表容量</span></span><br><span class="line">	<span class="keyword">if</span>(H-&gt;Capacity &gt;= H-&gt;TableSize) &#123;</span><br><span class="line">		<span class="keyword">return</span> H;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找可以可以插入的点</span></span><br><span class="line">	<span class="keyword">while</span>(H-&gt;TheCells[index].Info == Legitimate)&#123;</span><br><span class="line">		index = index + <span class="number">2</span> * (++number) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(index &gt;= H-&gt;TableSize)</span><br><span class="line">			index = index - H-&gt;TableSize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//插入数据，重置单元信息，表容量加1</span></span><br><span class="line">	H-&gt;TheCells[index].Element = key;</span><br><span class="line">	H-&gt;TheCells[index].Info = Legitimate;</span><br><span class="line">	H-&gt;Capacity++;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表的查找"><a href="#哈希表的查找" class="headerlink" title="哈希表的查找"></a>哈希表的查找</h2><p>查找操作也是和插入操作差不多的，不同的是如果查找的单元为空，则说明查找不成功</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType key,HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> index = Hash(key,H-&gt;TableSize);</span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;TheCells[index].Info == Empty)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;TheCells[index].Element == key) <span class="keyword">return</span> index;</span><br><span class="line">		index += <span class="number">2</span> * (++number) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(index &gt;= H-&gt;TableSize)</span><br><span class="line">			index = index - H-&gt;TableSize;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述三-二叉查找树</title>
    <url>/2018/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B8%89-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<p>二叉查找树是二叉树的特殊形式，主要性质是，对于树中的每个节点X，它的左子树中所有值小于X的值，而它的右子树中所有值大于X的值</p>
<p>因此，二叉查找树可以用某种统一的方式排序</p>
<p><img src="二叉查找树模型.png" alt="二叉查找树模型"></p>
<p>根据这一性质，可以对二叉查找树有如下的函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件中的函数定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">SearchTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(ElementType X,SearchTree T)</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(ElementType X,SearchTree T)</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindPositionUp</span><span class="params">(SearchTree T,ElementType X)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现文件中树节点的定义，这里将树节点元素类型定义为int类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	SearchTree Left;</span><br><span class="line">	SearchTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数实现</p>
<p>二叉查找树中最主要的两个功能就是插入数据和删除数据，在插入和删除数据之后需要保持整个二叉查找树任然具备二叉查找树的性质，这是很关键的</p>
<h2 id="插入功能的实现"><a href="#插入功能的实现" class="headerlink" title="插入功能的实现"></a>插入功能的实现</h2><p>根据二叉查找树的性质，那么要插入的数据是出入叶子节点<br>实现算法如下:</p>
<ol>
<li>判断插入元素与根节点元素的大小:</li>
<li>如果被插入的树是空树，那么分配内存空间并将新节点插入空树中;</li>
<li>如果插入元素大于根节点元素，使用递归的方式将插入元素插入到根节点的右子树上;</li>
<li>如果插入元素小于根节点元素，使用递归的方式将插入元素插入根节点的左子树上;</li>
<li>如果插入元素等于根节点元素，什么也不做</li>
</ol>
<p>代码实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(ElementType X,SearchTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			T = (SearchTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">		<span class="keyword">if</span>(T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"初始化树失败\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		T-&gt;Element = X;</span><br><span class="line">		T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;Element)&#123;</span><br><span class="line">		T-&gt;Left = Insert(X,T-&gt;Left);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;Element)&#123;</span><br><span class="line">		T-&gt;Right = Insert(X,T-&gt;Right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除功能的实现"><a href="#删除功能的实现" class="headerlink" title="删除功能的实现"></a>删除功能的实现</h2><p>删除功能相比于插入功能要困难， 如果删除的节点是叶子节点直接删除就行了， 如果删除的节点不是叶子节点，那么就需要找到一个节点来代替这个删除节点继续维持性质</p>
<p>删除功能算法如下:</p>
<ol>
<li>如果删除元素小于根节点元素，就去根节点的左子树删除该元素</li>
<li>如果删除元素大于根节点元素，就去根节点的右子树删除该元素</li>
<li>如果删除元素等于根节点元素，并且这个根节点还有两个子节点，先找到根节点右子树的最小值(或者根节点左子树的最大值)，将根节点的值修改为右子树的最小值(或者左子树的最大值)，然后去根节点的右子树删除最小值(或者去根节点的左子树删除最大值)。这里实际上把删除一个根节点改变为删除一个叶子节点</li>
<li>如果删除元素等于根节点，并且这个根节点只有一个或者没有子节点<br>4.1 如果根节点只有右节点，将根节点变为右节点<br>4.2 如果根节点只有左节点，将根节点变为左节点<br>4.3 如果根节点没有子节点，参照4.1</li>
</ol>
<p>代码实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(ElementType X,SearchTree T)</span></span>&#123;</span><br><span class="line">	Position ptr = T;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> T;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;Element) T-&gt;Left = Delete(X,T-&gt;Left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;Element) T-&gt;Right = Delete(X,T-&gt;Right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Left != <span class="literal">NULL</span>  &amp;&amp; T-&gt;Right != <span class="literal">NULL</span>)&#123; </span><br><span class="line">		<span class="comment">//找到根节点右子树的最小值</span></span><br><span class="line">		ptr = FindMin(T-&gt;Right);</span><br><span class="line">		<span class="comment">//将右子树的最小值赋给根节点</span></span><br><span class="line">		T-&gt;Element = ptr-&gt;Element;</span><br><span class="line">		<span class="comment">//前往右子树删除最小值</span></span><br><span class="line">		T-&gt;Right = Delete(T-&gt;Element,T-&gt;Right);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ptr = T;</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;Left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			T = T-&gt;Right;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			T = T-&gt;Left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉查找树可以方便的查找，但是在某些情况下，如果在二叉查找树中依次插入 1,2,3,4,5,6，那么得到的二叉查找树图如下:</p>
<p><img src="二叉查找树的不平衡插入.png" alt="二叉查找树的不平衡插入"></p>
<p>这样的情况不是我们想看见的，在这种情况下使用平衡二叉树可以改善这个问题</p>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述九-插入排序和希尔排序</title>
    <url>/2018/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%B9%9D-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序基于这样一种情况，待插入的数组是顺序的(升序或降序)，此时将插入数据从数组从后向前比较，满足条件就插入，不满足就依次向后移动</p>
<p>插入排序就好象玩扑克时一张一张的拿牌，大的在左边，小的在右边，每拿一张牌就从右到左一次比较，在第一张大于的牌的右边插入新的扑克</p>
<h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(ElementType* <span class="built_in">array</span>,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayMaxIndex = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> arrayMinIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(index = arrayMinIndex + <span class="number">1</span>;index &lt;= arrayMaxIndex;index++)&#123;</span><br><span class="line">		<span class="keyword">int</span> insertValue = <span class="built_in">array</span>[index];</span><br><span class="line">		<span class="keyword">for</span>(j = index - <span class="number">1</span>;j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; insertValue;j--)&#123;</span><br><span class="line">			<span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">array</span>[j + <span class="number">1</span>] = insertValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序通过比较相距一定间隔的元素来工作，将比较的元素按照大小排列到比较元素的位置，然后通过减小间隔再次比较，最后间隔为1时所有比较完成</p>
<p><img src="希尔排序.png" alt="希尔排序"></p>
<p>最上面数据为未排序数据，由上往下增量依次为 5,3,1</p>
<h3 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(ElementType* <span class="built_in">array</span>,<span class="keyword">int</span> increment,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayMinIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arrayMaxIndex = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sortTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> insertValue = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//当一趟的增量大于排序数组长度时进行的处理</span></span><br><span class="line">	<span class="keyword">if</span>(increment &gt; len)&#123;</span><br><span class="line">		shellSort(<span class="built_in">array</span>,<span class="number">1</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;sortTime &lt; increment;sortTime++)&#123;</span><br><span class="line">		<span class="comment">//插入排序的变形</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = sortTime + increment;i &lt; len;i += increment)&#123;</span><br><span class="line">			insertValue = <span class="built_in">array</span>[i];</span><br><span class="line">			<span class="keyword">for</span>(j = i - increment;j &gt;= arrayMinIndex &amp;&amp; <span class="built_in">array</span>[j] &gt;= insertValue;j -= increment)&#123;</span><br><span class="line">				<span class="built_in">array</span>[j + increment] = <span class="built_in">array</span>[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">array</span>[j + increment] = insertValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述二-栈</title>
    <url>/2017/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%8C-%E6%A0%88/</url>
    <content><![CDATA[<p>栈又称堆栈，仅允许在表的一端进行插入和删除操作的线性表，该位置位于表尾，称为栈顶(Top)，相对地，另一端称为栈底。由于栈的插入和删除运算只能在栈顶一端进行，后进栈元素必定先出栈，所以把栈称为后进先出表(last in first out 简称 LIFO)</p>
<p>这里使用链表实现栈</p>
<p><img src="栈模型.png" alt="栈模型"></p>
<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件中的函数定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Stack;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//创建一个空栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">(Stack S)</span></span>;<span class="comment">//删除栈中的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(ElementType X,Stack S)</span></span>;<span class="comment">//将数据压入栈栈有两种实现方式，一种使用顺序表，另一种使用链表方式实现</span></span><br><span class="line"><span class="function">ElementType <span class="title">Top</span><span class="params">(Stack S)</span></span>;<span class="comment">//返回栈顶的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack S)</span></span>;<span class="comment">//弹出栈顶的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(Stack S)</span></span>;<span class="comment">//遍历栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现文件中栈节点的定义，使用int类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	PtrToNode Next;<span class="comment">//因为是使用链表，所以这个执行下一个节点地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>栈的主要操作集中在Push和Pop操作，前者向栈中压入一个数据，后者从栈中弹出一个数据</p>
<h3 id="Push功能实现"><a href="#Push功能实现" class="headerlink" title="Push功能实现"></a>Push功能实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(ElementType X,Stack S)</span></span>&#123;</span><br><span class="line">	PtrToNode Node;</span><br><span class="line">	Node = (PtrToNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">	<span class="keyword">if</span>(Node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	Node-&gt;Element = X;</span><br><span class="line">	Node-&gt;Next = S-&gt;Next;</span><br><span class="line">	S-&gt;Next = Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pop功能实现"><a href="#Pop功能实现" class="headerlink" title="Pop功能实现"></a>Pop功能实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(S)) <span class="keyword">return</span>;</span><br><span class="line">	PtrToNode temp = S-&gt;Next;</span><br><span class="line">	S-&gt;Next = temp-&gt;Next;</span><br><span class="line">	temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述五-伸展树</title>
    <url>/2018/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E4%BA%94-%E4%BC%B8%E5%B1%95%E6%A0%91/</url>
    <content><![CDATA[<h2 id="什么是伸展树"><a href="#什么是伸展树" class="headerlink" title="什么是伸展树"></a>什么是伸展树</h2><p>伸展树保证了从空树开始任意连续 M 次对树的操作最多话费 O(M log N) 时间，伸展树是二叉搜索树的一种变形，不同于 AVL 树，伸展树不需要维护节点的高度，相对 AVL 树来说比较容易实现</p>
<p>当一个节点被访问时它就有可能在不久之后被再次访问，因此，伸展树的基本思想是：当一个节点被访问，它就经过一系列 AVL 树的旋转操作将该节点放到根上</p>
<p>将某个节点经过一系列的变形移动到树根上的操作称之为伸展(Splay)，伸展操作主要进行六个形态的转变，再将伸展节点伸展之后会再次检查伸展节点的位置，如果伸展节点是根结点则返回，否则继续伸展</p>
<ol>
<li><img src="根结点的左儿子是伸展节点.png" alt="根结点的左儿子是伸展节点"></li>
<li><img src="根结点的右儿子是伸展节点.png" alt="根结点的右儿子是伸展节点"></li>
<li><img src="祖父节点的左儿子是伸展节点的父儿子并且伸展节点是父结点的左儿子.png" alt="父结点的左儿子是伸展节点并且父结点是父结点的左儿子"></li>
<li><img src="祖父节点的左儿子是伸展节点的父儿子并且伸展节点是父结点的右儿子.png" alt="父结点的右儿子是伸展节点并且父结点是父结点的左儿子"></li>
<li><img src="祖父节点的右儿子是伸展节点的父儿子并且伸展节点是父结点的左儿子.png" alt="父结点的左儿子是伸展节点并且父结点是父结点的右儿子"></li>
<li><img src="祖父节点的右儿子是伸展节点的父儿子并且伸展节点是父结点的右儿子.png" alt="父结点的右儿子是伸展节点并且父结点是父结点的右儿子"></li>
</ol>
<h2 id="伸展树声明"><a href="#伸展树声明" class="headerlink" title="伸展树声明"></a>伸展树声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayTree <span class="title">MakeEmpty</span><span class="params">(SplayTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,SplayTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SplayTree T)</span></span>;	</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SplayTree T)</span></span>;</span><br><span class="line"><span class="function">SplayTree <span class="title">Insert</span><span class="params">(ElementType X,SplayTree T)</span></span>;	</span><br><span class="line"><span class="function">SplayTree <span class="title">Delete</span><span class="params">(ElementType X,SplayTree T)</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindPositionUp</span><span class="params">(SplayTree T,ElementType X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(SplayTree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotaleWithLeft</span><span class="params">(Position T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotaleWithRight</span><span class="params">(Position T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">ContinuRotaleWithLeft</span><span class="params">(Position T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">ContinuRotaleWithRight</span><span class="params">(Position T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotaleWithLeft</span><span class="params">(Position T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotaleWithRight</span><span class="params">(Position T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">Splay</span><span class="params">(ElementType X,SplayTree T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	SplayTree Left;</span><br><span class="line">	SplayTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="伸展功能"><a href="#伸展功能" class="headerlink" title="伸展功能"></a>伸展功能</h2><p>伸展功能依赖于 6 个函数分别时左旋转，右旋转，连续左旋转，连续右旋转，左双旋转，右双旋转，分别对应 6 中变形</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotaleWithLeft</span><span class="params">(Position T)</span></span>&#123;</span><br><span class="line">	Position ptr = T-&gt;Left;</span><br><span class="line">	T-&gt;Left = ptr-&gt;Right;</span><br><span class="line">	ptr-&gt;Right = T;</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">SingleRotaleWithRight</span><span class="params">(Position T)</span></span>&#123;</span><br><span class="line">	Position ptr = T-&gt;Right;</span><br><span class="line">	T-&gt;Right = ptr-&gt;Left;</span><br><span class="line">	ptr-&gt;Left = T;</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连续左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">ContinuRotaleWithLeft</span><span class="params">(Position T)</span></span>&#123;</span><br><span class="line">	Position ptr = SingleRotaleWithLeft(T);</span><br><span class="line">	<span class="keyword">return</span> SingleRotaleWithLeft(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左双旋转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotaleWithLeft</span><span class="params">(Position T)</span></span>&#123;</span><br><span class="line">	T-&gt;Right = SingleRotaleWithLeft(T-&gt;Right);</span><br><span class="line">	<span class="keyword">return</span> SingleRotaleWithRight(T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连续右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">ContinuRotaleWithRight</span><span class="params">(Position T)</span></span>&#123;</span><br><span class="line">	Position ptr = SingleRotaleWithRight(T);</span><br><span class="line">	<span class="keyword">return</span> SingleRotaleWithRight(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右双旋转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">DoubleRotaleWithRight</span><span class="params">(Position T)</span></span>&#123;</span><br><span class="line">	T-&gt;Left = SingleRotaleWithRight(T-&gt;Left);</span><br><span class="line">	<span class="keyword">return</span> SingleRotaleWithLeft(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伸展树的伸展流程如下:</p>
<ol>
<li>伸展节点为根节点，不做任何改变，并返回</li>
<li>伸展节点是根结点的左儿子，将伸展节点向左旋转</li>
<li>伸展节点是根结点的右儿子，将伸展节点向左旋转</li>
<li>伸展节点不属于上述三种情况，将伸展节点称为X,X的父结点称为F，F的父结点称为G，G节点就是X节点的’祖父’节点<br>4.1. 如果G的左儿子是F，并且F的左儿子是X，进行连续左旋转<br>4.2. 如果G的右儿子是F，并且F的右儿子是X，进行连续右旋转<br>4.3. 如果G的左儿子是F，并且F的右儿子是X，进行左双旋转<br>4.4. 如果G的右儿子是F，并且F的左儿子是X，进行有双旋转</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Position <span class="title">Splay</span><span class="params">(ElementType X,SplayTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span> || T-&gt;Element == X) <span class="keyword">return</span> T;</span><br><span class="line">	<span class="comment">//查找伸展节点的父结点</span></span><br><span class="line">	Position fatherNode = FindPositionUp(T,X);</span><br><span class="line">	<span class="keyword">if</span>(fatherNode == T)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fatherNode-&gt;Left != <span class="literal">NULL</span> &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123;</span><br><span class="line">			<span class="comment">//伸展节点属于根结点的左儿子</span></span><br><span class="line">			<span class="keyword">return</span> SingleRotaleWithLeft(fatherNode);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(fatherNode-&gt;Right != <span class="literal">NULL</span> &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123;</span><br><span class="line">			<span class="comment">//伸展节点属于根结点的右儿子</span></span><br><span class="line">			<span class="keyword">return</span> SingleRotaleWithRight(fatherNode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		Position grandNode = FindPositionUp(T,fatherNode-&gt;Element);</span><br><span class="line">		Position grandGrandNode = FindPositionUp(T,grandNode-&gt;Element);</span><br><span class="line">		Position temp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">int</span> level = <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">//判断伸展节点，父结点和祖父节点的关系</span></span><br><span class="line">		<span class="keyword">if</span>(grandNode-&gt;Left != <span class="literal">NULL</span> &amp;&amp; grandNode-&gt;Left == fatherNode)&#123;</span><br><span class="line">			<span class="keyword">if</span>(fatherNode-&gt;Left != <span class="literal">NULL</span> &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123;</span><br><span class="line">				level = <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(fatherNode-&gt;Right != <span class="literal">NULL</span> &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123;</span><br><span class="line">				level = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(grandNode-&gt;Right != <span class="literal">NULL</span> &amp;&amp; grandNode-&gt;Right == fatherNode)&#123;</span><br><span class="line">			<span class="keyword">if</span>(fatherNode-&gt;Left != <span class="literal">NULL</span> &amp;&amp; fatherNode-&gt;Left-&gt;Element == X)&#123;</span><br><span class="line">				level = <span class="number">3</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(fatherNode-&gt;Right != <span class="literal">NULL</span> &amp;&amp; fatherNode-&gt;Right-&gt;Element == X)&#123;</span><br><span class="line">				level = <span class="number">4</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span>(level)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//左左</span></span><br><span class="line">			temp = ContinuRotaleWithLeft(grandNode);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//左右</span></span><br><span class="line">			temp = DoubleRotaleWithRight(grandNode);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//右左</span></span><br><span class="line">			temp = DoubleRotaleWithLeft(grandNode);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//右右</span></span><br><span class="line">			temp = ContinuRotaleWithRight(grandNode);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(grandNode == T)</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(grandGrandNode-&gt;Left == grandNode)</span><br><span class="line">			grandGrandNode-&gt;Left = temp;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(grandGrandNode-&gt;Right == grandNode)</span><br><span class="line">			grandGrandNode-&gt;Right = temp;</span><br><span class="line">		<span class="keyword">return</span> Splay(X,T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>查询操作先要确定树中含有要查询的节点，如果没有则直接返回，否则将查询到的节点进行伸展移动到根结点然后返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,SplayTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;Element == X) <span class="keyword">return</span> T;</span><br><span class="line">	Position dst = T;</span><br><span class="line">	<span class="keyword">while</span>(dst != <span class="literal">NULL</span> &amp;&amp; X != dst-&gt;Element)&#123;</span><br><span class="line">		<span class="keyword">if</span>(X &lt; dst-&gt;Element)</span><br><span class="line">			dst = dst-&gt;Left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; dst-&gt;Element)</span><br><span class="line">			dst = dst-&gt;Right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dst != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> Splay(X,T);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>插入操作先将元素按照二叉搜索树的性质插入树中，然后在将插入的节点伸展到根结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayTree <span class="title">Insert</span><span class="params">(ElementType X,SplayTree T)</span></span>&#123;</span><br><span class="line">	Position temp = <span class="literal">NULL</span>;</span><br><span class="line">	temp = (SplayTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">	<span class="keyword">if</span>(temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"初始化树失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;Element = X;</span><br><span class="line">	temp-&gt;Left = temp-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		T = temp;</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	&#125;</span><br><span class="line">	Position ptr = T;</span><br><span class="line">	<span class="comment">//按照二叉搜索树的性质插入节点</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			ptr = ptr-&gt;Left;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			ptr = ptr-&gt;Right;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &lt; ptr-&gt;Element &amp;&amp; ptr-&gt;Left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			ptr-&gt;Left = temp;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(X &gt; ptr-&gt;Element &amp;&amp; ptr-&gt;Right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			ptr-&gt;Right = temp;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Splay(X,T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作先将删除节点伸展到根结点，此时，根结点的左子树元素都小于根节点，右子树元素都大于根结点，删除根结点，然后将左子树的最大元素进行伸展，此时左子树根结点是左子树中的最大元素，没有右儿子，然后再将左子树的右指针指向右子树，删除完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SplayTree <span class="title">Delete</span><span class="params">(ElementType X,SplayTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(X == T-&gt;Element)&#123;</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;Left == <span class="literal">NULL</span>) <span class="keyword">return</span> T-&gt;Right;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;Right == <span class="literal">NULL</span>) <span class="keyword">return</span> T-&gt;Left;</span><br><span class="line">		<span class="comment">//再查找最大元素的同时就对最大元素进行了伸展操作</span></span><br><span class="line">		Position left = FindMax(T-&gt;Left);</span><br><span class="line">		left-&gt;Right = T-&gt;Right;</span><br><span class="line">		<span class="built_in">free</span>(T);</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	T = Splay(X,T);</span><br><span class="line">	<span class="keyword">return</span> Delete(X,T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述八-再散列</title>
    <url>/2018/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AB-%E5%86%8D%E6%95%A3%E5%88%97/</url>
    <content><![CDATA[<h2 id="什么是再散列"><a href="#什么是再散列" class="headerlink" title="什么是再散列"></a>什么是再散列</h2><p>再散列也是散列表的一种，不同的是再散列可以动态的扩充表长，再搭配好的散列函数解决冲突</p>
<p>再散列在散列表到达某一临界点时扩充原来表长的容量，再将原来散列表中的数据重新散列移动到新的散列表的过程</p>
<h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> Index Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>* <span class="title">HashTable</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function">HashTable <span class="title">InitializeTable</span><span class="params">(<span class="keyword">int</span> TableSize,<span class="keyword">float</span> Facotr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyTable</span><span class="params">(HashTable H)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType key,HashTable H)</span></span>;</span><br><span class="line"><span class="function">HashTable <span class="title">Insert</span><span class="params">(ElementType key,HashTable H)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(ElementType key,HashTable H)</span></span>;</span><br><span class="line"><span class="function">HashTable <span class="title">Rehash</span><span class="params">(HashTable H)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Index <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> key,<span class="keyword">int</span> TableSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> KindOfEntry&#123;Legitimate,Emtry,Deleted&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	<span class="keyword">enum</span> KindOfEntry Info;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashEntry</span> <span class="title">Cell</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> TableSize;</span><br><span class="line">	<span class="keyword">int</span> Capacity;</span><br><span class="line">	<span class="keyword">float</span> LocalFacotr;<span class="comment">//装填因子</span></span><br><span class="line">	<span class="keyword">int</span> MaxCapacity;<span class="comment">//散列表所能容纳的最大容量，超过该容量后就要扩容</span></span><br><span class="line">	Cell* TheCells;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里采用当散列表容量达到指定的装填因子时进行再散列，采用的默认散列因子是 0.75，TableSize 表示散列表的长度，Capacity 表示散列表容乃数据的大小，MaxCapacity 表示散列表可以容纳的最大容量，由 TableSize × LocalFacotr 得出</p>
<h2 id="散列表的插入"><a href="#散列表的插入" class="headerlink" title="散列表的插入"></a>散列表的插入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HashTable <span class="title">Insert</span><span class="params">(ElementType key,HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">	<span class="keyword">if</span>(H-&gt;Capacity &gt;= H-&gt;MaxCapacity)&#123;</span><br><span class="line">		H = Rehash(H);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> index = Hash(key,H-&gt;TableSize);</span><br><span class="line">	<span class="comment">//如果已经在相同下标的散列表上有值，那就不管了</span></span><br><span class="line">	<span class="keyword">if</span>(H-&gt;TheCells[index].Info != Emtry)&#123;</span><br><span class="line">		<span class="keyword">return</span> H;</span><br><span class="line">	&#125;</span><br><span class="line">	H-&gt;Capacity++;</span><br><span class="line">	H-&gt;TheCells[index].Element = key;</span><br><span class="line">	H-&gt;TheCells[index].Info = Legitimate;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当散列表的容量超过最大容量是就要使用再散列方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HashTable <span class="title">Rehash</span><span class="params">(HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	HashTable T = InitializeTable(H-&gt;TableSize &lt;&lt; <span class="number">1</span>,H-&gt;LocalFacotr);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; H-&gt;TableSize;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(H-&gt;TheCells[i].Element != <span class="number">0</span>)</span><br><span class="line">			Insert(H-&gt;TheCells[i].Element,T);</span><br><span class="line">	&#125;</span><br><span class="line">	DestroyTable(H);</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述六-分离链接散列表</title>
    <url>/2018/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%85%AD-%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="什么是分离链接散列表"><a href="#什么是分离链接散列表" class="headerlink" title="什么是分离链接散列表"></a>什么是分离链接散列表</h2><p>分离链接散列表是散列表解决冲突的一种方法，其做法是将散列到同一个值的所有元素保留到一个表中。为方便起见，这些表都有表头</p>
<p><img src="分离链接散列表.png" alt="分离链接散列表"></p>
<p>分离链接散列表的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">Position</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>* <span class="title">HashTable</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function">HashTable <span class="title">InitializeTable</span><span class="params">(<span class="keyword">int</span> TableSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyTable</span><span class="params">(HashTable H)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType key,HashTable H)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType key,HashTable H)</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> key,<span class="keyword">int</span> TableSize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	Position Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Position List;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashTbl</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> TableSize;</span><br><span class="line">	List* TheList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="分离链接散列表的初始化"><a href="#分离链接散列表的初始化" class="headerlink" title="分离链接散列表的初始化"></a>分离链接散列表的初始化</h2><p>分离链接散列表在数组的每个位置保存有冲突元素组成链表的表头</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HashTable <span class="title">InitializeTable</span><span class="params">(<span class="keyword">int</span> TableSize)</span></span>&#123;</span><br><span class="line">	HashTable H = <span class="literal">NULL</span>;</span><br><span class="line">	H = (HashTable)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HashTbl));</span><br><span class="line">	<span class="keyword">if</span>(H == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	H-&gt;TableSize = TableSize;</span><br><span class="line">	H-&gt;TheList = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode) * TableSize);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; TableSize;i++)&#123;</span><br><span class="line">		H-&gt;TheList[i] = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		H-&gt;TheList[i]-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分离链接散列表的插入"><a href="#分离链接散列表的插入" class="headerlink" title="分离链接散列表的插入"></a>分离链接散列表的插入</h2><p>插入时先计算Hash值，然后将值作为对应表头的第一个元素，这里就相当与链表的头插法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType key,HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> index = Hash(key,H-&gt;TableSize);</span><br><span class="line">	Position ptr = H-&gt;TheList[index];</span><br><span class="line">	Position temp = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">	<span class="keyword">if</span>(temp == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">	temp-&gt;Element = key;</span><br><span class="line">	temp-&gt;Next = ptr-&gt;Next;</span><br><span class="line">	ptr-&gt;Next = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分离链接散列表的查找"><a href="#分离链接散列表的查找" class="headerlink" title="分离链接散列表的查找"></a>分离链接散列表的查找</h2><p>查找时首先计算要查找值的Hash值，然后返回对应的表头，遍历链表，找到就返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType key,HashTable H)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(H == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> index = Hash(key,H-&gt;TableSize);</span><br><span class="line">	Position ptr = H-&gt;TheList[index];</span><br><span class="line">	ptr = ptr-&gt;Next;</span><br><span class="line">	<span class="keyword">while</span>(ptr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ptr-&gt;Element == key)</span><br><span class="line">			<span class="keyword">return</span> ptr;</span><br><span class="line">		ptr = ptr-&gt;Next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构c语言描述四-AVL树</title>
    <url>/2018/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84c%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E5%9B%9B-AVL%E6%A0%91/</url>
    <content><![CDATA[<p>AVL 树是带有平衡条件的二叉查找树，所谓平衡条件就是:任何节点的深度均不得过深，如下图所示的二叉查找树是不应该出现的</p>
<p><img src="二叉查找树的不平衡插入.png" alt="二叉查找树的不平衡插入"></p>
<p>一颗 AVL 树是其每个节点的左子树和右子树的高度最多差1的二叉查找树（空树的高度定义为-1），这是一颗 AVL 树，树的高度为 3</p>
<p><img src="AVL树模型.png" alt="AVL树模型"></p>
<h1 id="AVL树的定义"><a href="#AVL树的定义" class="headerlink" title="AVL树的定义"></a>AVL树的定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件中的函数定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>* <span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>* <span class="title">AvlTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType ;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">MakeEmpty</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,AvlTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">(ElementType X,AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">(ElementType X,AvlTree T)</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现文件中的树节点定义，这里的树节点元素使用int类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>&#123;</span></span><br><span class="line">	ElementType Element;</span><br><span class="line">	AvlTree Left;</span><br><span class="line">	AvlTree Right;</span><br><span class="line">	<span class="keyword">int</span> Height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看见，AVL 树和二叉查找树的定义没有什么区别，在节点定义上多了一个变量用来存储树的高度</p>
<h2 id="AVL树的实现"><a href="#AVL树的实现" class="headerlink" title="AVL树的实现"></a>AVL树的实现</h2><p>AVL 树的不同主要体现在插入和删除时的不同，在插入和删除时都有可能破坏 AVL 树的平衡，此时就需要对 AVL 树进行平衡修复</p>
<h2 id="AVL树的插入实现"><a href="#AVL树的插入实现" class="headerlink" title="AVL树的插入实现"></a>AVL树的插入实现</h2><p><a href="https://commons.wikimedia.org/w/index.php?curid=12803426" target="_blank" rel="noopener"><img src="Tree_Rebalancing.png" alt="AVL树的插入情况"></a>图摘自维基百科</p>
<p>进行插入操作时，有四种情况可能破坏AVL树的平衡，我们把被破坏的平衡的节点称为root</p>
<ol>
<li>对 root 左儿子的左子树进行一次插入，对应上图的左左情况</li>
<li>对 root 右儿子的右子树进行一次插入，对应上图的右右情况</li>
<li>对 root 左儿子的右子树进行一次插入，对应上图的左右情况</li>
<li>对 root 右儿子的左子树进行一次哈入，对应上图的右左情况</li>
</ol>
<p>对于 1，2 情况，插入节点相对于 root 节点的’外侧’，这时只需要对 root 节点和 root 节点的左儿子或者右儿子进行一次右旋转或者左旋转就可以了; 3，4 情况相对于 root 节点的’内侧’，这是需要实行两次的旋转达到平衡</p>
<p>注意，无论是一次旋转还是两次旋转，都是为了满足二叉查找树的性质和平衡条件</p>
<p>下图演示了依次将 3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9 插入 AVL 树的过程，带箭头的表示插入时使用了旋转操作</p>
<p><img src="插入1到7.png" alt="插入1到7">  </p>
<p>上图演示了从1到7顺序插入AVL树的过程，这里都是1和2的情况</p>
<p><img src="插入模型.png" alt="插入模型"></p>
<h3 id="插入代码实现"><a href="#插入代码实现" class="headerlink" title="插入代码实现"></a>插入代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">(ElementType X,AvlTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		T = (AvlTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AvlNode));</span><br><span class="line">		<span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">		T-&gt;Element = X;</span><br><span class="line">		T-&gt;Height = <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(X &gt; T-&gt;Element)&#123;</span><br><span class="line">			T-&gt;Right = Insert(X,T-&gt;Right);</span><br><span class="line">			<span class="keyword">if</span>(Height(T-&gt;Right) - Height(T-&gt;Left) == <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">if</span>(X &gt; T-&gt;Right-&gt;Element)</span><br><span class="line">					T = SingleRotaleWithRight(T);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					T = DoubleRotaleWithRight(T);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			T-&gt;Left = Insert(X,T-&gt;Left);</span><br><span class="line">			<span class="keyword">if</span>(Height(T-&gt;Left) - Height(T-&gt;Right) == <span class="number">2</span>)</span><br><span class="line">				<span class="keyword">if</span>(X &lt; T-&gt;Left-&gt;Element)</span><br><span class="line">					T = SingleRotaleWithLeft(T);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					T = DoubleRotaleWithLeft(T);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;Height = max(Height(T-&gt;Left),Height(T-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AVL树的删除实现"><a href="#AVL树的删除实现" class="headerlink" title="AVL树的删除实现"></a>AVL树的删除实现</h2><p>AVL树的删除实现比起插入实现要复杂</p>
<p>基本想法是删除成功时，修正删除路径上节点高度，然后判断删除路径上的节点的平衡，然后进行旋转</p>
<p>删除失败时，不改变任何东西  </p>
<p>由于删除功能是按照本人自己的想法实现，实现过程较长，这里不进行展示，如有兴趣可以查看参考源码</p>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>
]]></content>
      <categories>
        <category>data_structure</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>系统监控指标</title>
    <url>/2023/02/19/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h1 id="系统监控指标"><a href="#系统监控指标" class="headerlink" title="系统监控指标"></a>系统监控指标</h1><ul>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/system-metrics/" target="_blank" rel="noopener">Kubernetes 系统组件指标</a></li>
<li><a href="https://yasongxu.gitbook.io/container-monitor/yi-.-kai-yuan-fang-an/di-2-zhang-prometheus/metric" target="_blank" rel="noopener">K8S常用指标分析</a></li>
</ul>
<p>通过系统组件指标可以更好地了解系统组个内部发生的情况。</p>
<p>Kubernetes 组件以 Prometheus 格式 生成度量值。 这种格式是结构化的纯文本，旨在使人和机器都可以阅读。</p>
<p>kubernetes 组件大致有</p>
<ul>
<li>kube-container-manager</li>
<li>kube-proxy</li>
<li>kube-apiserver</li>
<li>kube-scheduler</li>
<li>kubelet</li>
</ul>
<p>大多数情况下可以通过 HTTP 访问组件的 /metrics 端点获取指标的度量值</p>
<p>kubelet 包含了大量 Pod 级别指标，这些指标可以用于展示 Pod 对于资源的使用情况，kubelet 还会在 <code>/metrcis/cadvisor</code>, <code>/metrics/resource</code> 和 <code>/metrics/probes</code> 端点中公开度量值。</p>
<p>一般而言，为了收集 kubernetes 系统的指标，会在 kubernetes 内部部署一个 metrics-server 来统一公开指标，再通过 prometheus 收集指标，最后再通过 grafana 对指标进行图形化展示。</p>
<p>其中 kubelet 存储的 Pod，container，Node 级别的指标最丰富也是最常用的指标。</p>
<p>kubelet 包含的 Pod 级别的指标来自于底层容器运行时，kubelet 通过采集当前节点上容器运行时的目录计算归总得到 Pod 级别指标。</p>
<p>常用的指标有 <code>container_cpu_user_seconds_total</code>, <code>container_cpu_system_seconds_total</code>, <code>container_cpu_usage_seconds_total</code>，具体参考 <a href="https://yasongxu.gitbook.io/container-monitor/yi-.-kai-yuan-fang-an/di-2-zhang-prometheus/metric" target="_blank" rel="noopener">K8S常用指标分析</a></p>
<p>kubernetes 系统更新时有时会对系统指标进行更改，每个版本的指标更改可以通过 kubernetes 工程下的 <a href="https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG" target="_blank" rel="noopener">CHANGELOG</a> 进行查看</p>
<p>在<a href="https://kubernetes.io/docs/reference/instrumentation/metrics/" target="_blank" rel="noopener">这里</a>可以查看最新的 kubenretes 可用指标列表</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 基本命令</title>
    <url>/2018/11/27/linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="linux-基本命令"><a href="#linux-基本命令" class="headerlink" title="linux 基本命令"></a>linux 基本命令</h1><p>参考资料: <a href="http://wangchujiang.com/linux-command/" target="_blank" rel="noopener">Linux 命令搜索</a>，Linux man 指令</p>
<ul>
<li><a href="#linux-基本命令">linux 基本命令</a><ul>
<li><a href="#安装和登录命令">安装和登录命令</a><ul>
<li><a href="#login">login</a></li>
<li><a href="#shutdown">shutdown</a></li>
<li><a href="#halt">halt</a></li>
<li><a href="#reboot">reboot</a></li>
<li><a href="#mount">mount</a></li>
<li><a href="#umount">umount</a></li>
<li><a href="#chsh">chsh</a></li>
</ul>
</li>
<li><a href="#文件处理命令">文件处理命令</a><ul>
<li><a href="#file">file</a></li>
<li><a href="#mkdir">mkdir</a></li>
<li><a href="#grep">grep</a></li>
<li><a href="#dd">dd</a></li>
<li><a href="#find">find</a></li>
<li><a href="#mv">mv</a></li>
<li><a href="#ls">ls</a></li>
<li><a href="#diff">diff</a></li>
<li><a href="#cat">cat</a></li>
<li><a href="#ln">ln</a></li>
</ul>
</li>
<li><a href="#系统管理相关命令">系统管理相关命令</a><ul>
<li><a href="#df">df</a></li>
<li><a href="#top">top</a></li>
<li><a href="#free">free</a></li>
<li><a href="#quota">quota</a></li>
<li><a href="#at">at</a></li>
<li><a href="#lp">lp</a></li>
<li><a href="#adduser">adduser</a></li>
<li><a href="#groupadd">groupadd</a></li>
<li><a href="#kill">kill</a></li>
<li><a href="#crontab">crontab</a></li>
<li><a href="#tar">tar</a></li>
<li><a href="#unzip">unzip</a></li>
<li><a href="#gunzip">gunzip</a></li>
<li><a href="#last">last</a></li>
</ul>
</li>
<li><a href="#网络操作相关命令">网络操作相关命令</a><ul>
<li><a href="#ifconfig">ifconfig</a></li>
<li><a href="#ip">ip</a></li>
<li><a href="#ping">ping</a></li>
<li><a href="#netstat">netstat</a></li>
<li><a href="#telnet">telnet</a></li>
<li><a href="#ftp">ftp</a></li>
<li><a href="#route">route</a></li>
<li><a href="#rlogin">rlogin</a></li>
<li><a href="#rcp">rcp</a></li>
<li><a href="#finger">finger</a></li>
<li><a href="#mail">mail</a></li>
<li><a href="#nslookup">nslookup</a></li>
</ul>
</li>
<li><a href="#系统安全相关命令">系统安全相关命令</a><ul>
<li><a href="#passwd">passwd</a></li>
<li><a href="#su">su</a></li>
<li><a href="#umask">umask</a></li>
<li><a href="#chgrp">chgrp</a></li>
<li><a href="#chown">chown</a></li>
<li><a href="#chmod">chmod</a></li>
<li><a href="#chattr">chattr</a></li>
<li><a href="#sudo">sudo</a></li>
<li><a href="#ps">ps</a></li>
<li><a href="#who">who</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安装和登录命令"><a href="#安装和登录命令" class="headerlink" title="安装和登录命令"></a>安装和登录命令</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>作用: 登陆系统或切换用户身份</p>
<p>补充说明: login 命令 用于给出登录界面，可用于重新登录或者切换用户身份，也可通过它的功能随时更换登入身份。在 Slackware 发行版中 ，您可在命令后面附加欲登入的用户名称，它会直接询问密码，等待用户输入。当 /etc/nologin 文件存在时，系统只 root 帐号登入系统，其他用户一律不准登入。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">login [-p] [-h 主机] [用户名] [ENV=VAR...]</span><br><span class="line">login [-p] [-h 主机] [-f 名称]</span><br><span class="line">login [-p] -r 主机</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f 不要执行认证，用户已经预认证过。</span><br><span class="line">   注意：此时，username 是强制的。</span><br><span class="line">-h 此登录的远程主机名。</span><br><span class="line">-p 保留环境。</span><br><span class="line">-r 为 rlogin (远程登录)执行 autologin (自动登录)协议。</span><br><span class="line"></span><br><span class="line">-r, -h and -f 只能用于 root 使用 login 时。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般用于当前主机切换用户，远程连接使用 SSH 即可。</p>
</blockquote>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>作用: 系统关机命令</p>
<p>补充说明: shutdown  以一种安全的方式关闭系统。所有登陆用户都可以看到关机信息提示，并且 login(1) 将被阻塞。可以指定立刻关机，也可以指定系统在一定的延时后关机。所有进程都将接收到 SIGTERM 信号。这可以使 vi(1) 等程序有时间将处于编辑状态的文件进行存储，邮件和新闻程序进程则可以将所有缓冲池内的数据进行适当的清除等等。 </p>
<p>语法: </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown [-t sec] [-arkhncfF] time [warning-message]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a     使用 /etc/shutdown.allow 来验证身份。</span><br><span class="line">-t sec 通知 init(8) 在转换到其它运行级别前，发送警告 (warning) 信号后延时 (sec) 秒数后再发送关闭 (kill) 信号。</span><br><span class="line">-k     并非真正关机，只向所有人显示警告信息。</span><br><span class="line">-r     重启。</span><br><span class="line">-h     停机。</span><br><span class="line">-n     [DEPRECATED(不应再使用)] 不调用 init(8) 程序进行关机操作，而由自己进行。不建议用户使用这种关机方式，它的结果一般也不是你希望的那样。</span><br><span class="line">-f     重启时跳过磁盘检测。</span><br><span class="line">-F     重启时强制磁盘检测。</span><br><span class="line">-c     取消运行中的 shutdown 进程。不可能为此选项指定 time 参数，但你可以在命令行输入一条解释消息来向所有用户说明。(一般的shutdown指令可以用按“+”号来进行中断)</span><br></pre></td></tr></table></figure>
<p>关机指令，在 11:50 关机</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown -h 11:50</span><br></pre></td></tr></table></figure>
<p>重启指令，在 11:50 关机</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown -r 11:50</span><br></pre></td></tr></table></figure>
<p>取消 shutdown 指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown -c</span><br></pre></td></tr></table></figure>
<p>更多指令请使用 <code>man shutdown</code> 查看</p>
<h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>作用: 关机指令</p>
<p>补充说明: 作为兼容传统的命令存在</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">halt [OPTINS...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--help 显示简短的帮助信息并退出。</span><br><span class="line">--halt 停机(关闭系统但是不切断电源)</span><br><span class="line">-p, --poweroff 关机(关闭系统并且切断电源)</span><br><span class="line">--reboot 重新启动</span><br><span class="line">-f, --force 强制立即停机/关机/重新启动， 而不与 init 进程通信。</span><br><span class="line">-w, --wtmp-only 仅向 wtmp 中写入一条关机记录， 而不实际执行关机动作。</span><br><span class="line">-d, --no-wtmp 不向 wtmp 中写入任何关机记录</span><br><span class="line">-n, --no-sync 在关机前不刷写磁盘缓存</span><br><span class="line">--no-wall 在关机前不发送警告信息</span><br></pre></td></tr></table></figure>
<h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>作用: 重启指令</p>
<p>补充说明: 作为兼容传统的命令存在</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reboot [OPTINS...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--help 显示简短的帮助信息并退出。</span><br><span class="line">--halt 停机(关闭系统但是不切断电源)</span><br><span class="line">-p, --poweroff 关机(关闭系统并且切断电源)</span><br><span class="line">--reboot 重新启动</span><br><span class="line">-f, --force 强制立即停机/关机/重新启动， 而不与 init 进程通信。</span><br><span class="line">-w, --wtmp-only 仅向 wtmp 中写入一条关机记录， 而不实际执行关机动作。</span><br><span class="line">-d, --no-wtmp 不向 wtmp 中写入任何关机记录</span><br><span class="line">-n, --no-sync 在关机前不刷写磁盘缓存</span><br><span class="line">--no-wall 在关机前不发送警告信息</span><br></pre></td></tr></table></figure>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>作用: 挂在文件系统</p>
<p>补充说明: </p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount [-l|-h|-V]</span><br><span class="line">mount -a [-fFnrsvw] [-t fstype] [-O optlist]</span><br><span class="line">mount [-fnrsvw] [-o options] device|dir</span><br><span class="line">mount [-fnrsvw] [-t fstype] [-o options] device dir</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-V：显示程序版本</span><br><span class="line">-h：显示辅助讯息</span><br><span class="line">-v：显示较讯息，通常和 -f 用来除错。</span><br><span class="line">-a：将 /etc/fstab 中定义的所有档案系统挂上。</span><br><span class="line">-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。</span><br><span class="line">-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。</span><br><span class="line">-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。</span><br><span class="line">-s-r：等于 -o ro</span><br><span class="line">-w：等于 -o rw</span><br><span class="line">-L：将含有特定标签的硬盘分割挂上。</span><br><span class="line">-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。</span><br><span class="line">-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。</span><br><span class="line">-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。</span><br><span class="line">-o sync：在同步模式下执行。</span><br><span class="line">-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。</span><br><span class="line">-o auto、-o noauto：打开/关闭自动挂上模式。</span><br><span class="line">-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.</span><br><span class="line">-o dev、-o nodev-o exec、-o noexec允许执行档被执行。</span><br><span class="line">-o suid、-o nosuid：</span><br><span class="line">允许执行档在 root 权限下执行。</span><br><span class="line">-o user、-o nouser：使用者可以执行 mount/umount 的动作。</span><br><span class="line">-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。</span><br><span class="line">-o ro：用唯读模式挂上。</span><br><span class="line">-o rw：用可读写模式挂上。</span><br><span class="line">-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</span><br></pre></td></tr></table></figure>
<p>常用命令:</p>
<p>挂载一个文件系统</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount /dev/sdc1 /media/store</span><br></pre></td></tr></table></figure>
<h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3><p>作用: 卸载文件系统</p>
<p>补充说明: umount 命令 用于卸载已经加载的文件系统。利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">umount [-hV]</span><br><span class="line">umount -a [-nrv] [-t vfstype]</span><br><span class="line">umount [-nrv] device | dir [...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-V     打印版本信息并退出。</span><br><span class="line">-h     显示帮助信息并退出。</span><br><span class="line">-v     以冗长模式运行。</span><br><span class="line">-n     在卸载后不将相应信息写入 /etc/mtab 文件。</span><br><span class="line">-r     如果卸载失败，试图以只读方式进行重新挂载。</span><br><span class="line">-a     卸载所有在 /etc/mtab 文件中描述的文件系统。（在 umount 版本或以后的版本中，不会卸载 proc 文件系统）</span><br><span class="line">-t vfstype 只卸载指定类型的文件系统。如果要一次指定多个文件系统， 可以用逗号分隔。如在指定文件系统前加 no ，则可卸载除些文件系统以外的其它文件系统。</span><br><span class="line">-f     强制卸载（比如不可达的 NFS ）。 （此选项须在高于 2.1.116 的版本上使用）</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>通过设备名卸载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">umount /dev/sdc1</span><br></pre></td></tr></table></figure>
<p>通过挂载点卸载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">umount /media/store</span><br></pre></td></tr></table></figure>
<p>卸载并弹出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">eject /media/store</span><br></pre></td></tr></table></figure>
<h3 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h3><p>作用: 更改登录 shell</p>
<p>补充说明: chsh 命令 用来更换登录系统时使用的 shell。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chsh [选项] [登录]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-h, --help 现实帮助信息并退出。</span><br><span class="line">-R, --root CHROOT_DIR Apply changes in the CHROOT_DIR directory and use the configuration files from the CHROOT_DIR directory.</span><br><span class="line">-s, --shell SHELL 用户的新登录 shell 的名称。将此字段设置为空会让系统选择默认的登录 shell。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看系统安装了哪些 shell 可以使用 <code>cat /etc/shells</code> 命令查看</p>
</blockquote>
<h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>作用: 用来探测给定文件的类型。</p>
<p>补充说明: file 命令 用来探测给定文件的类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file [ -bcnsvzL ] [ -f 命名文件 ] [ -m 幻数文件 ] file ...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   -b      不输出文件名 (简要模式).</span><br><span class="line">   -c      检查时打印输出幻数文件的解析结果.常与 -m 一起使用，用来在安装幻数文件之前调试它.</span><br><span class="line">   -f 命名文件 从在参数表前的 命名文件 中读出将要检查的文件名(每行一个文件).要有 命名文件 ，或者至少有一个文件名参数; 如果要检查标准输入, 使用``-&apos;&apos;作为文件参数.</span><br><span class="line">-m list 指定包含幻数的文件列表.可以是单个文件，也可以是 用冒号分开的多个文件.</span><br><span class="line">-n      每检查完一个文件就强制刷新标准输出. 仅在检查一组文件时才有效.  一般在将文件类型输出到管道时才采用此选项.</span><br><span class="line">-v      打印程序版本并退出.</span><br><span class="line">-z      试图查看压缩文件内部信息.</span><br><span class="line">-L      (在支持符号链接的系统上)选项显示符号链接文件的原文件, 就像 ls(1) 命令的like-named 选项.</span><br><span class="line">-s      通常, file 只是试图去检查在文件列表中那些 stat(2) 报告为正常文件的文件的类型.由于读特殊文件将可能导致 不可知后果，所以这样可以防止发生问题.使用 -s 选项时 file 命令也将去读文件列表中的块特殊文件和字符特殊文件.  一般用于从原始磁盘分区中获得文件系统类型，此文件为块 特殊文件. 这个选项也导致 file 命令忽略 stat(2) 报告的文件大小，因为在有些系统中原始磁盘分区的大小报告为0.</span><br></pre></td></tr></table></figure>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>作用: 创建目录</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir [选项]... 目录列表...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-m, --mode=模式 设置文件模式(类似chmod)，而不是 rwx 减 umask</span><br><span class="line">-p, --parents 如果目录已存在，不报错，且按需创建父目录</span><br><span class="line">-v, --verbose 为每一个已创建的目录打印信息</span><br><span class="line">-Z     将每个创建的目录的 SELinux 安全上下文设置为默认类型</span><br><span class="line">--context[=CTX] 类似 -Z，或者如果指定了上下文，则将 SELinux 或者 SMACK 安全上下文设置为指定类型</span><br><span class="line">--help 显示此帮助信息并退出</span><br><span class="line">--version 显示版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>创建目录指定权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -m 777 /opt/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>如果创建目录的上级目录不存在，先创建上级目录在创建指定目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">test</span>/opt/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>作用: 文件搜索工具</p>
<p>补充说明: grep （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep [options] PATTERN [FILE...]</span><br><span class="line">grep [options] [-e PATTERN | -f FILE] [FILE...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">太多了，使用 man grep 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>一般 grep 配置 Linux 管道进行搜索</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test.txt | grep pattern</span><br></pre></td></tr></table></figure>
<p>不输出匹配行，改为输出匹配的行数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test.txt | grep -c pattern</span><br></pre></td></tr></table></figure>
<h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>作用: 转换和拷贝文件</p>
<p>补充说明: dd 命令 用于复制文件并对原文件的内容进行转换和格式化处理。dd 命令功能很强大的，对于一些比较底层的问题，使用 dd 命令往往可以得到出人意料的效果。用的比较多的还是用 dd 来备份裸设备。但是不推荐，如果需要备份 oracle 裸设备，可以使用 rman 备份，或使用第三方软件备份，使用 dd 的话，管理起来不太方便。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dd [--<span class="built_in">help</span>] [--version] [<span class="keyword">if</span>=file] [of=file] [ibs=bytes] [obs=bytes] [bs=bytes] [cbs=bytes] [skip=blocks] [seek=blocks] [count=blocks] [conv=&#123;ascii, ebcdic, ibm, block, unblock, lcase, ucase, swab, noerror, notrunc, sync&#125;]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if=file 从 file 中读而不是标准输入。</span><br><span class="line">of=file 写到 file 里去而不是标准输出。除非指定 conv=notrunc ，否则， dd 将把 file 截为O字节（或由 seek= 选项指定的大小）</span><br><span class="line">ibs=bytes 一次读 bytes 字节。默认是512。</span><br><span class="line">obs=bytes 一次写 bytes 字节。默认是512。</span><br><span class="line">bs=bytes 一次读和写 bytes 字节。这将覆盖 ibs 和 obs 设定的值（并且，设定 bs 不等于同时将 ibs 和 obs 设为同一个值，至少在 只使用 sync, noerror 或 notrunc 转换时是这样的。因为bs规定，每个输入块都应作为单独 的数据块拷贝到输出，而不把较短的块组合到一起）。</span><br><span class="line">cbs=bytes 为 block 转换和 unblock 转换指定转换块的大小。</span><br><span class="line">skip=blocks 在拷贝之前，跳过输入文件的前 blocks 块，每块大小为 ibs-byte 字节。</span><br><span class="line">seek=blocks 在拷贝之前，跳过输出文件的前 blocks 块，每块大小为 obs-byte 字节。</span><br><span class="line">count=blocks 只拷贝输入文件的前 blocks 块（每块的大小为 ibs-byte 字节），而不是全部内容，直到文件末尾。</span><br><span class="line">conv=转换&quot;[,&quot;转换&quot;]...&quot; 将文件按 转换 参数指定的方式转换（在“,”两边没有空格）。</span><br><span class="line">      转换方式包括： </span><br><span class="line">      ascii  将 EBCDIC 转换成 ascii。</span><br><span class="line">      ebcdic 将 ascii 转换成 ebcdic。</span><br><span class="line">      ibm    将 ascii 转换成 alternative ebcdic。</span><br><span class="line">      block  每一行输入，无论长短，输出都是 cbs 字节，并且其中的“换行”（NEWLINE，即c中的&apos;0）用 空格替换。如有必要，行尾会填充空格。</span><br><span class="line">      unblock 用“换行”替换每个输入块（ cbs 字节大小）末尾的空格。</span><br><span class="line">      lcase  将大写字母转换成小写。</span><br><span class="line">      ucase  将小写字母转换成大写。</span><br><span class="line">      swab   交换每对输入字节。如果读入的字节数是奇数，最后 一个字节只是简单的复制到输出（因为没有能跟它交换的 字节了）（POSIX 1003.26，PASC翻译1003.2 3号和4号）。</span><br><span class="line">      noerror 发生读错误时，继续进行。</span><br><span class="line">      notrunc 不截断输出文件。</span><br><span class="line">      sync   用0填充到每个输入块的末尾，使其大小为 ibs 字节。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>制作 Linux 镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/home/ubuntu.iso of=/mnt/usb_device</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>作用: 查找文件</p>
<p>补充说明: 用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find [path...] [expression]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">太多了，使用 man find 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出当前目录及子目录下的所有文件和文件夹</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find .</span><br></pre></td></tr></table></figure>
<p>在 home 目录下查找以 .txt 结尾的文件名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find /home -name <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure>
<p>在 home 目录下查找以 .txt 结尾的文件名，但忽略大小写</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find /home -iname <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure>
<p>在当前目录查找所有以 .txt 和 .pdf 结尾的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span></span><br></pre></td></tr></table></figure>
<p>更多参考命令点击<a href="http://wangchujiang.com/linux-command/c/find.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>作用: 移动文件</p>
<p>补充说明: mv 命令 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source 表示源文件或目录，target 表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mv [选项]... 源文件 目标文件</span><br><span class="line">mv [选项]... 源文件... 目录</span><br><span class="line">mv [选项]... --target-directory=DIRECTORY SOURCE...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--backup[=CONTROL] 为现有的每一个目标文件作一个备份</span><br><span class="line">-b     和--backup一样但是不接受参数</span><br><span class="line">-f, --force 覆盖前永不提示</span><br><span class="line">-i, --interactive 覆盖前提示</span><br><span class="line">--strip-trailing-slashes 删除任何“源文件”参数后面跟随的斜杠</span><br><span class="line">-S, --suffix=SUFFIX 省略一般的备份后缀</span><br><span class="line">--target-directory=DIRECTORY 移动全部“源文件”参数到“目录”中</span><br><span class="line">-u, --update 只移动更老的或者标记新的非目录</span><br><span class="line">-v, --verbose 说明完成了什么</span><br><span class="line">--help 显示帮助且退出程序 </span><br><span class="line">--version 输出版本信息且退出程序</span><br><span class="line">这是备份后缀 `~&apos;, 除非设定 --suffix 或 SIMPLE_BACKUP_SUFFIX。 这个版本管理方法可以选择通过 --backup 选项或通过</span><br><span class="line">VERSION_CONTROL 环境变量。这些值是：</span><br><span class="line">    none, off 永不做备份 (即使用 --backup)</span><br><span class="line">    numbered, t 做备份编号</span><br><span class="line">    existing, nil 编号，如果编号备份存在，用其它的简单方法</span><br><span class="line">    simple, never 总是做简单备份</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mv 可以用作备份，但是总会有更好的选择</p>
</blockquote>
<p>常用命令</p>
<p>覆盖文件提示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mv -i test.txt /home/office</span><br></pre></td></tr></table></figure>
<p>无条件覆盖已经存在的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mv -f test.txt /home/office</span><br></pre></td></tr></table></figure>
<p>重命名文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mv test.txt test.md</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mv 不仅可以操作文件，也可以操作目录，上述操作对目录同样起作用</p>
</blockquote>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>作用: 列出目录内容</p>
<p>补充说明: ls 命令 用来显示目标列表，在 Linux 中是使用率较高的命令。ls 命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls [选项] [文件名...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">太多了，使用 `man ls` 命令查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>查看当前目录的非隐藏文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>查看当前目录的所有文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>
<p>单列查看但前目录的所有文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -1a</span><br></pre></td></tr></table></figure>
<p>查看指定目录的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls /opt</span><br></pre></td></tr></table></figure>
<p>递归输出指定目录下面的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -R /opt</span><br></pre></td></tr></table></figure>
<p>显示文件夹信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -ld /etc/</span><br></pre></td></tr></table></figure>
<p>更多参考命令点击<a href="http://wangchujiang.com/linux-command/c/ls.html" target="_blank" rel="noopener">这里</a>查看</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>作用: 比较两个文件的不同</p>
<p>补充说明: diff 命令 在最简单的情况下，比较给定的两个文件的不同。如果使用“-”代替“文件”参数，则要比较的内容将来自标准输入。diff 命令是以逐行的方式，比较文本文件的异同处。如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">diff [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">太多了，使用 `man diff` 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>比较两个文件的不同</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">diff test1.txt test2.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 diff 显示的结果有不明白的，可以参考<a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">这篇文章</a></p>
</blockquote>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>作用: 连接文件并在标准输出上输出</p>
<p>补充说明: cat 命令 连接文件并打印到标准输出设备上，cat 经常用来显示文件的内容。对于大型文件应该使用 <code>more</code> 或者 <code>less</code> 命令分屏显示</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat [选项]... [文件]...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A, --show-all 等价于 -vET</span><br><span class="line">-b, --number-nonblank 给非空输出行编号，使 -n 失效。</span><br><span class="line">-e     等价于 -vE </span><br><span class="line">-E, --show-ends 在每行结束显示 $</span><br><span class="line">-n, --number 给所有输出行编号</span><br><span class="line">-s, --squeeze-blank 将所有的连续的多个空行替换为一个空行</span><br><span class="line">-t     等价于 -vT</span><br><span class="line">-T, --show-tabs 把 TAB 字符显示为 ^I</span><br><span class="line">-u     （被忽略的选项）</span><br><span class="line">-v, --show-nonprinting 除了 LFD 和 TAB 之外的不可打印字符，用 ^ 和 M- 标记方式显示</span><br><span class="line">--help 显示此帮助信息并退出</span><br><span class="line">--version 显示版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用指令</p>
<p>输出一个文件到终端</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test1.txt</span><br></pre></td></tr></table></figure>
<p>将两个文件输出到终端</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test1.txt test2.txt</span><br></pre></td></tr></table></figure>
<p>输出文件内容到文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat test1 &gt; newfile</span><br></pre></td></tr></table></figure>
<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>作用: 为文件创建连接</p>
<p>补充说明: ln 命令 用来为文件创件连接，连接类型分为硬连接和软链接两种，默认的连接类型是硬连接。如果要创建软链接必须使用 “-s” 选项。</p>
<blockquote>
<p>关于硬链接和软链接的区别可以看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">这篇文章</a>。<br>简单的说，硬链接就是有多个指针指向同一个文件区域，删除任何一个指针并不会实际删除文件区域，因此不会影响其他指针的使用。<br>软链接则不同，软链接创建的指针指向的不是文件区域，而是指向一个指向文件区域的指针，一旦指向的指针被删除，软链接就无法生效。</p>
</blockquote>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln [options] <span class="built_in">source</span> [dest]</span><br><span class="line">ln [options] source...directory</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--backup[=CONTROL]  为每个已存在的目标文件创建备份文件</span><br><span class="line">-b        类似--backup，但不接受任何参数</span><br><span class="line">-d, -F, --directory   创建指向目录的硬链接(只适用于超级用户)</span><br><span class="line">-f, --force     强行删除任何已存在的目标文件</span><br><span class="line">-i, --interactive           覆盖既有文件之前先询问用户；</span><br><span class="line">-L, --logical               取消引用作为软链接的目标</span><br><span class="line">-n, --no-dereference        把软链接的目的目录视为一般文件；</span><br><span class="line">-P, --physical              直接将硬链接到软链接</span><br><span class="line">-r, --relative              创建相对于链接位置的软链接</span><br><span class="line">-s, --symbolic              对源文件建立软链接，而非硬连接；</span><br><span class="line">-S, --suffix=SUFFIX         用&quot;-b&quot;参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；</span><br><span class="line">-t, --target-directory=DIRECTORY  指定要在其中创建链接的DIRECTORY</span><br><span class="line">-T, --no-target-directory   将“LINK_NAME”视为常规文件</span><br><span class="line">-v, --verbose               打印每个链接文件的名称</span><br><span class="line">    --help    显示此帮助信息并退出</span><br><span class="line">    --version   显示版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>创建一个硬链接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln <span class="built_in">source</span> newfile</span><br></pre></td></tr></table></figure>
<p>创建一个软链接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ln -s <span class="built_in">source</span> newfile</span><br></pre></td></tr></table></figure>
<h2 id="系统管理相关命令"><a href="#系统管理相关命令" class="headerlink" title="系统管理相关命令"></a>系统管理相关命令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>作用: 报告文件系统磁盘空间的使用情况 </p>
<p>补充说明: df 命令 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">df [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a, --all 列出包括BLOCK为0的文件系统</span><br><span class="line">--block-size=SIZE use SIZE-byte blocks 指定块的大小</span><br><span class="line">-h,--huma-readable&quot; 用常见的格式显示出大小(例如:1K 234M 2G)</span><br><span class="line">-H,--si&quot; 同上,但是这里的1k等于1000字节而不是1024字节</span><br><span class="line">-i, --inodes 用信息索引点代替块表示使用状况</span><br><span class="line">-k, --kilobytes 指定块大小等于1024字节来显示使用状况</span><br><span class="line">-l, --local 只显示本地文件系统使用状况</span><br><span class="line">-m, --megabytes 以指定块大小等于1048576字节(1M)来显示使用状况</span><br><span class="line">--no-sync 在取得使用信息前禁止调用同步 (default)</span><br><span class="line">-P, --portability 使用POSIX格式输出</span><br><span class="line">--sync 在取得使用信息前调用同步 </span><br><span class="line">-t, --type=TYPE 只显示指定类型(TYPE)的文件系统</span><br><span class="line">-T, --print-type 输出每个文件系统的类型</span><br><span class="line">-x, --exclude-type=TYPE 只显示指定类型(TYPE)之外的文件系统.</span><br><span class="line">-v (忽略) </span><br><span class="line">--     输出该命令的帮助信息并退出</span><br><span class="line">--version 输出版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>友好的方式显示整个文件系统的磁盘使用情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p>查看指定文件系统的使用情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">df -h /</span><br></pre></td></tr></table></figure>
<blockquote>
<p>df 只能查看挂载点上使用情况</p>
</blockquote>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>作用: 显示 Linux 进程</p>
<p>补充说明: top 命令 可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过 top 命令所提供的互动式界面，用热键可以管理。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">top -hv|-bcHiOSs -d secs -n max -u|U user -p pid -o fld -w [cols]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b：以批处理模式操作；</span><br><span class="line">-c：显示完整的治命令；</span><br><span class="line">-d：屏幕刷新间隔时间；</span><br><span class="line">-I：忽略失效过程；</span><br><span class="line">-s：保密模式；</span><br><span class="line">-S：累积模式；</span><br><span class="line">-i&lt;时间&gt;：设置间隔时间；</span><br><span class="line">-u&lt;用户名&gt;：指定用户名；</span><br><span class="line">-p&lt;进程号&gt;：指定进程；</span><br><span class="line">-n&lt;次数&gt;：循环显示的次数。</span><br></pre></td></tr></table></figure>
<p>top 交互命令</p>
<p>在 top 命令执行过程中可以使用一些交互命令。这些命令都是单字母的，如果在命令行中使用 -s 选项，其中一些命令可能会被屏蔽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h：显示帮助画面，给出一些简短的命令总结说明；</span><br><span class="line">k：终止一个进程；</span><br><span class="line">i：忽略闲置和僵死进程，这是一个开关式命令；</span><br><span class="line">q：退出程序；</span><br><span class="line">r：重新安排一个进程的优先级别；</span><br><span class="line">S：切换到累计模式；</span><br><span class="line">s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；</span><br><span class="line">f或者F：从当前显示中添加或者删除项目；</span><br><span class="line">o或者O：改变显示项目的顺序；</span><br><span class="line">l：切换显示平均负载和启动时间信息；</span><br><span class="line">m：切换显示内存信息；</span><br><span class="line">t：切换显示进程和CPU状态信息；</span><br><span class="line">c：切换显示命令名称和完整命令行；</span><br><span class="line">M：根据驻留内存大小进行排序；</span><br><span class="line">P：根据CPU使用百分比大小进行排序；</span><br><span class="line">T：根据时间/累计时间进行排序；</span><br><span class="line">w：将当前设置写入~/.toprc文件中。</span><br></pre></td></tr></table></figure>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>作用: 显示系统中已用和未用的内存空间总和</p>
<p>补充说明: free 命令 可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">free [-b | -k | -m] [-o] [-s delay ] [-t] [-V]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b 选项 以字节为单位 显示 内存总和; -k 选项 (缺省的) 以 KB 为单位 显示; -m 选项 以 MB 为单位.</span><br><span class="line">-t 选项 显示 一个 总计行.</span><br><span class="line">-o 选项 禁止 &quot;buffer adjusted&quot; 行的显示. 除非 指定 free 从 (相应的) 已用/未用的 内存 减去/加上 缓冲区内存.</span><br><span class="line">-s 使 free 以 delay 秒为间隔, 连续抽样显示. delay 可以设置成浮点数, 它用 usleep(3) 做 微秒级 延迟.</span><br><span class="line">-V 显示版本信息.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>以友好的方式显示内存使用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>
<h3 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h3><p>作用: 显示磁盘的使用和限额</p>
<p>补充说明: quota 命令 用于显示用户或者工作组的磁盘配额信息。输出信息包括磁盘使用和配额限制。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quota [ -guv | q ]</span><br><span class="line">quota [ -uv | q ] user</span><br><span class="line">quota [ -gv | q ] group</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-g     显示 用户所在组 的 组限额. 可选项(optional).</span><br><span class="line">-u     和 缺省情况 一样.</span><br><span class="line">-v     显示 文件系统上 的 限额, 即使 没有 占用 空间.</span><br><span class="line">-q     简洁的 信息, 只 显示 超出 限额 的 文件系统.</span><br></pre></td></tr></table></figure>
<h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>作用: 在指定时间执行一个任务</p>
<p>补充说明: at 命令 用于在指定时间执行命令。at 允许使用一套相当复杂的指定时间的方法。它能够接受在当天的 hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用 midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用 12 小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为 month day（月 日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。</p>
<p>上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units，now 就是当前时间，time-units 是时间单位，这里能够是 minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count 是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用 today（今天）、tomorrow（明天）来指定完成命令的时间。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">at [-V] [-q 队列] [-f 文件] [-mldbv] 时间 at -c 作业 [作业...]  atq [-V] [-q 队列] [-v]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-V      在标准错误上输出版本号。</span><br><span class="line">-q queue 使用指定的队列。一个队列用一个字母标定，有效的的队列标定的  范围是从a到z和从A到Z。at 的缺省队列是 a,batch 的缺省队列是 b。队列的字母顺序越高，则队列运行时越谦让(运行级别越低)。 指定的队列 &quot;=&quot; 保留给当前运行的作业所在的队列。</span><br><span class="line">如果一个作业被提交到一个以大写字母标定的队列，则与提交到 batch 同样对待。如果给 atq 指定一个队列，则只显示在此指定 队列中的作业。</span><br><span class="line">-m      当作业完成时即使没有输出也给用户发邮件。</span><br><span class="line">-f file 从文件而不是标准输入中读取作业信息。</span><br><span class="line">-l      是 atq 的别名。</span><br><span class="line">-d      是 atrm 的别名。</span><br><span class="line">-v      对于 atq， 显示完整的在队列中未被删除的作业，对于其他 命令，显示作业将要执行的时间。</span><br><span class="line">显示的时间的格式类似于&quot;1997-02-20 14:50&quot;，但如果设置了 POSIXLY_CORRECT 环境变量之后，格式类似于&quot;Thu Feb 20 14:50:00 1996&quot;。</span><br><span class="line">-c      连接命令行中列出的作业并输出到标准输出。</span><br></pre></td></tr></table></figure>
<h3 id="lp"><a href="#lp" class="headerlink" title="lp"></a>lp</h3><p>作用: 打印文件或修改排队的打印任务</p>
<p>补充说明: lp 命令 用于打印文件，或者修改排队的打印任务。与 lpr 命令类似，lp 命令既支持文件输入也支持标准输入。它与 lpr 的不同之处在于它有一个不同（稍微复杂点）的参数选项设置。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lp [ -E ] [ -U username ] [ -c ] [ -d destination[/instance] ] [ -h hostname[:port] ] [ -m ] [ -n num-copies ] [ -o option[=value] ] [ -q priority ] [ -s ] [ -t title ] [ -H handling ] [ -P page-list ] [ -- ] [ file(s) ]</span><br><span class="line">lp [ -E ] [ -U username ] [ -c ] [ -h hostname[:port] ] [ -i job-id ] [ -n num-copies ] [ -o option[=value] ] [ -q priority ] [ -t title ] [ -H handling ] [ -P page-list ]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-E：与打印服务器连接时强制使用加密；</span><br><span class="line">-U：指定连接打印服务器时使用的用户名；</span><br><span class="line">-d：指定接收打印任务的目标打印机；</span><br><span class="line">-i：指定一个存在的打印任务号；</span><br><span class="line">-m：打印完成时发送E-mail；</span><br><span class="line">-n：指定打印的份数；</span><br><span class="line">-t：指定打印任务的名称；</span><br><span class="line">-H：指定打印任务开始的时间；</span><br><span class="line">-P：指定需要打印的页码。</span><br></pre></td></tr></table></figure>
<h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p>作用: 添加一个新成员到系统中</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adduser [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID]</span><br><span class="line">[--firstuid ID] [--lastuid ID] [--gecos GECOS] [--ingroup GROUP | --gid ID]</span><br><span class="line">[--disabled-password] [--disabled-login] [--add_extra_groups] USER</span><br><span class="line">   Add a normal user</span><br><span class="line"></span><br><span class="line">adduser --system [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID]</span><br><span class="line">[--gecos GECOS] [--group | --ingroup GROUP | --gid ID] [--disabled-password]</span><br><span class="line">[--disabled-login] [--add_extra_groups] USER</span><br><span class="line">   Add a system user</span><br><span class="line"></span><br><span class="line">adduser --group [--gid ID] GROUP</span><br><span class="line">addgroup [--gid ID] GROUP</span><br><span class="line">   Add a user group</span><br><span class="line"></span><br><span class="line">addgroup --system [--gid ID] GROUP</span><br><span class="line">   Add a system group</span><br><span class="line"></span><br><span class="line">adduser USER GROUP</span><br><span class="line">   Add an existing user to an existing group</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--quiet | -q      don&apos;t give process information to stdout</span><br><span class="line">--force-badname   allow usernames which do not match the</span><br><span class="line">                NAME_REGEX configuration variable</span><br><span class="line">--help | -h       usage message</span><br><span class="line">--version | -v    version number and copyright</span><br><span class="line">--conf | -c FILE  use FILE as configuration file</span><br></pre></td></tr></table></figure>
<h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>作用: 创建一个新组</p>
<p>补充说明: groupadd 命令 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">groupadd [选项] group</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f, --force		如果组已经存在则成功退出</span><br><span class="line">        并且如果 GID 已经存在则取消 -g</span><br><span class="line">-g, --gid GID                 为新组使用 GID</span><br><span class="line">-h, --help                    显示此帮助信息并推出</span><br><span class="line">-K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值</span><br><span class="line">-o, --non-unique              允许创建有重复 GID 的组</span><br><span class="line">-p, --password PASSWORD       为新组使用此加密过的密码</span><br><span class="line">-r, --system                  创建一个系统账户</span><br><span class="line">-R, --root CHROOT_DIR         chroot 到的目录</span><br></pre></td></tr></table></figure>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>作用: 终止进程</p>
<p>补充说明: kill 命令 用来删除执行中的程序或工作。kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15) ,可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 job 指令查看。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span>[-ssignal|-p][-a]pid...</span><br><span class="line"><span class="built_in">kill</span> -l [ signal ]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid ...</span><br><span class="line">      给  kill 指定一个该发信号的进程列表. 每个 pid 可为下面四种之一.  进程名 在这种情况下,发信号给所命名的进程.  n 这里的 n 大于 0. 将发信号给 pid 为 n 的进程.  -1 在这种情况下, 只要发信号的用户能够控制那些进行, 将发信号给所</span><br><span class="line">      有从 MAX_INT 到 2 的进程.  -n 这里的 n 大于 1, 在这种情况下, 发信号给属于进程组 n 的进程. 如果给定一个负的参数, 那么信号 必须 首先声明, 否则它会被当作信号发送出去.</span><br><span class="line">-s     指定发送的信号.  信号可以以信号名或数字的方式给定.</span><br><span class="line">-p     指定 kill 只打印命名进程的进程标识 (pid) , 而不应发送给它信号.</span><br><span class="line">-l     打印信号名的列表.这可以在 /usr/include/linux/signal.h 中找到.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出所有信号名称</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure>
<h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>作用: 提交和管理用户的需要周期性执行的任务</p>
<p>补充说明: crontab 命令 被用来提交和管理用户的需要周期性执行的任务，与 windows 下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab [ -u user ] file</span><br><span class="line">crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-e	(edit user&apos;s crontab) 打开一个窗口直接变价 crontab 文件</span><br><span class="line">-l	(list user&apos;s crontab) 列表当前用户设置的定时任务</span><br><span class="line">-r	(delete user&apos;s crontab)</span><br><span class="line">-i	(prompt before deleting user&apos;s crontab)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>crontab 传入的文件参数是指定格式 crontab 文件，关于 crontab 文件的详细信息点击<a href="http://wangchujiang.com/linux-command/c/crontab.html" target="_blank" rel="noopener">这里</a>查看</p>
</blockquote>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>作用: 存储或提取 tar 文件的程序</p>
<p>补充说明: 利用 tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar &lt;操作参数&gt; [选项]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">太多了，使用 `man tar` 命令查看详细信息</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>把一个目录打包并压缩</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zcf test.tar.gz config install.sh local_install.sh</span><br></pre></td></tr></table></figure>
<p>查看压缩包有哪些文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -ztvf test.tar.gz</span><br></pre></td></tr></table></figure>
<p>只将压缩包内的部分文件解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf test.tar.gz config</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解压的文件可以通过 tar -ztvf 查看</p>
</blockquote>
<p>排除部分文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar --exclude docker/latex -zcvf docker.tar.gz docker</span><br></pre></td></tr></table></figure>
<p>压缩并保留权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar --exclude docker/latex -zcvfp docker.tar.gz docker</span><br></pre></td></tr></table></figure>
<h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>作用: 解压有 zip 命令压缩的压缩包</p>
<p>补充说明: unzip 命令 用于解压缩由 zip 命令压缩的 “.zip” 压缩包。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip [-Z] [-cflptTuvz[abjnoqsCDKLMUVWX$/:^]] file[.zip] [file(s) ...]  [-x xfile(s) ...] [-d exdir]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换；</span><br><span class="line">-f：更新现有的文件；</span><br><span class="line">-l：显示压缩文件内所包含的文件；</span><br><span class="line">-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；</span><br><span class="line">-t：检查压缩文件是否正确；</span><br><span class="line">-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；</span><br><span class="line">-v：执行时显示详细的信息；</span><br><span class="line">-z：仅显示压缩文件的备注文字；</span><br><span class="line">-a：对文本文件进行必要的字符转换；</span><br><span class="line">-b：不要对文本文件进行字符转换；</span><br><span class="line">-C：压缩文件中的文件名称区分大小写；</span><br><span class="line">-j：不处理压缩文件中原有的目录路径；</span><br><span class="line">-L：将压缩文件中的全部文件名改为小写；</span><br><span class="line">-M：将输出结果送到more程序处理；</span><br><span class="line">-n：解压缩时不要覆盖原有的文件；</span><br><span class="line">-o：不必先询问用户，unzip执行后覆盖原有的文件；</span><br><span class="line">-P&lt;密码&gt;：使用zip的密码选项；</span><br><span class="line">-q：执行时不显示任何信息；</span><br><span class="line">-s：将文件名中的空白字符转换为底线字符；</span><br><span class="line">-V：保留VMS的文件版本信息；</span><br><span class="line">-X：解压缩时同时回存文件原来的UID/GID；</span><br><span class="line">-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；</span><br><span class="line">-x&lt;文件&gt;：指定不要处理.zip压缩文件中的哪些文件；</span><br><span class="line">-Z：unzip-Z等于执行zipinfo指令。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>解压文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip test.zip</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般压缩文件使用 tar 来压缩，如果是 zip 压缩格式，很有可能是在 Windows 下进行压缩，在 Linux 下解压时可能出现乱码</p>
</blockquote>
<h3 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h3><p>作用: 压缩或解压文件</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gunzip [ -acfhlLnNrtvV ] [-S 后缀] [ 文件名 ...  ]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a或——ascii：使用ASCII文字模式；</span><br><span class="line">-c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；</span><br><span class="line">-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</span><br><span class="line">-h或——help：在线帮助；</span><br><span class="line">-l或——list：列出压缩文件的相关信息；</span><br><span class="line">-L或——license：显示版本与版权信息；</span><br><span class="line">-n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；</span><br><span class="line">-N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；</span><br><span class="line">-q或——quiet：不显示警告信息；</span><br><span class="line">-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；</span><br><span class="line">-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；</span><br><span class="line">-t或——test：测试压缩文件是否正确无误；</span><br><span class="line">-v或——verbose：显示指令执行过程；</span><br><span class="line">-V或——version：显示版本信息；</span><br></pre></td></tr></table></figure>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>作用: 列出目前与过去登入系统的用户相关信息</p>
<p>补充说明: last 命令 用于显示用户最近登录信息。单独执行 last 命令，它会读取 /var/log/wtmp 的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">last [-R] [-num] [ -n num ] [-adiox] [ -f file ] [name...]  [tty...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-num指定 last 要显示多少行。</span><br><span class="line">&quot;-n num&quot;等同 -num.</span><br><span class="line">-R不显示主机名列。</span><br><span class="line">-a在最后一列显示主机名. 和下一个选项合用时很有用</span><br><span class="line">-d对于非本地的登录，Linux 不仅保存远程主机名而且保存IP地址（IP number）。这个选项可以将IP地址（IP number）转换为主机名。</span><br><span class="line">-i这个选项类似于显示远程主机 IP 地址（IP number）的 -d 选项，只不过它用数字和点符号显示IP数</span><br><span class="line">-o读取一个旧格式的 wtmp 文件 (用linux-libc5应用程序写入的).</span><br><span class="line">-x显示系统关机记录和运行级别改变的日志。</span><br></pre></td></tr></table></figure>
<h2 id="网络操作相关命令"><a href="#网络操作相关命令" class="headerlink" title="网络操作相关命令"></a>网络操作相关命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>作用: 配置和显示Linux系统网卡的网络参数</p>
<p>补充说明: ifconfig 命令 被用于配置和显示 Linux 内核中网络接口的网络参数。用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig [接口]</span><br><span class="line">ifconfig 接口 [aftype] options | address ...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add&lt;地址&gt;：设置网络设备IPv6的ip地址；</span><br><span class="line">del&lt;地址&gt;：删除网络设备IPv6的IP地址；</span><br><span class="line">down：关闭指定的网络设备；</span><br><span class="line">&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;：设置网络设备的类型与硬件地址；</span><br><span class="line">io_addr&lt;I/O地址&gt;：设置网络设备的I/O地址；</span><br><span class="line">irq&lt;IRQ地址&gt;：设置网络设备的IRQ；</span><br><span class="line">media&lt;网络媒介类型&gt;：设置网络设备的媒介类型；</span><br><span class="line">mem_start&lt;内存地址&gt;：设置网络设备在主内存所占用的起始地址；</span><br><span class="line">metric&lt;数目&gt;：指定在计算数据包的转送次数时，所要加上的数目；</span><br><span class="line">mtu&lt;字节&gt;：设置网络设备的MTU；</span><br><span class="line">netmask&lt;子网掩码&gt;：设置网络设备的子网掩码；</span><br><span class="line">tunnel&lt;地址&gt;：建立IPv4与IPv6之间的隧道通信地址；</span><br><span class="line">up：启动指定的网络设备；</span><br><span class="line">-broadcast&lt;地址&gt;：将要送往指定地址的数据包当成广播数据包来处理；</span><br><span class="line">-pointopoint&lt;地址&gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能；</span><br><span class="line">-promisc：关闭或启动指定网络设备的promiscuous模式；</span><br><span class="line">IP地址：指定网络设备的IP地址；</span><br><span class="line">网络设备：指定网络设备的名称。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>显示网络设备信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>启动关闭指定网卡</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p>作用: 显示或操作路由，设备，测路路由和通道</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: ip [ OPTIONS ] OBJECT &#123; COMMAND | <span class="built_in">help</span> &#125;</span><br><span class="line">       ip [ -force ] -batch filename</span><br><span class="line"><span class="built_in">where</span>  OBJECT := &#123; link | address | addrlabel | route | rule | neigh | ntable |</span><br><span class="line">                   tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm |</span><br><span class="line">                   netns | l2tp | fou | macsec | tcp_metrics | token | netconf | ila &#125;</span><br><span class="line">       OPTIONS := &#123; -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |</span><br><span class="line">                    -h[uman-readable] | -iec |</span><br><span class="line">                    -f[amily] &#123; inet | inet6 | ipx | dnet | mpls | bridge | link &#125; |</span><br><span class="line">                    -4 | -6 | -I | -D | -B | -0 |</span><br><span class="line">                    -l[oops] &#123; maximum-addr-flush-attempts &#125; | -br[ief] |</span><br><span class="line">                    -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |</span><br><span class="line">                    -rc[vbuf] [size] | -n[etns] name | -a[ll] | -c[olor]&#125;</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<p>常用命令</p>
<p>查看 ip 地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ip address</span><br></pre></td></tr></table></figure>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>作用: 向网络主机发送 ICMP 回显请求（ECHO_REQUEST）分组</p>
<p>补充说明: ping 命令 用来测试主机之间网络的连通性。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ping  [-aAbBdDfhLnOqrRUvV46]  [-c count] [-F flowlabel] [-i interval] [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-w deadline] [-W timeout] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp option] [hop ...] destination</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-4     仅使用 IPv4。</span><br><span class="line">-6     仅使用 IPv6。</span><br><span class="line">-a     Audible ping.</span><br><span class="line">-A     自适应 ping。</span><br><span class="line">-b     允许对一个广播地址进行 ping。</span><br><span class="line">-t ttl 仅进行ping。 设置 IP 的 TTL（Time to Live）。</span><br><span class="line">-T timestamp option 设置特殊的 IP 时间戳选项。 timestamp option 可以是 tsonly（仅时间戳）、 tsandaddr（时间戳和地址）或者 tsprespec host1 [host2 [host3 [host4]]]（预先指定跳数的时间戳）。</span><br><span class="line">-U     打印完整的用户到用户的延迟（旧行为）。通常情况下 ping 打印网络往返延时，它们可能不同，例如在 DNS 解析出现失败时。</span><br><span class="line">-v     输出详细信息。</span><br><span class="line">-V     显示版本并退出。</span><br><span class="line">-c     count 在发送(和接收)了正好数量为 count 的回显应答分组后停止操作。在发送了 count 个分组后没有收到任何分组的特别情况是发送导致了终止(选程主机或网关不可达)。</span><br><span class="line">-d     在所用的套接字上使用 SO_DEBUG 选项。 实际上，这个套接字选项没有被 Linux 内核所使用。</span><br><span class="line">-D     在每行之前打印时间戳（UNIX 时间 + gettimeofday 中的毫秒）。</span><br><span class="line">-f     以高速（洪水）方式进行  ping。  以分组返回的速度来输出其它分组或每秒输出百次。当收到每个回显应答并打印一个退格符时，对每个回显请求都打印一个句点``.&apos;&apos;。这可以快速显示出丢弃了多少个分组，只有超级用户可以用这个选项。这（操作）对网络要求非常苛刻，应该慎重使用。</span><br><span class="line">-i     wait 在发送每个分组时等待 wait 个秒数。缺省值为每个分组等待一秒。此选项与-f选项不能同时使用。</span><br><span class="line">-l     preload 如果指定 preload ，那么 ping 程序在开始正常运行模式前尽可能快地发送分组。同样只有超级用户可以用这个选项。</span><br><span class="line">-n     只以数字形式输出信息。这样就不尝试去查找主机名了。</span><br><span class="line">-p     pattern 可以指定最多16个填充字节用于保持分组长度为16的整数倍。在网络上诊断与数据相关问题时此选项很有用。例如``-p ff&apos;&apos;将使发出的分组都用全1填充数据区。</span><br><span class="line">-q     静态输出。在程序启动和结束时只显示摘要行。</span><br><span class="line">-R     记录路由。在回显请求分组中包含记录路由选项并在相应的分组返回时显示路由缓冲区。注意IP首部的容量只能存放9条这样的路由。很多主机 忽略或禁用此选项。</span><br><span class="line">-r     在所连接的网络上旁路正常的选路表，直接向主机发送分组。如果主机未处于直接相连的网络上，那么返回一个错误。此选项可用来通过无路由接口对一台主机进行检测(例如当接口已被 routed 程序丢弃后)。</span><br><span class="line">-s     packetsize 指定要发送数据的字节量。缺省值为 56 ，这正好在添加了 8 字节的 ICMP 首部后组装成 64 字节的 ICMP 数据报。</span><br><span class="line"> -w     waitsecs 在 waitsecs 秒后停止 ping 程序的执行。当试图检测不可达主机时此选项很有用。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>测试网络状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ping www.biying.com</span><br></pre></td></tr></table></figure>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>作用: 显示网络连接，路由表，接口状态，伪装连接，网络链路信息和组播成员组。</p>
<p>补充说明: netstat 命令 用来打印 Linux 中网络系统的状态信息，可让你得知整个 Linux 系统的网络情况。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat  [address_family_options]  [--tcp|-t]  [--udp|-u]  [--raw|-w]  [--listening|-l]  [--all|-a]  [--numeric|-n]  [--numeric-hosts][--numeric-ports][--numeric-ports]  [--symbolic|-N] [--extend|-e[--extend|-e]] [--timers|-o]</span><br><span class="line">[--program|-p] [--verbose|-v] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--route|-r&#125; [address_family_options] [--extend|-e[--extend|-e]] [--verbose|-v] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--interfaces|-i&#125; [iface] [--all|-a] [--extend|-e[--extend|-e]] [--verbose|-v] [--program|-p] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--groups|-g&#125; [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--masquerade|-M&#125; [--extend|-e] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--statistics|-s&#125; [--tcp|-t] [--udp|-u] [--raw|-w] [delay]</span><br><span class="line">netstat &#123;--version|-V&#125;</span><br><span class="line">netstat &#123;--<span class="built_in">help</span>|-h&#125;</span><br><span class="line">address_family_options:</span><br><span class="line">[--protocol=&#123;inet,unix,ipx,ax25,netrom,ddp&#125;[,...]]  [--unix|-x] [--inet|--ip] [--ax25] [--ipx] [--netrom] [--ddp]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--verbose , -v 详细模式运行。特别是打印一些关于未配置地址族的有用信息。</span><br><span class="line">--numeric , -n 显示数字形式地址而不是去解析主机、端口或用户名。</span><br><span class="line">--numeric-hosts 显示数字形式的主机但是不影响端口或用户名的解析。</span><br><span class="line">--numeric-ports 显示数字端口号，但是不影响主机或用户名的解析。</span><br><span class="line">--numeric-users 显示数字的用户ID，但是不影响主机和端口名的解析。</span><br><span class="line">--protocol=family , -A 指定要显示哪些连接的地址族(也许在底层协议中可以更好地描述)。 family 以逗号分隔的地址族列表，比如 inet, unix, ipx, ax25, netrom, 和 ddp。 这样和使用 --inet, --unix (-x), --ipx, --ax25, --netrom, 和 --ddp 选项效果相同。</span><br><span class="line">    地址族 inet 包括raw, udp 和tcp 协议套接字。</span><br><span class="line">-c, --continuous 将使 netstat 不断地每秒输出所选的信息。</span><br><span class="line">-e, --extend 显示附加信息。使用这个选项两次来获得所有细节。</span><br><span class="line">-o, --timers 包含与网络定时器有关的信息。</span><br><span class="line">-p, --program 显示套接字所属进程的PID和名称。</span><br><span class="line">-l, --listening 只显示正在侦听的套接字(这是默认的选项)</span><br><span class="line">-a, --all 显示所有正在或不在侦听的套接字。加上 --interfaces 选项将显示没有标记的接口。</span><br><span class="line">-F 显示FIB中的路由信息。(这是默认的选项)</span><br><span class="line">-C 显示路由缓冲中的路由信息。</span><br><span class="line">delay netstat将循环输出统计信息，每隔 delay 秒。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出所有处于监听状态的 Sockets</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -l</span><br><span class="line">netstat -lt</span><br><span class="line">netstat -lu</span><br><span class="line">netstat -lx</span><br></pre></td></tr></table></figure>
<p>列出所有端口，包括监听和未监听的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -a</span><br><span class="line">netstat -at</span><br><span class="line">netstat -au</span><br></pre></td></tr></table></figure>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>作用: 登录远程主机和管理(测试ip端口是否连通)</p>
<p>补充说明: telnet 命令 用于登录远程主机，对远程主机进行管理。telnet 因为采用明文传送报文，安全性不好，很多 Linux 服务器都不开放 telnet 服务，而改用更安全的 ssh 方式了。</p>
<p>语法</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">telnet [-468ELadr] [-S tos] [-b address] [-e escapechar] [-l user] [-n tracefile] [host [port]]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-8：允许使用8位字符资料，包括输入与输出；</span><br><span class="line">-a：尝试自动登入远端系统；</span><br><span class="line">-b&lt;主机别名&gt;：使用别名指定远端主机名称；</span><br><span class="line">-c：不读取用户专属目录里的.telnetrc文件；</span><br><span class="line">-d：启动排错模式；</span><br><span class="line">-e&lt;脱离字符&gt;：设置脱离字符；</span><br><span class="line">-E：滤除脱离字符；</span><br><span class="line">-f：此参数的效果和指定&quot;-F&quot;参数相同；</span><br><span class="line">-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；</span><br><span class="line">-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；</span><br><span class="line">-K：不自动登入远端主机；</span><br><span class="line">-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；</span><br><span class="line">-L：允许输出8位字符资料；</span><br><span class="line">-n&lt;记录文件&gt;：指定文件记录相关信息；</span><br><span class="line">-r：使用类似rlogin指令的用户界面；</span><br><span class="line">-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息；</span><br><span class="line">-x：假设主机有支持数据加密的功能，就使用它；</span><br><span class="line">-X&lt;认证形态&gt;：关闭指定的认证形态。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet &lt;ip&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p>作用: Internet 文件传输程序 (file transfer program)</p>
<p>补充说明: 用户通过 Ftp 这个程序来使用 Internet 上的标准文件传输协议 (File Transfer  Protocol).  本程序允许用户向远端网站发送文件, 或从远端网站接收文件.</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ftp [-pinegvd] [host] pftp [-inegvd] [host]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-p    使用被动模式进行数据传输. 如果你本地网络有防火墙, 外部主机不能连接到你这个客户端, 这个选项就派上用场了.  本选项要求 ftp 服务器支持 PASV 命令.  如果使用 pftp 从命令行启动 ftp, 本选项是默认打开的.</span><br><span class="line">-i    进行多个文件传输时关掉交互式的确认提示.</span><br><span class="line">-n    一般，在启动 ftp 时, ftp 会试着进行自动登录. 本选项可以关掉这个功能.  如果 auto-login 功能被启用的话,  ftp 会在用户 home 目录下的 .netrc (参阅 netrc(5)) 文件中查找远端主机上的用户帐号.  如果 .netrc 文件中用户帐号这一项不存在, ftp 会提示用户输入远端主机上的登录名 (缺省为用户在本地机器上的帐号), 如果需要, 还会提示你输入密码和用来登录的帐号. ??</span><br><span class="line">-e    如果被编译成了 ftp 可执行格式, 本选项会关掉命令编辑和历史命令功能; 否则什么也不做. ??</span><br><span class="line">-g    关掉文件名匹配功能.</span><br><span class="line">-v    显示详细信息. 本选项使得 ftp 显示远端服务器的所有响应, 并在数据传输完成后显示传输数据的统计信息.</span><br><span class="line">-d    打开 debug 模式.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ftp &lt;ip&gt;</span><br></pre></td></tr></table></figure>
<h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>作用: 显示 / 操作 IP 选路表</p>
<p>补充说明: route 程序对内核的IP选路表进行操作。它主要用于通过已用 ifconfig 程序配置好的接口来指定的主机或网络设置静态路由。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route [-CFvnee]</span><br><span class="line">route  [-v]  [-A     family] add [-net|-host] target [netmask Nm] [gw Gw] [metric N] [mss M] [window W] [irtt  I][reject] [mod] [dyn] [reinstate] [[dev] If]</span><br><span class="line">route  [-v]  [-A     family]  del [-net|-host] target [gw Gw][netmask Nm] [metric N] [[dev] If]</span><br><span class="line">route  [-V] [--version] [-h] [--<span class="built_in">help</span>]</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出当前路由</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure>
<p>添加/设置网关</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0    <span class="comment">#增加一条到达244.0.0.0的路由。</span></span><br></pre></td></tr></table></figure>
<p>屏蔽一条路由：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject     <span class="comment">#增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。</span></span><br></pre></td></tr></table></figure>
<p>删除路由记录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure>
<p>删除和添加设置默认网关：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">route del default gw 192.168.120.240</span><br><span class="line">route add default gw 192.168.120.240</span><br></pre></td></tr></table></figure>
<h3 id="rlogin"><a href="#rlogin" class="headerlink" title="rlogin"></a>rlogin</h3><p>作用: 从当前终端登录到远程Linux主机</p>
<p>补充说明: 请用 SSH</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rlogin [-8EKLdx] [-e char] [-l username] host</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-8    -8 选项 允许 进行 8 位的 输入 数据 传送; 否则在 远程主机 未使用 与 ^S/^Q 不同的 控制 字符 之前, 所有的 奇偶 校验位 都会 被清除.</span><br><span class="line">-E    -E 选项 阻塞(stops) 一些 被识别 为转意 字符 的字符.  当 使用了 -8 选项时, 这样 可以 提供 完全 透明的 连接.</span><br><span class="line">-K    -K 选项 关闭 所有的 Kerberos 安全 鉴别.</span><br><span class="line">-L    -L 选项 允许 rlogin 会话 以 ``litout&apos;&apos; 模式 运行(参见 tty(4))</span><br><span class="line">-d    -d 选项 启动 套接字 调试(参见 setsockopt(2)) , 在 TCP 类型 的连接中, 套接字 用于 提供 与远程 主机的 通讯.</span><br><span class="line">-e    -e 选项 允许 用户 指定 转意 字符, 缺省是 ``~&apos;&apos;.  可以 直接 使用 字符, 也可以 使用 八进制值 进行 指定, 八进制 格式为: \nnn.</span><br><span class="line">-k    -k 选项 要求 rlogin 在从 远程 接受 许可证时, 使用 realm 中定义的 realm, 而不是 krb_realmofhost(3) 中定义的 realm.</span><br><span class="line">-x    -x 选项 使通过 rlogin 会话 进行的 数据 传送 都要 采用 DES 加密.  这可能 会影响 响应 时间和 CPU 的利用, 但 提高了 安全性.</span><br></pre></td></tr></table></figure>
<h3 id="rcp"><a href="#rcp" class="headerlink" title="rcp"></a>rcp</h3><p>作用: 安装在两台主机之间通信</p>
<p>补充说明: rcp 似乎是 scp 的一个马甲，实际使用的 scp 命令。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rcp [-pqrvBC1246] [-F ssh_config] [-S program] [-P port] [-c cipher] [-i identity_file] [-l <span class="built_in">limit</span>] [-o ssh_option] [[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c cipher Selects the cipher to use for encrypting the data transfer.  This option is directly passed to ssh(1).</span><br><span class="line">-i identity_file Selects the file from which the identity (private key) for RSA authentication is read.  This option is directly passed to ssh(1).</span><br><span class="line">-l limit Limits the used bandwidth, specified in Kbit/s.</span><br><span class="line">-p      Preserves modification times, access times, and modes from the original file.</span><br><span class="line">-r      递归复制整个目录。</span><br><span class="line">-v      详细模式。该选项使 scp 和 ssh(1) 打印出关于运行情况的调试信息。在进行调试连接、验证和配置问题时，这会很有用的</span><br><span class="line">-B      用批模式(避免重复询问口令)。</span><br><span class="line">-q      Disables the progress meter.</span><br><span class="line">-C      允许压缩。向 ssh(1) 传递 -C 标志以允许压缩。</span><br><span class="line">-F ssh_config Specifies an alternative per-user configuration file for ssh.  This option is directly passed to ssh(1).</span><br><span class="line">-P port Specifies the port to connect to on the remote host.  Note that this option is written with a capital ‘P’, because -p is already reserved for preserving the times and modes of the file in rcp(1).</span><br><span class="line">-S program Name of program to use for the encrypted connection.  The program must understand ssh(1) options.</span><br><span class="line">-o ssh_option Can be used to pass options to ssh in the format used in ssh_config(5).  This is useful for specifying options for which there is no separate scp command-line flag.</span><br><span class="line">-1      Forces scp to use protocol 1.</span><br><span class="line">-2      Forces scp to use protocol 2.</span><br><span class="line">-4      Forces scp to use IPv4 addresses only.</span><br><span class="line">-6      Forces scp to use IPv6 addresses only.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>从本地复制到远程主机</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rcp /<span class="built_in">test</span> root@&lt;ip&gt;:/home/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<p>从远程主机复制到本地</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rcp root@&lt;ip&gt;:/home/<span class="built_in">test</span> <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<p>从远程主机复到远程主机</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rcp root@&lt;ip&gt;:/home/<span class="built_in">test</span> root@&lt;nwe-ip&gt;:/home/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><p>作用: 用户信息查找程序</p>
<p>补充说明: finger 命令 用于查找并显示用户信息。包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行 finger 指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">finger [-lmsp] [user ...] [user@host ...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-s    Finger 显示用户的登录名, 真名, 终端名 以及写 状态(如果写被禁止，在终端名后显示一个``*&apos;&apos;), 空闲时间,登录时间,办公地点和电话等。</span><br><span class="line">   登录时间显示为月,天,小时和分钟，如果是超过6个月以前，则 显示年份，而不是小时和分钟。</span><br><span class="line">   不明设备以及不存在的空闲时间和登录时间显示为一个星号。</span><br><span class="line">-l    产生一个多行显示来描述信息 -s 关于用户家目录，家庭电话，登录脚本，邮件状态和文件的内容 “.plan” 和 “.project” 和 “.forward” 从用户的家目录.</span><br><span class="line">   11位数字电话号码显示为 ``+N-NNN-NNN-NNNN&apos;&apos;.  十位或七位数字可以显示为它的子集。 五位数字电话号码显示为 ``xN-NNNN&apos;&apos;.  四位数字电话号码显示为 ``xNNNN&apos;&apos;.</span><br><span class="line">   如果对设备写被禁止, 短语 ``(messages off)&apos;&apos; 被附加在有此设备的行后边.  每一个用户有一个条目，用 -l 选项; 如果一个用户多次登录, 终端信息 按每次登录重复显示。.</span><br><span class="line">   如果什么邮件都没有，邮件信息显示为``No Mail.&apos;&apos;, 如果当新邮件来后， 已经查看过信箱，为``Mail last read DDD MMM ## HH:MM YYYY (TZ)&apos;&apos; 如果有新邮件，则为 ``New mail received ...&apos;&apos;,``  Unread since ...&apos;&apos;</span><br><span class="line">-p    防止 finger -l 选项 显示 “.plan”</span><br><span class="line">    和 “.project” 文件的内容。</span><br><span class="line">-m    防止 user 名字的匹配.  User 通常是一个登录名; 可是, 也会对用户的真实名字 进行匹配, 除非提供 -m 选项.  所有由 finger 进行的名字匹配是区分大小写的</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">finger</span><br></pre></td></tr></table></figure>
<h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><p>作用: 发送和接受邮件</p>
<p>补充说明: mail 命令 是命令行的电子邮件发送和接收工具。操作的界面不像 elm 或 pine 那么容易使用，但功能非常完整。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mail [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] to-addr... mail [-iInNv] -f [name] mail [-iInNv] [-u user]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b&lt;地址&gt;：指定密件副本的收信人地址；</span><br><span class="line">-c&lt;地址&gt;：指定副本的收信人地址；</span><br><span class="line">-f&lt;邮件文件&gt;：读取指定邮件文件中的邮件；</span><br><span class="line">-i：不显示终端发出的信息；</span><br><span class="line">-I：使用互动模式；</span><br><span class="line">-n：程序使用时，不使用mail.rc文件中的设置；</span><br><span class="line">-N：阅读邮件时，不显示邮件的标题；</span><br><span class="line">-s&lt;邮件主题&gt;：指定邮件的主题；</span><br><span class="line">-u&lt;用户帐号&gt;：读取指定用户的邮件；</span><br><span class="line">-v：执行时，显示详细的信息。</span><br></pre></td></tr></table></figure>
<h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>作用: 查询域名DNS信息的工具</p>
<p>补充说明: nslookup 命令 是常用域名查询工具，就是查 DNS 信息用的命令。</p>
<p>nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p>
<p>进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nslookup [-option] [name | -] [server]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-sil：不显示任何警告信息。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nslookup www.biying.com</span><br></pre></td></tr></table></figure>
<h2 id="系统安全相关命令"><a href="#系统安全相关命令" class="headerlink" title="系统安全相关命令"></a>系统安全相关命令</h2><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>作用: 修改用户密码</p>
<p>补充说明: 命令用来更改用户账户的密码。普通用户通常只更改其自己账户的密码，而超级用户可以更改任何账户的密码。passwd 也更改账户或相关的密码有效期。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">passwd [选项] [登录]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a, --all 此选项只能和 -S 一起使用，来显示所有用户的状态。</span><br><span class="line">-d, --delete 删除用户密码(让它为空)。这是禁用一个用户密码的快速方法。它将设置给出名称的账户。</span><br><span class="line">-e, --expire 让一个账户的密码立即过期。这可以强制一个用户下次登录时更改密码。</span><br><span class="line">-h, --help 现实帮助信息并退出。</span><br><span class="line">-i, --inactive INACTIVE 此选项用于在密码过期一定天数之后禁用账户。一个用户账户密码已经过期 INACTIVE 天之后，用户将不能再登录进账户。</span><br><span class="line">-k, --keep-tokens 表示密码更改只应该因为认证口令(密码)过期更改。用户希望保持他们尚未过期的口令。</span><br><span class="line">-l, --lock 锁定指定账户的密码。此选项通过将密码更改为一个不可能与加密值匹配的值来禁用(它在密码开头添加一个“!”)。</span><br><span class="line">   注意，这并没有禁用此账户。用户仍然可以通过其它认证方式(如 SSH 密码)来登录。要禁用此账户，管理员需要使用 usermod --expiredate 1 (设置账户的过期时间为1970年1月2日)。</span><br><span class="line">   被锁定了密码的用户不允许更改密码。</span><br><span class="line">-n, --mindays MIN_DAYS 在密码更改之间的最小天数设置为 MIN_DAYS。此字段中的 0 值表示用户可以在任何时间更改其密码。</span><br><span class="line">-q, --quiet 安静模式。</span><br><span class="line">-r, --repository REPOSITORY 在 REPOSITORY 中更改密码</span><br><span class="line">-R, --root CHROOT_DIR Apply changes in the CHROOT_DIR directory and use the configuration files from the CHROOT_DIR directory.</span><br><span class="line">-S, --status 显示账户状态信息。状态信息包含 7 个字段。首个字段是用户的登录名，第二个字段表示用户账户是否已经锁定密码(L)、没有密码 (NP)或者密码可用(P)，第三个字段给出最后一次更改密码的日期。接下来的四个字段分别是密码的最小年龄、最大年龄、警告期和禁用期。这些年龄以天为单位计算。</span><br><span class="line">-u, --unlock 解锁指定用户的密码。此操作通过将密码改回先前值(改回使用 -l 之前的值)重新启用密码。</span><br><span class="line">-w, --warndays WARN_DAYS 设置在要求更改密码之前警告的天数。WARN_DAYS 选项是在密码过期之前提前警告的天数。</span><br><span class="line">-x, --maxdays MAX_DAYS 设置密码仍然有效的最大天数。MAX_DAYS 之后，密码会要求更改。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>用户修改自己的密码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<p>管理员创建用户之后，使用 passwd 为新用户创建密码，当然也可以任意修改用户的密码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">passwd &lt;new-user-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>作用: 用于切换当前用户身份到其他用户身份</p>
<p>补充说明: su 命令 用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su [选项] [用户名]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c, --command COMMAND 通过使用其 -c 选项，指定一个由 shell 运行的命令。</span><br><span class="line">-, -l, --login 提供一个类似于用户直接登录的环境，用户可能会希望这样。</span><br><span class="line">-s, --shell SHELL 将使用的 shell。</span><br><span class="line">-m, -p, --preserve-environment 保留当前环境，除非：.PP $PATH</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>切换为 root 用户</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>
<p>切换为其他用户</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su &lt;other-user&gt;</span><br></pre></td></tr></table></figure>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>作用: 用来设置限制新建文件权限的掩码</p>
<p>补充说明: umask 命令 用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask 命令都被执行， 并自动设置掩码 mode 来限制新文件的权限。用户可以通过再次执行 umask 命令来改变默认值，新的权限将会把旧的覆盖掉。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> [-p] [-S] [模式]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-p：输出的权限掩码可直接作为指令来执行；</span><br><span class="line">-S：以符号方式输出权限掩码。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>设置掩码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> u=rwx,g=,o=</span><br></pre></td></tr></table></figure>
<p>运行上述命令之后创建的文件，默认权限为 -rw——-</p>
<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>作用: 修改文件或目录所属的群组</p>
<p>补充说明: chgrp 命令 用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的 id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户 (root) ，则不能改变该文件的组。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chgrp [选项列表]... 组 文件...</span><br><span class="line">chgrp [选项列表]... --reference=参考文件 文件...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-R 递归式地改变指定目录及其下的所有子目录和文件的所属的组</span><br><span class="line">-c或——changes：效果类似“-v”参数，但仅回报更改的部分；</span><br><span class="line">-f或--quiet或——silent：不显示错误信息；</span><br><span class="line">-h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件；</span><br><span class="line">-H如果命令行参数是一个通到目录的符号链接，则遍历符号链接</span><br><span class="line">-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；</span><br><span class="line">-L遍历每一个遇到的通到目录的符号链接</span><br><span class="line">-P不遍历任何符号链接（默认）</span><br><span class="line">-v或——verbose：显示指令执行过程；</span><br><span class="line">--reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>改变一个文件所属用户组</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chgrp canxing <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>改变一个目录以及目录下所有文件所属用户组</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chgrp -R canxing <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>作用: 修改文件所有者和组别</p>
<p>补充说明: chown 修改每个由第一个非选项参数声明的给定 file(文件) 的用户和/或组的所有权.如下: 如果只给出了用户名(或者数字用户标识),那么该用户即成为每个指定 文件的所有者,而该文件的组别并不改变.如果用户名后面紧跟着冒号和组名(或者是数字组标识),并且它们之间没有空格,那么文件的组所有权 也随之改变.</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown [options] user [:group] file...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c, --changes 详尽地描述每个 file 实际改变了哪些所有权.</span><br><span class="line">-f, --silent, --quiet 不打印文件所有权不能修改的报错信息.</span><br><span class="line">-h, --no-dereference 只作用于其本身的符号链接,而不修改它们所指向的文件.  这只在提供了 lchown 系统调用的情况下才可用.</span><br><span class="line">-v, --verbose 详尽地描述对每个 file 所执行的操作(或者无操作).</span><br><span class="line">-R, --recursive 递归地修改目录及其下面内容的所有权.</span><br><span class="line">--dereference 修改符号链接目标端的所有权,而非符号链接自身.  (fileutils 4.0中实现的新功能.)</span><br><span class="line">--reference=rfile (fileutils 4.0中实现的新功能.)  修改 file 的所有权为 rfile 的所有权.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>改变文件的所有者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown canxing <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>改变目录以及目录下所有文件的所有者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R canxing <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>作用: 变更目录或文件权限</p>
<p>补充说明: chmod 命令 用来变更文件或目录的权限。在 UNIX 系统家族里，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。用户可以使用 chmod 指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod [options] mode file...</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c, --changes 只有在文件的权限确实改变时才进行详细的说明</span><br><span class="line">-f, --silent, --quiet 不输出权限不能改变的文件的错误信息</span><br><span class="line">-v, --verbose 详细说明权限的变化</span><br><span class="line">-R, --recursive 改变目录及其所有子目录的文件的权限</span><br><span class="line">--reference=rfile (更新在fileutils 4.0上) 改变文件的模式到rfile.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>使用数字修改文件或目录权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 755 <span class="built_in">test</span> </span><br><span class="line">chmod -R 755 <span class="built_in">test</span>-dir/</span><br></pre></td></tr></table></figure>
<p>增加其他用户的执行权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod o+x <span class="built_in">test</span></span><br><span class="line">chmod -R o+x <span class="built_in">test</span>-dir/</span><br></pre></td></tr></table></figure>
<h3 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h3><p>作用: 用来改变文件属性</p>
<p>补充说明: chattr 命令 用来改变文件属性。这项指令可改变存放在 ext2 文件系统上的文件或目录属性，这些属性共有以下 8 种模式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a：让文件或目录仅供附加用途；</span><br><span class="line">b：不更新文件或目录的最后存取时间；</span><br><span class="line">c：将文件或目录压缩后存放；</span><br><span class="line">d：将文件或目录排除在倾倒操作之外；</span><br><span class="line">i：不得任意更动文件或目录；</span><br><span class="line">s：保密性删除文件或目录；</span><br><span class="line">S：即时更新文件或目录；</span><br><span class="line">u：预防意外删除。</span><br></pre></td></tr></table></figure></p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chattr [ -RVf ] [ -v 版本 ] [ -p project ] [ mode ] files...</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-R     递归地修改目录以及其下内容的属性.  如果在递归目录时遇到了符号链接,遍历将跳过.</span><br><span class="line">-V     详尽地给出chattr的输出信息并打印出程序的版本.</span><br><span class="line">-v version 设置文件系统的版本.</span><br></pre></td></tr></table></figure>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>作用: 以其他用户的身份来执行命令</p>
<p>补充说明: sudo 命令 用来以其他身份来执行命令，预设的身份为 root。在 /etc/sudoers 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用 sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo -h | -K | -k | -V</span><br><span class="line">sudo -v [-AknS] [-a <span class="built_in">type</span>] [-g group] [-h host] [-p prompt] [-u user]</span><br><span class="line">sudo -l [-AknS] [-a <span class="built_in">type</span>] [-g group] [-h host] [-p prompt] [-U user] [-u user] [<span class="built_in">command</span>]</span><br><span class="line">sudo [-AbEHnPS] [-a <span class="built_in">type</span>] [-C num] [-c class] [-g group] [-h host] [-p prompt] [-r role] [-t <span class="built_in">type</span>] [-u user] [VAR=value] [-i | -s] [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-b：在后台执行指令；</span><br><span class="line">-h：显示帮助；</span><br><span class="line">-H：将HOME环境变量设为新身份的HOME环境变量；</span><br><span class="line">-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。</span><br><span class="line">-l：列出目前用户可执行与无法执行的指令；</span><br><span class="line">-p：改变询问密码的提示符号；</span><br><span class="line">-s&lt;shell&gt;：执行指定的shell；</span><br><span class="line">-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；</span><br><span class="line">-v：延长密码有效期限5分钟；</span><br><span class="line">-V ：显示版本信息。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没啥用</p>
</blockquote>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>作用: 报告当前程序的状态</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">太多，使用 `man ps` 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure>
<p>上述命令会输出所有当前运行进程的详细信息，再通过管道即可获取想要的信息</p>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>作用: 显示已登录用户</p>
<p>补充说明: who 命令 是显示目前登录系统的用户信息。执行 who 命令可得知目前有那些用户登入系统，单独执行 who 命令会列出登入帐号，使用的终端机，登入时间以及从何处登入或正在使用哪个 X 显示器。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">who [选项]... [ 文件 | 参数1 参数2 ]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a, --all 等价于 -b -d --login -p -r -t -T -u</span><br><span class="line">-b, --boot 最近一次系统引导的时间</span><br><span class="line">-d, --dead 显示死进程</span><br><span class="line">-H, --heading 显示表格的表头</span><br><span class="line">--ips  显示 IP地址而不是主机名。加上 --lookup，则会尽可能基于已存储的 IP 规范化，而不是已存储的主机名</span><br><span class="line">-l, --login 显示系统登录进程</span><br><span class="line">--lookup 试图通过 DNS 规范主机名</span><br><span class="line">-m     仅显示和标准输入关联的主机名和用户</span><br><span class="line">-p, --process 显示由 init 生成的活跃进程</span><br><span class="line">-q, --count 所有登录名称与已登录用户数量</span><br><span class="line">-r, --runlevel 显示当前运行级别</span><br><span class="line">-s, --short 仅显示名称、线路与时间（默认）</span><br><span class="line">-t, --time 显示最近一次系统时钟更改</span><br><span class="line">-T, -w, --mesg 添加用户状态信息，如 +, - 或 ?</span><br><span class="line">-u, --users w列出已登陆用户</span><br><span class="line">--message 等价于 -T</span><br><span class="line">--writable 等价于 -T</span><br><span class="line">--help 显示此帮助信息并退出</span><br><span class="line">--version 显示版本信息并退出</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
