<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="残星">
<meta property="og:url" content="http://yoursite.com/archives/index.html">
<meta property="og:site_name" content="残星">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="残星">

<link rel="canonical" href="http://yoursite.com/archives/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>残星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">残星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/28/shell基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/28/shell基础/" class="post-title-link" itemprop="url">shell基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-28 17:48:47" itemprop="dateCreated datePublished" datetime="2018-11-28T17:48:47+08:00">2018-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Shell/" itemprop="url" rel="index"><span itemprop="name">Shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Shell-基础"><a href="#Shell-基础" class="headerlink" title="Shell 基础"></a>Shell 基础</h1><blockquote>
<p>Shell 脚本的第一行用于指定该脚本用什么解释器执行。通过命令 <code>cat /etb/shells</code> 可以查看当前系统安装了哪些解释器，<br>然后在脚本第一行输入 <code>#! /bin/bash</code> 指定解释器，<code>/bin/bash</code> 是通过查看 <code>/etc/shells</code> 文件得到的，不同的机器上可能有不同的脚本</p>
</blockquote>
<ul>
<li><a href="#变量">变量</a><ul>
<li><a href="#定义变量">定义变量</a></li>
<li><a href="#使用变量">使用变量</a></li>
<li><a href="#只读变量">只读变量</a></li>
<li><a href="#删除变量">删除变量</a></li>
<li><a href="#变量类型">变量类型</a></li>
<li><a href="#字符串变量">字符串变量</a><ul>
<li><a href="#获取字符串长度">获取字符串长度</a></li>
<li><a href="#提取子字符串">提取子字符串</a></li>
</ul>
</li>
<li><a href="#数组变量">数组变量</a></li>
</ul>
</li>
<li><a href="#传递参数">传递参数</a></li>
<li><a href="#运算符">运算符</a><ul>
<li><a href="#算数运算符">算数运算符</a></li>
<li><a href="#关系运算符">关系运算符</a></li>
<li><a href="#布尔运算符">布尔运算符</a></li>
<li><a href="#逻辑运算符">逻辑运算符</a></li>
<li><a href="#字符串运算符">字符串运算符</a></li>
<li><a href="#文件测试运算符">文件测试运算符</a></li>
</ul>
</li>
<li><a href="#控制流">控制流</a><ul>
<li><a href="#if-else">if-else</a></li>
<li><a href="#for">for</a></li>
<li><a href="#while">while</a></li>
<li><a href="#until">until</a></li>
</ul>
</li>
<li><a href="#函数">函数</a></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>在 Shell 中定义变量，不需要指定变量类型，也不需要修饰变量。直接使用 <code>变量名=值</code> 的形式即可对变量进行赋值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"canxinglook.cn"</span></span><br></pre></td></tr></table></figure>
<p><strong><em> 和其他编程语言不同的是，Shell 定义变量时，= 左右两边不能有空格 </em></strong></p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>要使用一个定义过的变量，只要在变量前加 <code>$</code> 即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"i am <span class="variable">$your_name</span>"</span></span><br><span class="line"><span class="built_in">echo</span> i am <span class="variable">$your_name</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br><span class="line"><span class="built_in">echo</span> i am <span class="variable">$&#123;your_name&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"i am<span class="variable">$&#123;your_name&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>变量名称外可以加花括号，加不加都行，但是在某些情况下，需要加花括号对变量边界加以限制</p>
<blockquote>
<p>为了保持统一，建议使用变量都加上花括号</p>
</blockquote>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>Shell 提供了 <code>readonly</code> 关键字将一个变量声明为只读变量，声明之后的变量值将不能在改变。</p>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>Shell 使用 <code>unset</code> 关键字删除一个变量，<code>unset</code> 关键字不能删除只读变量。删除之后的变量可以重新赋值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"canxinglook.cn"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">unset</span> your_name</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br><span class="line">your_name=<span class="string">"tom"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行 Shell 时，会存在三种变量:</p>
<ol>
<li>局部变量: 在脚本或命令中定义，仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问</li>
<li>环境变量: 所有程序，包括 Shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。</li>
<li>Shell 变量: Shell 变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行。</li>
</ol>
<h3 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h3><p>字符串是 Shell 编程中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号。虽然单引号和双引号都可以表示一个字符串，但是在使用上还存在一些不同。</p>
<p>单引号的限制:</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
<p>在字符串定义上，尽量使用双引号不要使用单引号。</p>
<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>使用 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#&lt;string&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>即可获取字符串长度，其中 <code>&lt;string&gt;</code> 为字符串。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">'abcdefg'</span></span><br><span class="line">len=<span class="variable">$&#123;#your_name&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;len&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><p>提取子字符串使用 <code>${&lt;string&gt;:&lt;startIndex&gt;:&lt;offset&gt;}</code> 从 string 的 startIndex 位置开始提取 offset 个字符返回。其中 <code>&lt;string&gt;</code> 为被提取的字符串;<code>&lt;startIndex&gt;</code> 为提取开始位置，字符串的第一个字符下标为 0; <code>&lt;offset&gt;</code> 为提取个数，包括开始位置的那个字符串。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">'abcdefg'</span></span><br><span class="line">subStr=<span class="variable">$&#123;your_name:1:2&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;subStr&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><p>Shell 中定义一个数组可以使用下面三种方式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array_name=(<span class="string">"abc"</span> <span class="string">"defg"</span> <span class="string">"1234"</span>)</span><br><span class="line"></span><br><span class="line">array_name=(</span><br><span class="line"><span class="string">"111"</span></span><br><span class="line"><span class="string">"222"</span></span><br><span class="line"><span class="string">"333"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">array_name=()</span><br><span class="line">array_name[0]=<span class="string">"aaaaa"</span></span><br><span class="line">array_name[1]=<span class="string">"bbbbbb"</span></span><br><span class="line">array_name[2]=<span class="string">"ccccc"</span></span><br><span class="line">array_name[3]=<span class="string">"ddddddd"</span></span><br></pre></td></tr></table></figure>
<p>Shell 使用一对括号 <code>()</code> 来定义一个数组，数组中的每个元素使用空格分割。数组元素下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或表达式，其值应该大于或等于 0。</p>
<p>获取数组元素使用 <code>{&lt;array-name&gt;[&lt;index&gt;]}</code>，其中 <code>&lt;array-name&gt;</code> 为一个数组变量，<code>&lt;index&gt;</code> 表示数组下标。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name=(<span class="string">"aaaaaa"</span>, <span class="string">"bbbbb"</span> <span class="string">"cccccc"</span> <span class="string">"ddddddddd"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[2]&#125;</span></span><br></pre></td></tr></table></figure>
<p>获取数组中的所有元素使用 <code>{&lt;array-name&gt;[@]}</code> 或者 <code>{&lt;array-name&gt;[*]}</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name=(<span class="string">"aaaaaa"</span>, <span class="string">"bbbbb"</span> <span class="string">"cccccc"</span> <span class="string">"ddddddddd"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[*]&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>获取数组长度使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#&lt;array-name&gt;[@]&#125;</span></span><br><span class="line"><span class="variable">$&#123;#&lt;array-name&gt;[*]&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;array-name&gt;</code> 为数组变量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array_name=(<span class="string">"aaaaaa"</span>, <span class="string">"bbbbb"</span> <span class="string">"cccccc"</span> <span class="string">"ddddddddd"</span>)</span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line">len=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;length&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;len&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>在执行 Shell 脚本时，可以向脚本传递参数，脚本内获取参数的方式为 <code>$n</code>，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，0 为执行脚本的名称。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的名称为 <span class="variable">$0</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的第一个参数为 <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的第二个参数为 <span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行脚本的第三个参数为 <span class="variable">$3</span>"</span></span><br></pre></td></tr></table></figure>
<p>执行脚本命令 <code>./test 1 2 3</code></p>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行脚本的名称为 ./test.sh</span><br><span class="line">执行脚本的第一个参数为 1</span><br><span class="line">执行脚本的第二个参数为 2</span><br><span class="line">执行脚本的第三个参数为 3</span><br></pre></td></tr></table></figure>
<p>另外 Shell 还有几个特殊字符用来处理参数</p>
<table>
<thead>
<tr>
<th>参数说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$#</code></td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程 ID</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的 ID</td>
</tr>
<tr>
<td>$@</td>
<td>与 <code>$*</code> 相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>现实 Shell 使用的当前选项，与 set 命令相同</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态，0 表示没有错误，其他任何值表示有错误。</td>
</tr>
</tbody>
</table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>Shell 不支持原生的数学运算，但是可以通过其他命令来实现，最常用的就是 <code>expr</code></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expr $a + $b</code></td>
<td>加法运算</td>
</tr>
<tr>
<td><code>expr $a - $b</code></td>
<td>减法运算</td>
</tr>
<tr>
<td><code>expr $a \* $b</code></td>
<td>乘法运算</td>
</tr>
<tr>
<td><code>expr $a / $b</code></td>
<td>除法运算</td>
</tr>
<tr>
<td><code>expr $a % %b</code></td>
<td>取余运算</td>
</tr>
</tbody>
</table>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>相等返回 true，不相等返回 false</td>
<td><code>[ $a -eq $b ]</code></td>
</tr>
<tr>
<td>-ne</td>
<td>不相等返回 true，相等返回 false</td>
<td><code>[ $a -ne $b ]</code></td>
</tr>
<tr>
<td>-gt</td>
<td>大于返回 true，不大于返回 false</td>
<td><code>[ $a -gt $b ]</code></td>
</tr>
<tr>
<td>-lt</td>
<td>小于返回 true，不小于返回 false</td>
<td><code>[ $a -lt $b ]</code></td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于返回 true，小于返回 false</td>
<td><code>[ $a -ge $b ]</code></td>
</tr>
<tr>
<td>-le</td>
<td>小于等于返回 true，大于返回 false</td>
<td><code>[ $a -le $b ]</code></td>
</tr>
</tbody>
</table>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非运算</td>
<td><code>[ !false ]</code></td>
</tr>
<tr>
<td>-o</td>
<td>或运算</td>
<td><code>[ $a -lt 200 -o $b -ge 10 ]</code></td>
</tr>
<tr>
<td>-a</td>
<td>与运算</td>
<td><code>[ $a -lt 200 -a $b -ge 10 ]</code></td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>and</td>
<td><code>[[ $a -lt 200 &amp;&amp; $b -ge 10 ]]</code></td>
</tr>
<tr>
<td>_</td>
<td></td>
<td>_</td>
<td>or</td>
<td>`[[ $a -lt 200</td>
<td></td>
<td>$b -ge 10 ]]`</td>
</tr>
</tbody>
</table>
<h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>相等返回 true，不相等返回 false</td>
<td><code>[ $a = $b ]</code></td>
</tr>
<tr>
<td>!=</td>
<td>不相等返回 true，相等返回 false</td>
<td><code>[ $a != $b ]</code></td>
</tr>
<tr>
<td>-z</td>
<td>字符串长度为 0 返回 true，不为 0 返回 false</td>
<td><code>[ -z $a ]</code></td>
</tr>
<tr>
<td>-n</td>
<td>字符串长度不为 0 返回 true，为 0 返回 false</td>
<td><code>[ -n $a ]</code></td>
</tr>
<tr>
<td>str</td>
<td>字符串不为空返回 true</td>
<td><code>[ $a ]</code></td>
</tr>
</tbody>
</table>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>如果文件是块设备文件，返回 true。</td>
<td><code>[ -b $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-c</td>
<td>如果文件是字符设备文件，返回 true。</td>
<td><code>[ -c $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-d</td>
<td>如果文件是目录，返回 true。</td>
<td><code>[ -d $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-f</td>
<td>如果文件是普通文件，返回 true。</td>
<td><code>[ -f $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-g</td>
<td>如果文件设置了SGID 位，返回 true。 `</td>
<td>[ -g $file ]` 返回 false。</td>
</tr>
<tr>
<td>-k</td>
<td>如果文件设置了粘着位，返回 true。</td>
<td><code>[ -k $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-p</td>
<td>如果文件是有名管道，返回 true。</td>
<td><code>[ -p $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-u</td>
<td>如果文件设置了 SUID 位，返回 true。</td>
<td><code>[ -u $file ]</code> 返回 false。</td>
</tr>
<tr>
<td>-r</td>
<td>如果文件可读，返回 true。</td>
<td><code>[ -r $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-w</td>
<td>如果文件可写，则返回 true。</td>
<td><code>[ -w $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-x</td>
<td>如果文件可执行，返回 true。</td>
<td><code>[ -x $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-s</td>
<td>如果文件不为空，返回 true。</td>
<td><code>[ -s $file ]</code> 返回 true。</td>
</tr>
<tr>
<td>-e</td>
<td>如果文件（包括目录）存在，返回 true。</td>
<td><code>[ -e $file ]</code> 返回 true。</td>
</tr>
</tbody>
</table>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><blockquote>
<p>和其他编程语言一样可以使用 break 和 continue 来跳出循环</p>
</blockquote>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>if 语句语法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">elif</span> condition3</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command3</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command4</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if 语句以 <code>if condition1; then</code> 开始，<code>fi</code> 结束，<code>elif</code> 和 <code>else</code> 都是可选的。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for 语句语法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;var&gt; <span class="keyword">in</span> item1 item2 item3 ... itemn</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>遍历一个数组需要使用 <code>${array[@]}</code> 获取所有数组元素</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=(<span class="string">'111'</span> <span class="string">'222'</span> <span class="string">'333'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;item&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while 语句语句如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>实例如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$i</span> -le 5 ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    i=`expr <span class="variable">$i</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>until 语句执行一些语句直到条件为 true 时停止</p>
<p>until 语法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>case 语句为多选择语句，类似其他语句中的 switch 语句。case 语句语法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;val&gt; <span class="keyword">in</span> </span><br><span class="line">    &lt;val1&gt;)</span><br><span class="line">        command1</span><br><span class="line">        ;;</span><br><span class="line">    &lt;val2&gt;)</span><br><span class="line">        command2</span><br><span class="line">        ;;</span><br><span class="line">    &lt;val3&gt;)</span><br><span class="line">        command3</span><br><span class="line">        ;;</span><br><span class="line">        ...</span><br><span class="line">        *)</span><br><span class="line">        commandn</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义函数的语法如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>] funname [()] &#123;</span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line">    [<span class="built_in">return</span> value;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中带有 <code>[]</code> 都是可选的</p>
<p>要调用函数直接使用函数名称即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span> () &#123;</span><br><span class="line">    <span class="built_in">read</span> num</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$&#123;num&#125;</span> <span class="keyword">in</span> </span><br><span class="line">        1) <span class="built_in">echo</span> <span class="string">"你选择了 1"</span></span><br><span class="line">            ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;num&#125;</span>"</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func</span><br></pre></td></tr></table></figure>
<p>如果要传递参数到函数中，只需要在函数名称后加上参数即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span> () &#123;</span><br><span class="line">    //<span class="built_in">command</span></span><br><span class="line">&#125;</span><br><span class="line">func 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p>要从函数内部获取传入的参数，需要借助几个特殊字符。</p>
<table>
<thead>
<tr>
<th>参数说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程 ID</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的 ID</td>
</tr>
<tr>
<td>$@</td>
<td>与 <code>$*</code> 相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>现实 Shell 使用的当前选项，与 set 命令相同</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态，0 表示没有错误，其他任何值表示有错误。</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/27/linux基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/27/linux基础/" class="post-title-link" itemprop="url">linux 基本命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-27 19:56:00" itemprop="dateCreated datePublished" datetime="2018-11-27T19:56:00+08:00">2018-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="linux-基本命令"><a href="#linux-基本命令" class="headerlink" title="linux 基本命令"></a>linux 基本命令</h1><p>参考资料: <a href="http://wangchujiang.com/linux-command/" target="_blank" rel="noopener">Linux 命令搜索</a>，Linux man 指令</p>
<ul>
<li><a href="#安装和登录命令">安装和登录命令</a><ul>
<li><a href="#login">login</a></li>
<li><a href="#shutdown">shutdown</a></li>
<li><a href="#halt">halt</a></li>
<li><a href="#reboot">reboot</a></li>
<li><a href="#mount">mount</a></li>
<li><a href="#umount">umount</a></li>
<li><a href="#chsh">chsh</a></li>
</ul>
</li>
<li><a href="#文件处理命令">文件处理命令</a><ul>
<li><a href="#file">file</a></li>
<li><a href="#mkdir">mkdir</a></li>
<li><a href="#grep">grep</a></li>
<li><a href="#dd">dd</a></li>
<li><a href="#find">find</a></li>
<li><a href="#mv">mv</a></li>
<li><a href="#ls">ls</a></li>
<li><a href="#diff">diff</a></li>
<li><a href="#cat">cat</a></li>
<li><a href="#ln">ln</a></li>
</ul>
</li>
<li><a href="#系统管理相关命令">系统管理相关命令</a><ul>
<li><a href="#df">df</a></li>
<li><a href="#top">top</a></li>
<li><a href="#free">free</a></li>
<li><a href="#quota">quota</a></li>
<li><a href="#at">at</a></li>
<li><a href="#lp">lp</a></li>
<li><a href="#adduser">adduser</a></li>
<li><a href="#groupadd">groupadd</a></li>
<li><a href="#kill">kill</a></li>
<li><a href="#crontab">crontab</a></li>
<li><a href="#tar">tar</a></li>
<li><a href="#unzip">unzip</a></li>
<li><a href="#gunzip">gunzip</a></li>
<li><a href="#last">last</a></li>
</ul>
</li>
<li><a href="#网络操作命令">网络操作命令</a><ul>
<li><a href="#ifconfig">ifconfig</a></li>
<li><a href="#ip">ip</a></li>
<li><a href="#ping">ping</a></li>
<li><a href="#netstat">netstat</a></li>
<li><a href="#ftp">ftp</a></li>
<li><a href="#route">route</a></li>
<li><a href="#rlogin">rlogin</a></li>
<li><a href="#rcp">rcp</a></li>
<li><a href="#finger">finger</a></li>
<li><a href="#mail">mail</a></li>
<li><a href="#nslookup">nslookup</a></li>
</ul>
</li>
<li><a href="#系统安全相关命令">系统安全相关命令</a><ul>
<li><a href="#passwd">passwd</a></li>
<li><a href="#su">su</a></li>
<li><a href="#umask">umask</a></li>
<li><a href="#chgrp">chgrp</a></li>
<li><a href="#chmod">chmod</a></li>
<li><a href="#chown">chown</a></li>
<li><a href="#chattr">chattr</a></li>
<li><a href="#sudo">sudo</a></li>
<li><a href="#ps">ps</a></li>
<li><a href="#who">who</a></li>
</ul>
</li>
</ul>
<h2 id="安装和登录命令"><a href="#安装和登录命令" class="headerlink" title="安装和登录命令"></a>安装和登录命令</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>作用: 登陆系统或切换用户身份</p>
<p>补充说明: login 命令 用于给出登录界面，可用于重新登录或者切换用户身份，也可通过它的功能随时更换登入身份。在 Slackware 发行版中 ，您可在命令后面附加欲登入的用户名称，它会直接询问密码，等待用户输入。当 /etc/nologin 文件存在时，系统只 root 帐号登入系统，其他用户一律不准登入。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login [-p] [-h 主机] [用户名] [ENV=VAR...]</span><br><span class="line">login [-p] [-h 主机] [-f 名称]</span><br><span class="line">login [-p] -r 主机</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f 不要执行认证，用户已经预认证过。</span><br><span class="line">   注意：此时，username 是强制的。</span><br><span class="line">-h 此登录的远程主机名。</span><br><span class="line">-p 保留环境。</span><br><span class="line">-r 为 rlogin (远程登录)执行 autologin (自动登录)协议。</span><br><span class="line"></span><br><span class="line">-r, -h and -f 只能用于 root 使用 login 时。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般用于当前主机切换用户，远程连接使用 SSH 即可。</p>
</blockquote>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>作用: 系统关机命令</p>
<p>补充说明: shutdown  以一种安全的方式关闭系统。所有登陆用户都可以看到关机信息提示，并且 login(1) 将被阻塞。可以指定立刻关机，也可以指定系统在一定的延时后关机。所有进程都将接收到 SIGTERM 信号。这可以使 vi(1) 等程序有时间将处于编辑状态的文件进行存储，邮件和新闻程序进程则可以将所有缓冲池内的数据进行适当的清除等等。 </p>
<p>语法: </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [-t sec] [-arkhncfF] time [warning-message]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-a     使用 /etc/shutdown.allow 来验证身份。</span><br><span class="line">-t sec 通知 init(8) 在转换到其它运行级别前，发送警告 (warning) 信号后延时 (sec) 秒数后再发送关闭 (kill) 信号。</span><br><span class="line">-k     并非真正关机，只向所有人显示警告信息。</span><br><span class="line">-r     重启。</span><br><span class="line">-h     停机。</span><br><span class="line">-n     [DEPRECATED(不应再使用)] 不调用 init(8) 程序进行关机操作，而由自己进行。不建议用户使用这种关机方式，它的结果一般也不是你希望的那样。</span><br><span class="line">-f     重启时跳过磁盘检测。</span><br><span class="line">-F     重启时强制磁盘检测。</span><br><span class="line">-c     取消运行中的 shutdown 进程。不可能为此选项指定 time 参数，但你可以在命令行输入一条解释消息来向所有用户说明。(一般的shutdown指令可以用按“+”号来进行中断)</span><br></pre></td></tr></table></figure>
<p>关机指令，在 11:50 关机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h 11:50</span><br></pre></td></tr></table></figure>
<p>重启指令，在 11:50 关机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r 11:50</span><br></pre></td></tr></table></figure>
<p>取消 shutdown 指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -c</span><br></pre></td></tr></table></figure>
<p>更多指令请使用 <code>man shutdown</code> 查看</p>
<h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>作用: 关机指令</p>
<p>补充说明: 作为兼容传统的命令存在</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">halt [OPTINS...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--help 显示简短的帮助信息并退出。</span><br><span class="line">--halt 停机(关闭系统但是不切断电源)</span><br><span class="line">-p, --poweroff 关机(关闭系统并且切断电源)</span><br><span class="line">--reboot 重新启动</span><br><span class="line">-f, --force 强制立即停机/关机/重新启动， 而不与 init 进程通信。</span><br><span class="line">-w, --wtmp-only 仅向 wtmp 中写入一条关机记录， 而不实际执行关机动作。</span><br><span class="line">-d, --no-wtmp 不向 wtmp 中写入任何关机记录</span><br><span class="line">-n, --no-sync 在关机前不刷写磁盘缓存</span><br><span class="line">--no-wall 在关机前不发送警告信息</span><br></pre></td></tr></table></figure>
<h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>作用: 重启指令</p>
<p>补充说明: 作为兼容传统的命令存在</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot [OPTINS...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--help 显示简短的帮助信息并退出。</span><br><span class="line">--halt 停机(关闭系统但是不切断电源)</span><br><span class="line">-p, --poweroff 关机(关闭系统并且切断电源)</span><br><span class="line">--reboot 重新启动</span><br><span class="line">-f, --force 强制立即停机/关机/重新启动， 而不与 init 进程通信。</span><br><span class="line">-w, --wtmp-only 仅向 wtmp 中写入一条关机记录， 而不实际执行关机动作。</span><br><span class="line">-d, --no-wtmp 不向 wtmp 中写入任何关机记录</span><br><span class="line">-n, --no-sync 在关机前不刷写磁盘缓存</span><br><span class="line">--no-wall 在关机前不发送警告信息</span><br></pre></td></tr></table></figure>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>作用: 挂在文件系统</p>
<p>补充说明: </p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount [-l|-h|-V]</span><br><span class="line">mount -a [-fFnrsvw] [-t fstype] [-O optlist]</span><br><span class="line">mount [-fnrsvw] [-o options] device|dir</span><br><span class="line">mount [-fnrsvw] [-t fstype] [-o options] device dir</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-V：显示程序版本</span><br><span class="line">-h：显示辅助讯息</span><br><span class="line">-v：显示较讯息，通常和 -f 用来除错。</span><br><span class="line">-a：将 /etc/fstab 中定义的所有档案系统挂上。</span><br><span class="line">-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。</span><br><span class="line">-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。</span><br><span class="line">-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。</span><br><span class="line">-s-r：等于 -o ro</span><br><span class="line">-w：等于 -o rw</span><br><span class="line">-L：将含有特定标签的硬盘分割挂上。</span><br><span class="line">-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。</span><br><span class="line">-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。</span><br><span class="line">-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。</span><br><span class="line">-o sync：在同步模式下执行。</span><br><span class="line">-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。</span><br><span class="line">-o auto、-o noauto：打开/关闭自动挂上模式。</span><br><span class="line">-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.</span><br><span class="line">-o dev、-o nodev-o exec、-o noexec允许执行档被执行。</span><br><span class="line">-o suid、-o nosuid：</span><br><span class="line">允许执行档在 root 权限下执行。</span><br><span class="line">-o user、-o nouser：使用者可以执行 mount/umount 的动作。</span><br><span class="line">-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。</span><br><span class="line">-o ro：用唯读模式挂上。</span><br><span class="line">-o rw：用可读写模式挂上。</span><br><span class="line">-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</span><br></pre></td></tr></table></figure>
<p>常用命令:</p>
<p>挂载一个文件系统</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdc1 /media/store</span><br></pre></td></tr></table></figure>
<h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3><p>作用: 卸载文件系统</p>
<p>补充说明: umount 命令 用于卸载已经加载的文件系统。利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount [-hV]</span><br><span class="line">umount -a [-nrv] [-t vfstype]</span><br><span class="line">umount [-nrv] device | dir [...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-V     打印版本信息并退出。</span><br><span class="line">-h     显示帮助信息并退出。</span><br><span class="line">-v     以冗长模式运行。</span><br><span class="line">-n     在卸载后不将相应信息写入 /etc/mtab 文件。</span><br><span class="line">-r     如果卸载失败，试图以只读方式进行重新挂载。</span><br><span class="line">-a     卸载所有在 /etc/mtab 文件中描述的文件系统。（在 umount 版本或以后的版本中，不会卸载 proc 文件系统）</span><br><span class="line">-t vfstype 只卸载指定类型的文件系统。如果要一次指定多个文件系统， 可以用逗号分隔。如在指定文件系统前加 no ，则可卸载除些文件系统以外的其它文件系统。</span><br><span class="line">-f     强制卸载（比如不可达的 NFS ）。 （此选项须在高于 2.1.116 的版本上使用）</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>通过设备名卸载</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sdc1</span><br></pre></td></tr></table></figure>
<p>通过挂载点卸载</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /media/store</span><br></pre></td></tr></table></figure>
<p>卸载并弹出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eject /media/store</span><br></pre></td></tr></table></figure>
<h3 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h3><p>作用: 更改登录 shell</p>
<p>补充说明: chsh 命令 用来更换登录系统时使用的 shell。若不指定任何参数与用户名称，则 chsh 会以应答的方式进行设置。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh [选项] [登录]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-h, --help 现实帮助信息并退出。</span><br><span class="line">-R, --root CHROOT_DIR Apply changes in the CHROOT_DIR directory and use the configuration files from the CHROOT_DIR directory.</span><br><span class="line">-s, --shell SHELL 用户的新登录 shell 的名称。将此字段设置为空会让系统选择默认的登录 shell。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看系统安装了哪些 shell 可以使用 <code>cat /etc/shells</code> 命令查看</p>
</blockquote>
<h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>作用: 用来探测给定文件的类型。</p>
<p>补充说明: file 命令 用来探测给定文件的类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [ -bcnsvzL ] [ -f 命名文件 ] [ -m 幻数文件 ] file ...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   -b      不输出文件名 (简要模式).</span><br><span class="line">   -c      检查时打印输出幻数文件的解析结果.常与 -m 一起使用，用来在安装幻数文件之前调试它.</span><br><span class="line">   -f 命名文件 从在参数表前的 命名文件 中读出将要检查的文件名(每行一个文件).要有 命名文件 ，或者至少有一个文件名参数; 如果要检查标准输入, 使用``-&apos;&apos;作为文件参数.</span><br><span class="line">-m list 指定包含幻数的文件列表.可以是单个文件，也可以是 用冒号分开的多个文件.</span><br><span class="line">-n      每检查完一个文件就强制刷新标准输出. 仅在检查一组文件时才有效.  一般在将文件类型输出到管道时才采用此选项.</span><br><span class="line">-v      打印程序版本并退出.</span><br><span class="line">-z      试图查看压缩文件内部信息.</span><br><span class="line">-L      (在支持符号链接的系统上)选项显示符号链接文件的原文件, 就像 ls(1) 命令的like-named 选项.</span><br><span class="line">-s      通常, file 只是试图去检查在文件列表中那些 stat(2) 报告为正常文件的文件的类型.由于读特殊文件将可能导致 不可知后果，所以这样可以防止发生问题.使用 -s 选项时 file 命令也将去读文件列表中的块特殊文件和字符特殊文件.  一般用于从原始磁盘分区中获得文件系统类型，此文件为块 特殊文件. 这个选项也导致 file 命令忽略 stat(2) 报告的文件大小，因为在有些系统中原始磁盘分区的大小报告为0.</span><br></pre></td></tr></table></figure>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>作用: 创建目录</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项]... 目录列表...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-m, --mode=模式 设置文件模式(类似chmod)，而不是 rwx 减 umask</span><br><span class="line">-p, --parents 如果目录已存在，不报错，且按需创建父目录</span><br><span class="line">-v, --verbose 为每一个已创建的目录打印信息</span><br><span class="line">-Z     将每个创建的目录的 SELinux 安全上下文设置为默认类型</span><br><span class="line">--context[=CTX] 类似 -Z，或者如果指定了上下文，则将 SELinux 或者 SMACK 安全上下文设置为指定类型</span><br><span class="line">--help 显示此帮助信息并退出</span><br><span class="line">--version 显示版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>创建目录指定权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -m 777 /opt/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>如果创建目录的上级目录不存在，先创建上级目录在创建指定目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /<span class="built_in">test</span>/opt/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>作用: 文件搜索工具</p>
<p>补充说明: grep （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep [options] PATTERN [FILE...]</span><br><span class="line">grep [options] [-e PATTERN | -f FILE] [FILE...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">太多了，使用 man grep 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>一般 grep 配置 Linux 管道进行搜索</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt | grep pattern</span><br></pre></td></tr></table></figure>
<p>不输出匹配行，改为输出匹配的行数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt | grep -c pattern</span><br></pre></td></tr></table></figure>
<h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>作用: 转换和拷贝文件</p>
<p>补充说明: dd 命令 用于复制文件并对原文件的内容进行转换和格式化处理。dd 命令功能很强大的，对于一些比较底层的问题，使用 dd 命令往往可以得到出人意料的效果。用的比较多的还是用 dd 来备份裸设备。但是不推荐，如果需要备份 oracle 裸设备，可以使用 rman 备份，或使用第三方软件备份，使用 dd 的话，管理起来不太方便。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd [--<span class="built_in">help</span>] [--version] [<span class="keyword">if</span>=file] [of=file] [ibs=bytes] [obs=bytes] [bs=bytes] [cbs=bytes] [skip=blocks] [seek=blocks] [count=blocks] [conv=&#123;ascii, ebcdic, ibm, block, unblock, lcase, ucase, swab, noerror, notrunc, sync&#125;]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if=file 从 file 中读而不是标准输入。</span><br><span class="line">of=file 写到 file 里去而不是标准输出。除非指定 conv=notrunc ，否则， dd 将把 file 截为O字节（或由 seek= 选项指定的大小）</span><br><span class="line">ibs=bytes 一次读 bytes 字节。默认是512。</span><br><span class="line">obs=bytes 一次写 bytes 字节。默认是512。</span><br><span class="line">bs=bytes 一次读和写 bytes 字节。这将覆盖 ibs 和 obs 设定的值（并且，设定 bs 不等于同时将 ibs 和 obs 设为同一个值，至少在 只使用 sync, noerror 或 notrunc 转换时是这样的。因为bs规定，每个输入块都应作为单独 的数据块拷贝到输出，而不把较短的块组合到一起）。</span><br><span class="line">cbs=bytes 为 block 转换和 unblock 转换指定转换块的大小。</span><br><span class="line">skip=blocks 在拷贝之前，跳过输入文件的前 blocks 块，每块大小为 ibs-byte 字节。</span><br><span class="line">seek=blocks 在拷贝之前，跳过输出文件的前 blocks 块，每块大小为 obs-byte 字节。</span><br><span class="line">count=blocks 只拷贝输入文件的前 blocks 块（每块的大小为 ibs-byte 字节），而不是全部内容，直到文件末尾。</span><br><span class="line">conv=转换&quot;[,&quot;转换&quot;]...&quot; 将文件按 转换 参数指定的方式转换（在“,”两边没有空格）。</span><br><span class="line">      转换方式包括： </span><br><span class="line">      ascii  将 EBCDIC 转换成 ascii。</span><br><span class="line">      ebcdic 将 ascii 转换成 ebcdic。</span><br><span class="line">      ibm    将 ascii 转换成 alternative ebcdic。</span><br><span class="line">      block  每一行输入，无论长短，输出都是 cbs 字节，并且其中的“换行”（NEWLINE，即c中的&apos;0）用 空格替换。如有必要，行尾会填充空格。</span><br><span class="line">      unblock 用“换行”替换每个输入块（ cbs 字节大小）末尾的空格。</span><br><span class="line">      lcase  将大写字母转换成小写。</span><br><span class="line">      ucase  将小写字母转换成大写。</span><br><span class="line">      swab   交换每对输入字节。如果读入的字节数是奇数，最后 一个字节只是简单的复制到输出（因为没有能跟它交换的 字节了）（POSIX 1003.26，PASC翻译1003.2 3号和4号）。</span><br><span class="line">      noerror 发生读错误时，继续进行。</span><br><span class="line">      notrunc 不截断输出文件。</span><br><span class="line">      sync   用0填充到每个输入块的末尾，使其大小为 ibs 字节。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>制作 Linux 镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/home/ubuntu.iso of=/mnt/usb_device</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>作用: 查找文件</p>
<p>补充说明: 用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [path...] [expression]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">太多了，使用 man find 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出当前目录及子目录下的所有文件和文件夹</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .</span><br></pre></td></tr></table></figure>
<p>在 home 目录下查找以 .txt 结尾的文件名</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure>
<p>在 home 目录下查找以 .txt 结尾的文件名，但忽略大小写</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -iname <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure>
<p>在当前目录查找所有以 .txt 和 .pdf 结尾的文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span></span><br></pre></td></tr></table></figure>
<p>更多参考命令点击<a href="http://wangchujiang.com/linux-command/c/find.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>作用: 移动文件</p>
<p>补充说明: mv 命令 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source 表示源文件或目录，target 表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv [选项]... 源文件 目标文件</span><br><span class="line">mv [选项]... 源文件... 目录</span><br><span class="line">mv [选项]... --target-directory=DIRECTORY SOURCE...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--backup[=CONTROL] 为现有的每一个目标文件作一个备份</span><br><span class="line">-b     和--backup一样但是不接受参数</span><br><span class="line">-f, --force 覆盖前永不提示</span><br><span class="line">-i, --interactive 覆盖前提示</span><br><span class="line">--strip-trailing-slashes 删除任何“源文件”参数后面跟随的斜杠</span><br><span class="line">-S, --suffix=SUFFIX 省略一般的备份后缀</span><br><span class="line">--target-directory=DIRECTORY 移动全部“源文件”参数到“目录”中</span><br><span class="line">-u, --update 只移动更老的或者标记新的非目录</span><br><span class="line">-v, --verbose 说明完成了什么</span><br><span class="line">--help 显示帮助且退出程序 </span><br><span class="line">--version 输出版本信息且退出程序</span><br><span class="line">这是备份后缀 `~&apos;, 除非设定 --suffix 或 SIMPLE_BACKUP_SUFFIX。 这个版本管理方法可以选择通过 --backup 选项或通过</span><br><span class="line">VERSION_CONTROL 环境变量。这些值是：</span><br><span class="line">    none, off 永不做备份 (即使用 --backup)</span><br><span class="line">    numbered, t 做备份编号</span><br><span class="line">    existing, nil 编号，如果编号备份存在，用其它的简单方法</span><br><span class="line">    simple, never 总是做简单备份</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mv 可以用作备份，但是总会有更好的选择</p>
</blockquote>
<p>常用命令</p>
<p>覆盖文件提示</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -i test.txt /home/office</span><br></pre></td></tr></table></figure>
<p>无条件覆盖已经存在的文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -f test.txt /home/office</span><br></pre></td></tr></table></figure>
<p>重命名文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv test.txt test.md</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mv 不仅可以操作文件，也可以操作目录，上述操作对目录同样起作用</p>
</blockquote>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>作用: 列出目录内容</p>
<p>补充说明: ls 命令 用来显示目标列表，在 Linux 中是使用率较高的命令。ls 命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] [文件名...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">太多了，使用 `man ls` 命令查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>查看当前目录的非隐藏文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>查看当前目录的所有文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>
<p>单列查看但前目录的所有文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -1a</span><br></pre></td></tr></table></figure>
<p>查看指定目录的文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /opt</span><br></pre></td></tr></table></figure>
<p>递归输出指定目录下面的文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -R /opt</span><br></pre></td></tr></table></figure>
<p>显示文件夹信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ld /etc/</span><br></pre></td></tr></table></figure>
<p>更多参考命令点击<a href="http://wangchujiang.com/linux-command/c/ls.html" target="_blank" rel="noopener">这里</a>查看</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>作用: 比较两个文件的不同</p>
<p>补充说明: diff 命令 在最简单的情况下，比较给定的两个文件的不同。如果使用“-”代替“文件”参数，则要比较的内容将来自标准输入。diff 命令是以逐行的方式，比较文本文件的异同处。如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">太多了，使用 `man diff` 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>比较两个文件的不同</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff test1.txt test2.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 diff 显示的结果有不明白的，可以参考<a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">这篇文章</a></p>
</blockquote>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>作用: 连接文件并在标准输出上输出</p>
<p>补充说明: cat 命令 连接文件并打印到标准输出设备上，cat 经常用来显示文件的内容。对于大型文件应该使用 <code>more</code> 或者 <code>less</code> 命令分屏显示</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项]... [文件]...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-A, --show-all 等价于 -vET</span><br><span class="line">-b, --number-nonblank 给非空输出行编号，使 -n 失效。</span><br><span class="line">-e     等价于 -vE </span><br><span class="line">-E, --show-ends 在每行结束显示 $</span><br><span class="line">-n, --number 给所有输出行编号</span><br><span class="line">-s, --squeeze-blank 将所有的连续的多个空行替换为一个空行</span><br><span class="line">-t     等价于 -vT</span><br><span class="line">-T, --show-tabs 把 TAB 字符显示为 ^I</span><br><span class="line">-u     （被忽略的选项）</span><br><span class="line">-v, --show-nonprinting 除了 LFD 和 TAB 之外的不可打印字符，用 ^ 和 M- 标记方式显示</span><br><span class="line">--help 显示此帮助信息并退出</span><br><span class="line">--version 显示版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用指令</p>
<p>输出一个文件到终端</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt</span><br></pre></td></tr></table></figure>
<p>将两个文件输出到终端</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test1.txt test2.txt</span><br></pre></td></tr></table></figure>
<p>输出文件内容到文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test1 &gt; newfile</span><br></pre></td></tr></table></figure>
<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>作用: 为文件创建连接</p>
<p>补充说明: ln 命令 用来为文件创件连接，连接类型分为硬连接和软链接两种，默认的连接类型是硬连接。如果要创建软链接必须使用 “-s” 选项。</p>
<blockquote>
<p>关于硬链接和软链接的区别可以看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">这篇文章</a>。<br>简单的说，硬链接就是有多个指针指向同一个文件区域，删除任何一个指针并不会实际删除文件区域，因此不会影响其他指针的使用。<br>软链接则不同，软链接创建的指针指向的不是文件区域，而是指向一个指向文件区域的指针，一旦指向的指针被删除，软链接就无法生效。</p>
</blockquote>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln [options] <span class="built_in">source</span> [dest]</span><br><span class="line">ln [options] source...directory</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--backup[=CONTROL]  为每个已存在的目标文件创建备份文件</span><br><span class="line">-b        类似--backup，但不接受任何参数</span><br><span class="line">-d, -F, --directory   创建指向目录的硬链接(只适用于超级用户)</span><br><span class="line">-f, --force     强行删除任何已存在的目标文件</span><br><span class="line">-i, --interactive           覆盖既有文件之前先询问用户；</span><br><span class="line">-L, --logical               取消引用作为软链接的目标</span><br><span class="line">-n, --no-dereference        把软链接的目的目录视为一般文件；</span><br><span class="line">-P, --physical              直接将硬链接到软链接</span><br><span class="line">-r, --relative              创建相对于链接位置的软链接</span><br><span class="line">-s, --symbolic              对源文件建立软链接，而非硬连接；</span><br><span class="line">-S, --suffix=SUFFIX         用&quot;-b&quot;参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号“~”，用户可通过“-S”参数来改变它；</span><br><span class="line">-t, --target-directory=DIRECTORY  指定要在其中创建链接的DIRECTORY</span><br><span class="line">-T, --no-target-directory   将“LINK_NAME”视为常规文件</span><br><span class="line">-v, --verbose               打印每个链接文件的名称</span><br><span class="line">    --help    显示此帮助信息并退出</span><br><span class="line">    --version   显示版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>创建一个硬链接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln <span class="built_in">source</span> newfile</span><br></pre></td></tr></table></figure>
<p>创建一个软链接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="built_in">source</span> newfile</span><br></pre></td></tr></table></figure>
<h2 id="系统管理相关命令"><a href="#系统管理相关命令" class="headerlink" title="系统管理相关命令"></a>系统管理相关命令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>作用: 报告文件系统磁盘空间的使用情况 </p>
<p>补充说明: df 命令 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-a, --all 列出包括BLOCK为0的文件系统</span><br><span class="line">--block-size=SIZE use SIZE-byte blocks 指定块的大小</span><br><span class="line">-h,--huma-readable&quot; 用常见的格式显示出大小(例如:1K 234M 2G)</span><br><span class="line">-H,--si&quot; 同上,但是这里的1k等于1000字节而不是1024字节</span><br><span class="line">-i, --inodes 用信息索引点代替块表示使用状况</span><br><span class="line">-k, --kilobytes 指定块大小等于1024字节来显示使用状况</span><br><span class="line">-l, --local 只显示本地文件系统使用状况</span><br><span class="line">-m, --megabytes 以指定块大小等于1048576字节(1M)来显示使用状况</span><br><span class="line">--no-sync 在取得使用信息前禁止调用同步 (default)</span><br><span class="line">-P, --portability 使用POSIX格式输出</span><br><span class="line">--sync 在取得使用信息前调用同步 </span><br><span class="line">-t, --type=TYPE 只显示指定类型(TYPE)的文件系统</span><br><span class="line">-T, --print-type 输出每个文件系统的类型</span><br><span class="line">-x, --exclude-type=TYPE 只显示指定类型(TYPE)之外的文件系统.</span><br><span class="line">-v (忽略) </span><br><span class="line">--     输出该命令的帮助信息并退出</span><br><span class="line">--version 输出版本信息并退出</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>友好的方式显示整个文件系统的磁盘使用情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p>查看指定文件系统的使用情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h /</span><br></pre></td></tr></table></figure>
<blockquote>
<p>df 只能查看挂载点上使用情况</p>
</blockquote>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>作用: 显示 Linux 进程</p>
<p>补充说明: top 命令 可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过 top 命令所提供的互动式界面，用热键可以管理。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -hv|-bcHiOSs -d secs -n max -u|U user -p pid -o fld -w [cols]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b：以批处理模式操作；</span><br><span class="line">-c：显示完整的治命令；</span><br><span class="line">-d：屏幕刷新间隔时间；</span><br><span class="line">-I：忽略失效过程；</span><br><span class="line">-s：保密模式；</span><br><span class="line">-S：累积模式；</span><br><span class="line">-i&lt;时间&gt;：设置间隔时间；</span><br><span class="line">-u&lt;用户名&gt;：指定用户名；</span><br><span class="line">-p&lt;进程号&gt;：指定进程；</span><br><span class="line">-n&lt;次数&gt;：循环显示的次数。</span><br></pre></td></tr></table></figure>
<p>top 交互命令</p>
<p>在 top 命令执行过程中可以使用一些交互命令。这些命令都是单字母的，如果在命令行中使用 -s 选项，其中一些命令可能会被屏蔽</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">h：显示帮助画面，给出一些简短的命令总结说明；</span><br><span class="line">k：终止一个进程；</span><br><span class="line">i：忽略闲置和僵死进程，这是一个开关式命令；</span><br><span class="line">q：退出程序；</span><br><span class="line">r：重新安排一个进程的优先级别；</span><br><span class="line">S：切换到累计模式；</span><br><span class="line">s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；</span><br><span class="line">f或者F：从当前显示中添加或者删除项目；</span><br><span class="line">o或者O：改变显示项目的顺序；</span><br><span class="line">l：切换显示平均负载和启动时间信息；</span><br><span class="line">m：切换显示内存信息；</span><br><span class="line">t：切换显示进程和CPU状态信息；</span><br><span class="line">c：切换显示命令名称和完整命令行；</span><br><span class="line">M：根据驻留内存大小进行排序；</span><br><span class="line">P：根据CPU使用百分比大小进行排序；</span><br><span class="line">T：根据时间/累计时间进行排序；</span><br><span class="line">w：将当前设置写入~/.toprc文件中。</span><br></pre></td></tr></table></figure>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>作用: 显示系统中已用和未用的内存空间总和</p>
<p>补充说明: free 命令 可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [-b | -k | -m] [-o] [-s delay ] [-t] [-V]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b 选项 以字节为单位 显示 内存总和; -k 选项 (缺省的) 以 KB 为单位 显示; -m 选项 以 MB 为单位.</span><br><span class="line">-t 选项 显示 一个 总计行.</span><br><span class="line">-o 选项 禁止 &quot;buffer adjusted&quot; 行的显示. 除非 指定 free 从 (相应的) 已用/未用的 内存 减去/加上 缓冲区内存.</span><br><span class="line">-s 使 free 以 delay 秒为间隔, 连续抽样显示. delay 可以设置成浮点数, 它用 usleep(3) 做 微秒级 延迟.</span><br><span class="line">-V 显示版本信息.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>以友好的方式显示内存使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>
<h3 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h3><p>作用: 显示磁盘的使用和限额</p>
<p>补充说明: quota 命令 用于显示用户或者工作组的磁盘配额信息。输出信息包括磁盘使用和配额限制。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quota [ -guv | q ]</span><br><span class="line">quota [ -uv | q ] user</span><br><span class="line">quota [ -gv | q ] group</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-g     显示 用户所在组 的 组限额. 可选项(optional).</span><br><span class="line">-u     和 缺省情况 一样.</span><br><span class="line">-v     显示 文件系统上 的 限额, 即使 没有 占用 空间.</span><br><span class="line">-q     简洁的 信息, 只 显示 超出 限额 的 文件系统.</span><br></pre></td></tr></table></figure>
<h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>作用: 在指定时间执行一个任务</p>
<p>补充说明: at 命令 用于在指定时间执行命令。at 允许使用一套相当复杂的指定时间的方法。它能够接受在当天的 hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用 midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用 12 小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为 month day（月 日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。</p>
<p>上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units，now 就是当前时间，time-units 是时间单位，这里能够是 minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count 是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用 today（今天）、tomorrow（明天）来指定完成命令的时间。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at [-V] [-q 队列] [-f 文件] [-mldbv] 时间 at -c 作业 [作业...]  atq [-V] [-q 队列] [-v]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-V      在标准错误上输出版本号。</span><br><span class="line">-q queue 使用指定的队列。一个队列用一个字母标定，有效的的队列标定的  范围是从a到z和从A到Z。at 的缺省队列是 a,batch 的缺省队列是 b。队列的字母顺序越高，则队列运行时越谦让(运行级别越低)。 指定的队列 &quot;=&quot; 保留给当前运行的作业所在的队列。</span><br><span class="line">如果一个作业被提交到一个以大写字母标定的队列，则与提交到 batch 同样对待。如果给 atq 指定一个队列，则只显示在此指定 队列中的作业。</span><br><span class="line">-m      当作业完成时即使没有输出也给用户发邮件。</span><br><span class="line">-f file 从文件而不是标准输入中读取作业信息。</span><br><span class="line">-l      是 atq 的别名。</span><br><span class="line">-d      是 atrm 的别名。</span><br><span class="line">-v      对于 atq， 显示完整的在队列中未被删除的作业，对于其他 命令，显示作业将要执行的时间。</span><br><span class="line">显示的时间的格式类似于&quot;1997-02-20 14:50&quot;，但如果设置了 POSIXLY_CORRECT 环境变量之后，格式类似于&quot;Thu Feb 20 14:50:00 1996&quot;。</span><br><span class="line">-c      连接命令行中列出的作业并输出到标准输出。</span><br></pre></td></tr></table></figure>
<h3 id="lp"><a href="#lp" class="headerlink" title="lp"></a>lp</h3><p>作用: 打印文件或修改排队的打印任务</p>
<p>补充说明: lp 命令 用于打印文件，或者修改排队的打印任务。与 lpr 命令类似，lp 命令既支持文件输入也支持标准输入。它与 lpr 的不同之处在于它有一个不同（稍微复杂点）的参数选项设置。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lp [ -E ] [ -U username ] [ -c ] [ -d destination[/instance] ] [ -h hostname[:port] ] [ -m ] [ -n num-copies ] [ -o option[=value] ] [ -q priority ] [ -s ] [ -t title ] [ -H handling ] [ -P page-list ] [ -- ] [ file(s) ]</span><br><span class="line">lp [ -E ] [ -U username ] [ -c ] [ -h hostname[:port] ] [ -i job-id ] [ -n num-copies ] [ -o option[=value] ] [ -q priority ] [ -t title ] [ -H handling ] [ -P page-list ]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-E：与打印服务器连接时强制使用加密；</span><br><span class="line">-U：指定连接打印服务器时使用的用户名；</span><br><span class="line">-d：指定接收打印任务的目标打印机；</span><br><span class="line">-i：指定一个存在的打印任务号；</span><br><span class="line">-m：打印完成时发送E-mail；</span><br><span class="line">-n：指定打印的份数；</span><br><span class="line">-t：指定打印任务的名称；</span><br><span class="line">-H：指定打印任务开始的时间；</span><br><span class="line">-P：指定需要打印的页码。</span><br></pre></td></tr></table></figure>
<h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p>作用: 添加一个新成员到系统中</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">adduser [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID]</span><br><span class="line">[--firstuid ID] [--lastuid ID] [--gecos GECOS] [--ingroup GROUP | --gid ID]</span><br><span class="line">[--disabled-password] [--disabled-login] [--add_extra_groups] USER</span><br><span class="line">   Add a normal user</span><br><span class="line"></span><br><span class="line">adduser --system [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID]</span><br><span class="line">[--gecos GECOS] [--group | --ingroup GROUP | --gid ID] [--disabled-password]</span><br><span class="line">[--disabled-login] [--add_extra_groups] USER</span><br><span class="line">   Add a system user</span><br><span class="line"></span><br><span class="line">adduser --group [--gid ID] GROUP</span><br><span class="line">addgroup [--gid ID] GROUP</span><br><span class="line">   Add a user group</span><br><span class="line"></span><br><span class="line">addgroup --system [--gid ID] GROUP</span><br><span class="line">   Add a system group</span><br><span class="line"></span><br><span class="line">adduser USER GROUP</span><br><span class="line">   Add an existing user to an existing group</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--quiet | -q      don&apos;t give process information to stdout</span><br><span class="line">--force-badname   allow usernames which do not match the</span><br><span class="line">                NAME_REGEX configuration variable</span><br><span class="line">--help | -h       usage message</span><br><span class="line">--version | -v    version number and copyright</span><br><span class="line">--conf | -c FILE  use FILE as configuration file</span><br></pre></td></tr></table></figure>
<h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>作用: 创建一个新组</p>
<p>补充说明: groupadd 命令 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] group</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-f, --force		如果组已经存在则成功退出</span><br><span class="line">        并且如果 GID 已经存在则取消 -g</span><br><span class="line">-g, --gid GID                 为新组使用 GID</span><br><span class="line">-h, --help                    显示此帮助信息并推出</span><br><span class="line">-K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值</span><br><span class="line">-o, --non-unique              允许创建有重复 GID 的组</span><br><span class="line">-p, --password PASSWORD       为新组使用此加密过的密码</span><br><span class="line">-r, --system                  创建一个系统账户</span><br><span class="line">-R, --root CHROOT_DIR         chroot 到的目录</span><br></pre></td></tr></table></figure>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>作用: 终止进程</p>
<p>补充说明: kill 命令 用来删除执行中的程序或工作。kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15) ,可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 job 指令查看。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span>[-ssignal|-p][-a]pid...</span><br><span class="line"><span class="built_in">kill</span> -l [ signal ]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pid ...</span><br><span class="line">      给  kill 指定一个该发信号的进程列表. 每个 pid 可为下面四种之一.  进程名 在这种情况下,发信号给所命名的进程.  n 这里的 n 大于 0. 将发信号给 pid 为 n 的进程.  -1 在这种情况下, 只要发信号的用户能够控制那些进行, 将发信号给所</span><br><span class="line">      有从 MAX_INT 到 2 的进程.  -n 这里的 n 大于 1, 在这种情况下, 发信号给属于进程组 n 的进程. 如果给定一个负的参数, 那么信号 必须 首先声明, 否则它会被当作信号发送出去.</span><br><span class="line">-s     指定发送的信号.  信号可以以信号名或数字的方式给定.</span><br><span class="line">-p     指定 kill 只打印命名进程的进程标识 (pid) , 而不应发送给它信号.</span><br><span class="line">-l     打印信号名的列表.这可以在 /usr/include/linux/signal.h 中找到.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出所有信号名称</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure>
<h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>作用: 提交和管理用户的需要周期性执行的任务</p>
<p>补充说明: crontab 命令 被用来提交和管理用户的需要周期性执行的任务，与 windows 下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab [ -u user ] file</span><br><span class="line">crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-e	(edit user&apos;s crontab)</span><br><span class="line">-l	(list user&apos;s crontab)</span><br><span class="line">-r	(delete user&apos;s crontab)</span><br><span class="line">-i	(prompt before deleting user&apos;s crontab)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>crontab 传入的文件参数是指定格式 crontab 文件，关于 crontab 文件的详细信息点击<a href="http://wangchujiang.com/linux-command/c/crontab.html" target="_blank" rel="noopener">这里</a>查看</p>
</blockquote>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>作用: 存储或提取 tar 文件的程序</p>
<p>补充说明: 利用 tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar &lt;操作参数&gt; [选项]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">太多了，使用 `man tar` 命令查看详细信息</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>把一个目录打包并压缩</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf test.tar.gz config install.sh local_install.sh</span><br></pre></td></tr></table></figure>
<p>查看压缩包有哪些文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -ztvf test.tar.gz</span><br></pre></td></tr></table></figure>
<p>只将压缩包内的部分文件解压</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf test.tar.gz config</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解压的文件可以通过 tar -ztvf 查看</p>
</blockquote>
<p>排除部分文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude docker/latex -zcvf docker.tar.gz docker</span><br></pre></td></tr></table></figure>
<p>压缩并保留权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude docker/latex -zcvfp docker.tar.gz docker</span><br></pre></td></tr></table></figure>
<h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h3><p>作用: 解压有 zip 命令压缩的压缩包</p>
<p>补充说明: unzip 命令 用于解压缩由 zip 命令压缩的 “.zip” 压缩包。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [-Z] [-cflptTuvz[abjnoqsCDKLMUVWX$/:^]] file[.zip] [file(s) ...]  [-x xfile(s) ...] [-d exdir]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换；</span><br><span class="line">-f：更新现有的文件；</span><br><span class="line">-l：显示压缩文件内所包含的文件；</span><br><span class="line">-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；</span><br><span class="line">-t：检查压缩文件是否正确；</span><br><span class="line">-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；</span><br><span class="line">-v：执行时显示详细的信息；</span><br><span class="line">-z：仅显示压缩文件的备注文字；</span><br><span class="line">-a：对文本文件进行必要的字符转换；</span><br><span class="line">-b：不要对文本文件进行字符转换；</span><br><span class="line">-C：压缩文件中的文件名称区分大小写；</span><br><span class="line">-j：不处理压缩文件中原有的目录路径；</span><br><span class="line">-L：将压缩文件中的全部文件名改为小写；</span><br><span class="line">-M：将输出结果送到more程序处理；</span><br><span class="line">-n：解压缩时不要覆盖原有的文件；</span><br><span class="line">-o：不必先询问用户，unzip执行后覆盖原有的文件；</span><br><span class="line">-P&lt;密码&gt;：使用zip的密码选项；</span><br><span class="line">-q：执行时不显示任何信息；</span><br><span class="line">-s：将文件名中的空白字符转换为底线字符；</span><br><span class="line">-V：保留VMS的文件版本信息；</span><br><span class="line">-X：解压缩时同时回存文件原来的UID/GID；</span><br><span class="line">-d&lt;目录&gt;：指定文件解压缩后所要存储的目录；</span><br><span class="line">-x&lt;文件&gt;：指定不要处理.zip压缩文件中的哪些文件；</span><br><span class="line">-Z：unzip-Z等于执行zipinfo指令。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>解压文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip test.zip</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般压缩文件使用 tar 来压缩，如果是 zip 压缩格式，很有可能是在 Windows 下进行压缩，在 Linux 下解压时可能出现乱码</p>
</blockquote>
<h3 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h3><p>作用: 压缩或解压文件</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip [ -acfhlLnNrtvV ] [-S 后缀] [ 文件名 ...  ]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-a或——ascii：使用ASCII文字模式；</span><br><span class="line">-c或--stdout或--to-stdout：把解压后的文件输出到标准输出设备；</span><br><span class="line">-f或-force：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</span><br><span class="line">-h或——help：在线帮助；</span><br><span class="line">-l或——list：列出压缩文件的相关信息；</span><br><span class="line">-L或——license：显示版本与版权信息；</span><br><span class="line">-n或--no-name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；</span><br><span class="line">-N或——name：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；</span><br><span class="line">-q或——quiet：不显示警告信息；</span><br><span class="line">-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；</span><br><span class="line">-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；</span><br><span class="line">-t或——test：测试压缩文件是否正确无误；</span><br><span class="line">-v或——verbose：显示指令执行过程；</span><br><span class="line">-V或——version：显示版本信息；</span><br></pre></td></tr></table></figure>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>作用: 列出目前与过去登入系统的用户相关信息</p>
<p>补充说明: last 命令 用于显示用户最近登录信息。单独执行 last 命令，它会读取 /var/log/wtmp 的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last [-R] [-num] [ -n num ] [-adiox] [ -f file ] [name...]  [tty...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-num指定 last 要显示多少行。</span><br><span class="line">&quot;-n num&quot;等同 -num.</span><br><span class="line">-R不显示主机名列。</span><br><span class="line">-a在最后一列显示主机名. 和下一个选项合用时很有用</span><br><span class="line">-d对于非本地的登录，Linux 不仅保存远程主机名而且保存IP地址（IP number）。这个选项可以将IP地址（IP number）转换为主机名。</span><br><span class="line">-i这个选项类似于显示远程主机 IP 地址（IP number）的 -d 选项，只不过它用数字和点符号显示IP数</span><br><span class="line">-o读取一个旧格式的 wtmp 文件 (用linux-libc5应用程序写入的).</span><br><span class="line">-x显示系统关机记录和运行级别改变的日志。</span><br></pre></td></tr></table></figure>
<h2 id="网络操作相关命令"><a href="#网络操作相关命令" class="headerlink" title="网络操作相关命令"></a>网络操作相关命令</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>作用: 配置和显示Linux系统网卡的网络参数</p>
<p>补充说明: ifconfig 命令 被用于配置和显示 Linux 内核中网络接口的网络参数。用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [接口]</span><br><span class="line">ifconfig 接口 [aftype] options | address ...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">add&lt;地址&gt;：设置网络设备IPv6的ip地址；</span><br><span class="line">del&lt;地址&gt;：删除网络设备IPv6的IP地址；</span><br><span class="line">down：关闭指定的网络设备；</span><br><span class="line">&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;：设置网络设备的类型与硬件地址；</span><br><span class="line">io_addr&lt;I/O地址&gt;：设置网络设备的I/O地址；</span><br><span class="line">irq&lt;IRQ地址&gt;：设置网络设备的IRQ；</span><br><span class="line">media&lt;网络媒介类型&gt;：设置网络设备的媒介类型；</span><br><span class="line">mem_start&lt;内存地址&gt;：设置网络设备在主内存所占用的起始地址；</span><br><span class="line">metric&lt;数目&gt;：指定在计算数据包的转送次数时，所要加上的数目；</span><br><span class="line">mtu&lt;字节&gt;：设置网络设备的MTU；</span><br><span class="line">netmask&lt;子网掩码&gt;：设置网络设备的子网掩码；</span><br><span class="line">tunnel&lt;地址&gt;：建立IPv4与IPv6之间的隧道通信地址；</span><br><span class="line">up：启动指定的网络设备；</span><br><span class="line">-broadcast&lt;地址&gt;：将要送往指定地址的数据包当成广播数据包来处理；</span><br><span class="line">-pointopoint&lt;地址&gt;：与指定地址的网络设备建立直接连线，此模式具有保密功能；</span><br><span class="line">-promisc：关闭或启动指定网络设备的promiscuous模式；</span><br><span class="line">IP地址：指定网络设备的IP地址；</span><br><span class="line">网络设备：指定网络设备的名称。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>显示网络设备信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>启动关闭指定网卡</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p>作用: 显示或操作路由，设备，测路路由和通道</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage: ip [ OPTIONS ] OBJECT &#123; COMMAND | <span class="built_in">help</span> &#125;</span><br><span class="line">       ip [ -force ] -batch filename</span><br><span class="line"><span class="built_in">where</span>  OBJECT := &#123; link | address | addrlabel | route | rule | neigh | ntable |</span><br><span class="line">                   tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm |</span><br><span class="line">                   netns | l2tp | fou | macsec | tcp_metrics | token | netconf | ila &#125;</span><br><span class="line">       OPTIONS := &#123; -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |</span><br><span class="line">                    -h[uman-readable] | -iec |</span><br><span class="line">                    -f[amily] &#123; inet | inet6 | ipx | dnet | mpls | bridge | link &#125; |</span><br><span class="line">                    -4 | -6 | -I | -D | -B | -0 |</span><br><span class="line">                    -l[oops] &#123; maximum-addr-flush-attempts &#125; | -br[ief] |</span><br><span class="line">                    -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |</span><br><span class="line">                    -rc[vbuf] [size] | -n[etns] name | -a[ll] | -c[olor]&#125;</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<p>常用命令</p>
<p>查看 ip 地址</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip address</span><br></pre></td></tr></table></figure>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>作用: 向网络主机发送 ICMP 回显请求（ECHO_REQUEST）分组</p>
<p>补充说明: ping 命令 用来测试主机之间网络的连通性。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping  [-aAbBdDfhLnOqrRUvV46]  [-c count] [-F flowlabel] [-i interval] [-I interface] [-l preload] [-m mark] [-M pmtudisc_option] [-N nodeinfo_option] [-w deadline] [-W timeout] [-p pattern] [-Q tos] [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp option] [hop ...] destination</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-4     仅使用 IPv4。</span><br><span class="line">-6     仅使用 IPv6。</span><br><span class="line">-a     Audible ping.</span><br><span class="line">-A     自适应 ping。</span><br><span class="line">-b     允许对一个广播地址进行 ping。</span><br><span class="line">-t ttl 仅进行ping。 设置 IP 的 TTL（Time to Live）。</span><br><span class="line">-T timestamp option 设置特殊的 IP 时间戳选项。 timestamp option 可以是 tsonly（仅时间戳）、 tsandaddr（时间戳和地址）或者 tsprespec host1 [host2 [host3 [host4]]]（预先指定跳数的时间戳）。</span><br><span class="line">-U     打印完整的用户到用户的延迟（旧行为）。通常情况下 ping 打印网络往返延时，它们可能不同，例如在 DNS 解析出现失败时。</span><br><span class="line">-v     输出详细信息。</span><br><span class="line">-V     显示版本并退出。</span><br><span class="line">-c     count 在发送(和接收)了正好数量为 count 的回显应答分组后停止操作。在发送了 count 个分组后没有收到任何分组的特别情况是发送导致了终止(选程主机或网关不可达)。</span><br><span class="line">-d     在所用的套接字上使用 SO_DEBUG 选项。 实际上，这个套接字选项没有被 Linux 内核所使用。</span><br><span class="line">-D     在每行之前打印时间戳（UNIX 时间 + gettimeofday 中的毫秒）。</span><br><span class="line">-f     以高速（洪水）方式进行  ping。  以分组返回的速度来输出其它分组或每秒输出百次。当收到每个回显应答并打印一个退格符时，对每个回显请求都打印一个句点``.&apos;&apos;。这可以快速显示出丢弃了多少个分组，只有超级用户可以用这个选项。这（操作）对网络要求非常苛刻，应该慎重使用。</span><br><span class="line">-i     wait 在发送每个分组时等待 wait 个秒数。缺省值为每个分组等待一秒。此选项与-f选项不能同时使用。</span><br><span class="line">-l     preload 如果指定 preload ，那么 ping 程序在开始正常运行模式前尽可能快地发送分组。同样只有超级用户可以用这个选项。</span><br><span class="line">-n     只以数字形式输出信息。这样就不尝试去查找主机名了。</span><br><span class="line">-p     pattern 可以指定最多16个填充字节用于保持分组长度为16的整数倍。在网络上诊断与数据相关问题时此选项很有用。例如``-p ff&apos;&apos;将使发出的分组都用全1填充数据区。</span><br><span class="line">-q     静态输出。在程序启动和结束时只显示摘要行。</span><br><span class="line">-R     记录路由。在回显请求分组中包含记录路由选项并在相应的分组返回时显示路由缓冲区。注意IP首部的容量只能存放9条这样的路由。很多主机 忽略或禁用此选项。</span><br><span class="line">-r     在所连接的网络上旁路正常的选路表，直接向主机发送分组。如果主机未处于直接相连的网络上，那么返回一个错误。此选项可用来通过无路由接口对一台主机进行检测(例如当接口已被 routed 程序丢弃后)。</span><br><span class="line">-s     packetsize 指定要发送数据的字节量。缺省值为 56 ，这正好在添加了 8 字节的 ICMP 首部后组装成 64 字节的 ICMP 数据报。</span><br><span class="line"> -w     waitsecs 在 waitsecs 秒后停止 ping 程序的执行。当试图检测不可达主机时此选项很有用。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>测试网络状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.biying.com</span><br></pre></td></tr></table></figure>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>作用: 显示网络连接，路由表，接口状态，伪装连接，网络链路信息和组播成员组。</p>
<p>补充说明: netstat 命令 用来打印 Linux 中网络系统的状态信息，可让你得知整个 Linux 系统的网络情况。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">netstat  [address_family_options]  [--tcp|-t]  [--udp|-u]  [--raw|-w]  [--listening|-l]  [--all|-a]  [--numeric|-n]  [--numeric-hosts][--numeric-ports][--numeric-ports]  [--symbolic|-N] [--extend|-e[--extend|-e]] [--timers|-o]</span><br><span class="line">[--program|-p] [--verbose|-v] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--route|-r&#125; [address_family_options] [--extend|-e[--extend|-e]] [--verbose|-v] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--interfaces|-i&#125; [iface] [--all|-a] [--extend|-e[--extend|-e]] [--verbose|-v] [--program|-p] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--groups|-g&#125; [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--masquerade|-M&#125; [--extend|-e] [--numeric|-n] [--numeric-hosts][--numeric-ports][--numeric-ports] [--continuous|-c] [delay]</span><br><span class="line">netstat &#123;--statistics|-s&#125; [--tcp|-t] [--udp|-u] [--raw|-w] [delay]</span><br><span class="line">netstat &#123;--version|-V&#125;</span><br><span class="line">netstat &#123;--<span class="built_in">help</span>|-h&#125;</span><br><span class="line">address_family_options:</span><br><span class="line">[--protocol=&#123;inet,unix,ipx,ax25,netrom,ddp&#125;[,...]]  [--unix|-x] [--inet|--ip] [--ax25] [--ipx] [--netrom] [--ddp]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--verbose , -v 详细模式运行。特别是打印一些关于未配置地址族的有用信息。</span><br><span class="line">--numeric , -n 显示数字形式地址而不是去解析主机、端口或用户名。</span><br><span class="line">--numeric-hosts 显示数字形式的主机但是不影响端口或用户名的解析。</span><br><span class="line">--numeric-ports 显示数字端口号，但是不影响主机或用户名的解析。</span><br><span class="line">--numeric-users 显示数字的用户ID，但是不影响主机和端口名的解析。</span><br><span class="line">--protocol=family , -A 指定要显示哪些连接的地址族(也许在底层协议中可以更好地描述)。 family 以逗号分隔的地址族列表，比如 inet, unix, ipx, ax25, netrom, 和 ddp。 这样和使用 --inet, --unix (-x), --ipx, --ax25, --netrom, 和 --ddp 选项效果相同。</span><br><span class="line">    地址族 inet 包括raw, udp 和tcp 协议套接字。</span><br><span class="line">-c, --continuous 将使 netstat 不断地每秒输出所选的信息。</span><br><span class="line">-e, --extend 显示附加信息。使用这个选项两次来获得所有细节。</span><br><span class="line">-o, --timers 包含与网络定时器有关的信息。</span><br><span class="line">-p, --program 显示套接字所属进程的PID和名称。</span><br><span class="line">-l, --listening 只显示正在侦听的套接字(这是默认的选项)</span><br><span class="line">-a, --all 显示所有正在或不在侦听的套接字。加上 --interfaces 选项将显示没有标记的接口。</span><br><span class="line">-F 显示FIB中的路由信息。(这是默认的选项)</span><br><span class="line">-C 显示路由缓冲中的路由信息。</span><br><span class="line">delay netstat将循环输出统计信息，每隔 delay 秒。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出所有处于监听状态的 Sockets</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -l</span><br><span class="line">netstat -lt</span><br><span class="line">netstat -lu</span><br><span class="line">netstat -lx</span><br></pre></td></tr></table></figure>
<p>列出所有端口，包括监听和未监听的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -a</span><br><span class="line">netstat -at</span><br><span class="line">netstat -au</span><br></pre></td></tr></table></figure>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>作用: 登录远程主机和管理(测试ip端口是否连通)</p>
<p>补充说明: telnet 命令 用于登录远程主机，对远程主机进行管理。telnet 因为采用明文传送报文，安全性不好，很多 Linux 服务器都不开放 telnet 服务，而改用更安全的 ssh 方式了。</p>
<p>语法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [-468ELadr] [-S tos] [-b address] [-e escapechar] [-l user] [-n tracefile] [host [port]]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-8：允许使用8位字符资料，包括输入与输出；</span><br><span class="line">-a：尝试自动登入远端系统；</span><br><span class="line">-b&lt;主机别名&gt;：使用别名指定远端主机名称；</span><br><span class="line">-c：不读取用户专属目录里的.telnetrc文件；</span><br><span class="line">-d：启动排错模式；</span><br><span class="line">-e&lt;脱离字符&gt;：设置脱离字符；</span><br><span class="line">-E：滤除脱离字符；</span><br><span class="line">-f：此参数的效果和指定&quot;-F&quot;参数相同；</span><br><span class="line">-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；</span><br><span class="line">-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；</span><br><span class="line">-K：不自动登入远端主机；</span><br><span class="line">-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；</span><br><span class="line">-L：允许输出8位字符资料；</span><br><span class="line">-n&lt;记录文件&gt;：指定文件记录相关信息；</span><br><span class="line">-r：使用类似rlogin指令的用户界面；</span><br><span class="line">-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息；</span><br><span class="line">-x：假设主机有支持数据加密的功能，就使用它；</span><br><span class="line">-X&lt;认证形态&gt;：关闭指定的认证形态。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet &lt;ip&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h3><p>作用: Internet 文件传输程序 (file transfer program)</p>
<p>补充说明: 用户通过 Ftp 这个程序来使用 Internet 上的标准文件传输协议 (File Transfer  Protocol).  本程序允许用户向远端网站发送文件, 或从远端网站接收文件.</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp [-pinegvd] [host] pftp [-inegvd] [host]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-p    使用被动模式进行数据传输. 如果你本地网络有防火墙, 外部主机不能连接到你这个客户端, 这个选项就派上用场了.  本选项要求 ftp 服务器支持 PASV 命令.  如果使用 pftp 从命令行启动 ftp, 本选项是默认打开的.</span><br><span class="line">-i    进行多个文件传输时关掉交互式的确认提示.</span><br><span class="line">-n    一般，在启动 ftp 时, ftp 会试着进行自动登录. 本选项可以关掉这个功能.  如果 auto-login 功能被启用的话,  ftp 会在用户 home 目录下的 .netrc (参阅 netrc(5)) 文件中查找远端主机上的用户帐号.  如果 .netrc 文件中用户帐号这一项不存在, ftp 会提示用户输入远端主机上的登录名 (缺省为用户在本地机器上的帐号), 如果需要, 还会提示你输入密码和用来登录的帐号. ??</span><br><span class="line">-e    如果被编译成了 ftp 可执行格式, 本选项会关掉命令编辑和历史命令功能; 否则什么也不做. ??</span><br><span class="line">-g    关掉文件名匹配功能.</span><br><span class="line">-v    显示详细信息. 本选项使得 ftp 显示远端服务器的所有响应, 并在数据传输完成后显示传输数据的统计信息.</span><br><span class="line">-d    打开 debug 模式.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp &lt;ip&gt;</span><br></pre></td></tr></table></figure>
<h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>作用: 显示 / 操作 IP 选路表</p>
<p>补充说明: route 程序对内核的IP选路表进行操作。它主要用于通过已用 ifconfig 程序配置好的接口来指定的主机或网络设置静态路由。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">route [-CFvnee]</span><br><span class="line">route  [-v]  [-A     family] add [-net|-host] target [netmask Nm] [gw Gw] [metric N] [mss M] [window W] [irtt  I][reject] [mod] [dyn] [reinstate] [[dev] If]</span><br><span class="line">route  [-v]  [-A     family]  del [-net|-host] target [gw Gw][netmask Nm] [metric N] [[dev] If]</span><br><span class="line">route  [-V] [--version] [-h] [--<span class="built_in">help</span>]</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>列出当前路由</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure>
<p>添加/设置网关</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0    <span class="comment">#增加一条到达244.0.0.0的路由。</span></span><br></pre></td></tr></table></figure>
<p>屏蔽一条路由：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject     <span class="comment">#增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝。</span></span><br></pre></td></tr></table></figure>
<p>删除路由记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure>
<p>删除和添加设置默认网关：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route del default gw 192.168.120.240</span><br><span class="line">route add default gw 192.168.120.240</span><br></pre></td></tr></table></figure>
<h3 id="rlogin"><a href="#rlogin" class="headerlink" title="rlogin"></a>rlogin</h3><p>作用: 从当前终端登录到远程Linux主机</p>
<p>补充说明: 请用 SSH</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlogin [-8EKLdx] [-e char] [-l username] host</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-8    -8 选项 允许 进行 8 位的 输入 数据 传送; 否则在 远程主机 未使用 与 ^S/^Q 不同的 控制 字符 之前, 所有的 奇偶 校验位 都会 被清除.</span><br><span class="line">-E    -E 选项 阻塞(stops) 一些 被识别 为转意 字符 的字符.  当 使用了 -8 选项时, 这样 可以 提供 完全 透明的 连接.</span><br><span class="line">-K    -K 选项 关闭 所有的 Kerberos 安全 鉴别.</span><br><span class="line">-L    -L 选项 允许 rlogin 会话 以 ``litout&apos;&apos; 模式 运行(参见 tty(4))</span><br><span class="line">-d    -d 选项 启动 套接字 调试(参见 setsockopt(2)) , 在 TCP 类型 的连接中, 套接字 用于 提供 与远程 主机的 通讯.</span><br><span class="line">-e    -e 选项 允许 用户 指定 转意 字符, 缺省是 ``~&apos;&apos;.  可以 直接 使用 字符, 也可以 使用 八进制值 进行 指定, 八进制 格式为: \nnn.</span><br><span class="line">-k    -k 选项 要求 rlogin 在从 远程 接受 许可证时, 使用 realm 中定义的 realm, 而不是 krb_realmofhost(3) 中定义的 realm.</span><br><span class="line">-x    -x 选项 使通过 rlogin 会话 进行的 数据 传送 都要 采用 DES 加密.  这可能 会影响 响应 时间和 CPU 的利用, 但 提高了 安全性.</span><br></pre></td></tr></table></figure>
<h3 id="rcp"><a href="#rcp" class="headerlink" title="rcp"></a>rcp</h3><p>作用: 安装在两台主机之间通信</p>
<p>补充说明: rcp 似乎是 scp 的一个马甲，实际使用的 scp 命令。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp [-pqrvBC1246] [-F ssh_config] [-S program] [-P port] [-c cipher] [-i identity_file] [-l <span class="built_in">limit</span>] [-o ssh_option] [[user@]host1:]file1 [...] [[user@]host2:]file2</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-c cipher Selects the cipher to use for encrypting the data transfer.  This option is directly passed to ssh(1).</span><br><span class="line">-i identity_file Selects the file from which the identity (private key) for RSA authentication is read.  This option is directly passed to ssh(1).</span><br><span class="line">-l limit Limits the used bandwidth, specified in Kbit/s.</span><br><span class="line">-p      Preserves modification times, access times, and modes from the original file.</span><br><span class="line">-r      递归复制整个目录。</span><br><span class="line">-v      详细模式。该选项使 scp 和 ssh(1) 打印出关于运行情况的调试信息。在进行调试连接、验证和配置问题时，这会很有用的</span><br><span class="line">-B      用批模式(避免重复询问口令)。</span><br><span class="line">-q      Disables the progress meter.</span><br><span class="line">-C      允许压缩。向 ssh(1) 传递 -C 标志以允许压缩。</span><br><span class="line">-F ssh_config Specifies an alternative per-user configuration file for ssh.  This option is directly passed to ssh(1).</span><br><span class="line">-P port Specifies the port to connect to on the remote host.  Note that this option is written with a capital ‘P’, because -p is already reserved for preserving the times and modes of the file in rcp(1).</span><br><span class="line">-S program Name of program to use for the encrypted connection.  The program must understand ssh(1) options.</span><br><span class="line">-o ssh_option Can be used to pass options to ssh in the format used in ssh_config(5).  This is useful for specifying options for which there is no separate scp command-line flag.</span><br><span class="line">-1      Forces scp to use protocol 1.</span><br><span class="line">-2      Forces scp to use protocol 2.</span><br><span class="line">-4      Forces scp to use IPv4 addresses only.</span><br><span class="line">-6      Forces scp to use IPv6 addresses only.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>从本地复制到远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp /<span class="built_in">test</span> root@&lt;ip&gt;:/home/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<p>从远程主机复制到本地</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp root@&lt;ip&gt;:/home/<span class="built_in">test</span> <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<p>从远程主机复到远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp root@&lt;ip&gt;:/home/<span class="built_in">test</span> root@&lt;nwe-ip&gt;:/home/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><p>作用: 用户信息查找程序</p>
<p>补充说明: finger 命令 用于查找并显示用户信息。包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行 finger 指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finger [-lmsp] [user ...] [user@host ...]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-s    Finger 显示用户的登录名, 真名, 终端名 以及写 状态(如果写被禁止，在终端名后显示一个``*&apos;&apos;), 空闲时间,登录时间,办公地点和电话等。</span><br><span class="line">   登录时间显示为月,天,小时和分钟，如果是超过6个月以前，则 显示年份，而不是小时和分钟。</span><br><span class="line">   不明设备以及不存在的空闲时间和登录时间显示为一个星号。</span><br><span class="line">-l    产生一个多行显示来描述信息 -s 关于用户家目录，家庭电话，登录脚本，邮件状态和文件的内容 “.plan” 和 “.project” 和 “.forward” 从用户的家目录.</span><br><span class="line">   11位数字电话号码显示为 ``+N-NNN-NNN-NNNN&apos;&apos;.  十位或七位数字可以显示为它的子集。 五位数字电话号码显示为 ``xN-NNNN&apos;&apos;.  四位数字电话号码显示为 ``xNNNN&apos;&apos;.</span><br><span class="line">   如果对设备写被禁止, 短语 ``(messages off)&apos;&apos; 被附加在有此设备的行后边.  每一个用户有一个条目，用 -l 选项; 如果一个用户多次登录, 终端信息 按每次登录重复显示。.</span><br><span class="line">   如果什么邮件都没有，邮件信息显示为``No Mail.&apos;&apos;, 如果当新邮件来后， 已经查看过信箱，为``Mail last read DDD MMM ## HH:MM YYYY (TZ)&apos;&apos; 如果有新邮件，则为 ``New mail received ...&apos;&apos;,``  Unread since ...&apos;&apos;</span><br><span class="line">-p    防止 finger -l 选项 显示 “.plan”</span><br><span class="line">    和 “.project” 文件的内容。</span><br><span class="line">-m    防止 user 名字的匹配.  User 通常是一个登录名; 可是, 也会对用户的真实名字 进行匹配, 除非提供 -m 选项.  所有由 finger 进行的名字匹配是区分大小写的</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finger</span><br></pre></td></tr></table></figure>
<h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><p>作用: 发送和接受邮件</p>
<p>补充说明: mail 命令 是命令行的电子邮件发送和接收工具。操作的界面不像 elm 或 pine 那么容易使用，但功能非常完整。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] to-addr... mail [-iInNv] -f [name] mail [-iInNv] [-u user]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b&lt;地址&gt;：指定密件副本的收信人地址；</span><br><span class="line">-c&lt;地址&gt;：指定副本的收信人地址；</span><br><span class="line">-f&lt;邮件文件&gt;：读取指定邮件文件中的邮件；</span><br><span class="line">-i：不显示终端发出的信息；</span><br><span class="line">-I：使用互动模式；</span><br><span class="line">-n：程序使用时，不使用mail.rc文件中的设置；</span><br><span class="line">-N：阅读邮件时，不显示邮件的标题；</span><br><span class="line">-s&lt;邮件主题&gt;：指定邮件的主题；</span><br><span class="line">-u&lt;用户帐号&gt;：读取指定用户的邮件；</span><br><span class="line">-v：执行时，显示详细的信息。</span><br></pre></td></tr></table></figure>
<h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>作用: 查询域名DNS信息的工具</p>
<p>补充说明: nslookup 命令 是常用域名查询工具，就是查 DNS 信息用的命令。</p>
<p>nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p>
<p>进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup [-option] [name | -] [server]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sil：不显示任何警告信息。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.biying.com</span><br></pre></td></tr></table></figure>
<h2 id="系统安全相关命令"><a href="#系统安全相关命令" class="headerlink" title="系统安全相关命令"></a>系统安全相关命令</h2><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>作用: 修改用户密码</p>
<p>补充说明: 命令用来更改用户账户的密码。普通用户通常只更改其自己账户的密码，而超级用户可以更改任何账户的密码。passwd 也更改账户或相关的密码有效期。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] [登录]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-a, --all 此选项只能和 -S 一起使用，来显示所有用户的状态。</span><br><span class="line">-d, --delete 删除用户密码(让它为空)。这是禁用一个用户密码的快速方法。它将设置给出名称的账户。</span><br><span class="line">-e, --expire 让一个账户的密码立即过期。这可以强制一个用户下次登录时更改密码。</span><br><span class="line">-h, --help 现实帮助信息并退出。</span><br><span class="line">-i, --inactive INACTIVE 此选项用于在密码过期一定天数之后禁用账户。一个用户账户密码已经过期 INACTIVE 天之后，用户将不能再登录进账户。</span><br><span class="line">-k, --keep-tokens 表示密码更改只应该因为认证口令(密码)过期更改。用户希望保持他们尚未过期的口令。</span><br><span class="line">-l, --lock 锁定指定账户的密码。此选项通过将密码更改为一个不可能与加密值匹配的值来禁用(它在密码开头添加一个“!”)。</span><br><span class="line">   注意，这并没有禁用此账户。用户仍然可以通过其它认证方式(如 SSH 密码)来登录。要禁用此账户，管理员需要使用 usermod --expiredate 1 (设置账户的过期时间为1970年1月2日)。</span><br><span class="line">   被锁定了密码的用户不允许更改密码。</span><br><span class="line">-n, --mindays MIN_DAYS 在密码更改之间的最小天数设置为 MIN_DAYS。此字段中的 0 值表示用户可以在任何时间更改其密码。</span><br><span class="line">-q, --quiet 安静模式。</span><br><span class="line">-r, --repository REPOSITORY 在 REPOSITORY 中更改密码</span><br><span class="line">-R, --root CHROOT_DIR Apply changes in the CHROOT_DIR directory and use the configuration files from the CHROOT_DIR directory.</span><br><span class="line">-S, --status 显示账户状态信息。状态信息包含 7 个字段。首个字段是用户的登录名，第二个字段表示用户账户是否已经锁定密码(L)、没有密码 (NP)或者密码可用(P)，第三个字段给出最后一次更改密码的日期。接下来的四个字段分别是密码的最小年龄、最大年龄、警告期和禁用期。这些年龄以天为单位计算。</span><br><span class="line">-u, --unlock 解锁指定用户的密码。此操作通过将密码改回先前值(改回使用 -l 之前的值)重新启用密码。</span><br><span class="line">-w, --warndays WARN_DAYS 设置在要求更改密码之前警告的天数。WARN_DAYS 选项是在密码过期之前提前警告的天数。</span><br><span class="line">-x, --maxdays MAX_DAYS 设置密码仍然有效的最大天数。MAX_DAYS 之后，密码会要求更改。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>用户修改自己的密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<p>管理员创建用户之后，使用 passwd 为新用户创建密码，当然也可以任意修改用户的密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd &lt;new-user-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>作用: 用于切换当前用户身份到其他用户身份</p>
<p>补充说明: su 命令 用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [选项] [用户名]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c, --command COMMAND 通过使用其 -c 选项，指定一个由 shell 运行的命令。</span><br><span class="line">-, -l, --login 提供一个类似于用户直接登录的环境，用户可能会希望这样。</span><br><span class="line">-s, --shell SHELL 将使用的 shell。</span><br><span class="line">-m, -p, --preserve-environment 保留当前环境，除非：.PP $PATH</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>切换为 root 用户</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>
<p>切换为其他用户</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su &lt;other-user&gt;</span><br></pre></td></tr></table></figure>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>作用: 用来设置限制新建文件权限的掩码</p>
<p>补充说明: umask 命令 用来设置限制新建文件权限的掩码。当新文件被创建时，其最初的权限由文件创建掩码决定。用户每次注册进入系统时，umask 命令都被执行， 并自动设置掩码 mode 来限制新文件的权限。用户可以通过再次执行 umask 命令来改变默认值，新的权限将会把旧的覆盖掉。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span> [-p] [-S] [模式]</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p：输出的权限掩码可直接作为指令来执行；</span><br><span class="line">-S：以符号方式输出权限掩码。</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>设置掩码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span> u=rwx,g=,o=</span><br></pre></td></tr></table></figure>
<p>运行上述命令之后创建的文件，默认权限为 -rw——-</p>
<h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>作用: 修改文件或目录所属的群组</p>
<p>补充说明: chgrp 命令 用来改变文件或目录所属的用户组。该命令用来改变指定文件所属的用户组。其中，组名可以是用户组的 id，也可以是用户组的组名。文件名可以 是由空格分开的要改变属组的文件列表，也可以是由通配符描述的文件集合。如果用户不是该文件的文件主或超级用户 (root) ，则不能改变该文件的组。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项列表]... 组 文件...</span><br><span class="line">chgrp [选项列表]... --reference=参考文件 文件...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-R 递归式地改变指定目录及其下的所有子目录和文件的所属的组</span><br><span class="line">-c或——changes：效果类似“-v”参数，但仅回报更改的部分；</span><br><span class="line">-f或--quiet或——silent：不显示错误信息；</span><br><span class="line">-h或--no-dereference：只对符号连接的文件作修改，而不是该其他任何相关文件；</span><br><span class="line">-H如果命令行参数是一个通到目录的符号链接，则遍历符号链接</span><br><span class="line">-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；</span><br><span class="line">-L遍历每一个遇到的通到目录的符号链接</span><br><span class="line">-P不遍历任何符号链接（默认）</span><br><span class="line">-v或——verbose：显示指令执行过程；</span><br><span class="line">--reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>改变一个文件所属用户组</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp canxing <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>改变一个目录以及目录下所有文件所属用户组</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp -R canxing <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>作用: 修改文件所有者和组别</p>
<p>补充说明: chown 修改每个由第一个非选项参数声明的给定 file(文件) 的用户和/或组的所有权.如下: 如果只给出了用户名(或者数字用户标识),那么该用户即成为每个指定 文件的所有者,而该文件的组别并不改变.如果用户名后面紧跟着冒号和组名(或者是数字组标识),并且它们之间没有空格,那么文件的组所有权 也随之改变.</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [options] user [:group] file...</span><br></pre></td></tr></table></figure>
<p>选项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c, --changes 详尽地描述每个 file 实际改变了哪些所有权.</span><br><span class="line">-f, --silent, --quiet 不打印文件所有权不能修改的报错信息.</span><br><span class="line">-h, --no-dereference 只作用于其本身的符号链接,而不修改它们所指向的文件.  这只在提供了 lchown 系统调用的情况下才可用.</span><br><span class="line">-v, --verbose 详尽地描述对每个 file 所执行的操作(或者无操作).</span><br><span class="line">-R, --recursive 递归地修改目录及其下面内容的所有权.</span><br><span class="line">--dereference 修改符号链接目标端的所有权,而非符号链接自身.  (fileutils 4.0中实现的新功能.)</span><br><span class="line">--reference=rfile (fileutils 4.0中实现的新功能.)  修改 file 的所有权为 rfile 的所有权.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>改变文件的所有者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown canxing <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>改变目录以及目录下所有文件的所有者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R canxing <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>作用: 变更目录或文件权限</p>
<p>补充说明: chmod 命令 用来变更文件或目录的权限。在 UNIX 系统家族里，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。用户可以使用 chmod 指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [options] mode file...</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c, --changes 只有在文件的权限确实改变时才进行详细的说明</span><br><span class="line">-f, --silent, --quiet 不输出权限不能改变的文件的错误信息</span><br><span class="line">-v, --verbose 详细说明权限的变化</span><br><span class="line">-R, --recursive 改变目录及其所有子目录的文件的权限</span><br><span class="line">--reference=rfile (更新在fileutils 4.0上) 改变文件的模式到rfile.</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<p>使用数字修改文件或目录权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 <span class="built_in">test</span> </span><br><span class="line">chmod -R 755 <span class="built_in">test</span>-dir/</span><br></pre></td></tr></table></figure>
<p>增加其他用户的执行权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod o+x <span class="built_in">test</span></span><br><span class="line">chmod -R o+x <span class="built_in">test</span>-dir/</span><br></pre></td></tr></table></figure>
<h3 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h3><p>作用: 用来改变文件属性</p>
<p>补充说明: chattr 命令 用来改变文件属性。这项指令可改变存放在 ext2 文件系统上的文件或目录属性，这些属性共有以下 8 种模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a：让文件或目录仅供附加用途；</span><br><span class="line">b：不更新文件或目录的最后存取时间；</span><br><span class="line">c：将文件或目录压缩后存放；</span><br><span class="line">d：将文件或目录排除在倾倒操作之外；</span><br><span class="line">i：不得任意更动文件或目录；</span><br><span class="line">s：保密性删除文件或目录；</span><br><span class="line">S：即时更新文件或目录；</span><br><span class="line">u：预防意外删除。</span><br></pre></td></tr></table></figure></p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [ -RVf ] [ -v 版本 ] [ -p project ] [ mode ] files...</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-R     递归地修改目录以及其下内容的属性.  如果在递归目录时遇到了符号链接,遍历将跳过.</span><br><span class="line">-V     详尽地给出chattr的输出信息并打印出程序的版本.</span><br><span class="line">-v version 设置文件系统的版本.</span><br></pre></td></tr></table></figure>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>作用: 以其他用户的身份来执行命令</p>
<p>补充说明: sudo 命令 用来以其他身份来执行命令，预设的身份为 root。在 /etc/sudoers 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用 sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo -h | -K | -k | -V</span><br><span class="line">sudo -v [-AknS] [-a <span class="built_in">type</span>] [-g group] [-h host] [-p prompt] [-u user]</span><br><span class="line">sudo -l [-AknS] [-a <span class="built_in">type</span>] [-g group] [-h host] [-p prompt] [-U user] [-u user] [<span class="built_in">command</span>]</span><br><span class="line">sudo [-AbEHnPS] [-a <span class="built_in">type</span>] [-C num] [-c class] [-g group] [-h host] [-p prompt] [-r role] [-t <span class="built_in">type</span>] [-u user] [VAR=value] [-i | -s] [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b：在后台执行指令；</span><br><span class="line">-h：显示帮助；</span><br><span class="line">-H：将HOME环境变量设为新身份的HOME环境变量；</span><br><span class="line">-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。</span><br><span class="line">-l：列出目前用户可执行与无法执行的指令；</span><br><span class="line">-p：改变询问密码的提示符号；</span><br><span class="line">-s&lt;shell&gt;：执行指定的shell；</span><br><span class="line">-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；</span><br><span class="line">-v：延长密码有效期限5分钟；</span><br><span class="line">-V ：显示版本信息。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没啥用</p>
</blockquote>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>作用: 报告当前程序的状态</p>
<p>补充说明:</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">太多，使用 `man ps` 查看</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure>
<p>上述命令会输出所有当前运行进程的详细信息，再通过管道即可获取想要的信息</p>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>作用: 显示已登录用户</p>
<p>补充说明: who 命令 是显示目前登录系统的用户信息。执行 who 命令可得知目前有那些用户登入系统，单独执行 who 命令会列出登入帐号，使用的终端机，登入时间以及从何处登入或正在使用哪个 X 显示器。</p>
<p>语法:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who [选项]... [ 文件 | 参数1 参数2 ]</span><br></pre></td></tr></table></figure>
<p>选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-a, --all 等价于 -b -d --login -p -r -t -T -u</span><br><span class="line">-b, --boot 最近一次系统引导的时间</span><br><span class="line">-d, --dead 显示死进程</span><br><span class="line">-H, --heading 显示表格的表头</span><br><span class="line">--ips  显示 IP地址而不是主机名。加上 --lookup，则会尽可能基于已存储的 IP 规范化，而不是已存储的主机名</span><br><span class="line">-l, --login 显示系统登录进程</span><br><span class="line">--lookup 试图通过 DNS 规范主机名</span><br><span class="line">-m     仅显示和标准输入关联的主机名和用户</span><br><span class="line">-p, --process 显示由 init 生成的活跃进程</span><br><span class="line">-q, --count 所有登录名称与已登录用户数量</span><br><span class="line">-r, --runlevel 显示当前运行级别</span><br><span class="line">-s, --short 仅显示名称、线路与时间（默认）</span><br><span class="line">-t, --time 显示最近一次系统时钟更改</span><br><span class="line">-T, -w, --mesg 添加用户状态信息，如 +, - 或 ?</span><br><span class="line">-u, --users w列出已登陆用户</span><br><span class="line">--message 等价于 -T</span><br><span class="line">--writable 等价于 -T</span><br><span class="line">--help 显示此帮助信息并退出</span><br><span class="line">--version 显示版本信息并退出</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/26/docker基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/26/docker基础/" class="post-title-link" itemprop="url">docker基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-26 21:04:08" itemprop="dateCreated datePublished" datetime="2018-11-26T21:04:08+08:00">2018-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><p>本文参考自 <code>&lt;&lt;Docker--从入门到实践&gt;&gt;</code>，该书<a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">github 地址</a>，<a href="https://gitee.com/docker_practice/docker_practice" target="_blank" rel="noopener">国内镜像</a></p>
<ul>
<li><a href="#基本概念">基本概念</a></li>
<li><a href="#镜像">镜像</a><ul>
<li><a href="#获取镜像">获取镜像</a></li>
<li><a href="#查看本地镜像">查看本地镜像</a></li>
<li><a href="#运行镜像">运行镜像</a></li>
<li><a href="#停止容器">停止容器</a></li>
<li><a href="#删除本地镜像">删除本地镜像</a></li>
<li><a href="#定制镜像">定制镜像</a></li>
<li><a href="#Dockerfile指令">Dockerfile 指令</a></li>
<li><a href="#导入导出镜像">导入导出镜像</a></li>
</ul>
</li>
<li><a href="#容器">容器</a><ul>
<li><a href="#启动容器">启动容器</a></li>
<li><a href="#查看容器信息">查看容器信息</a></li>
<li><a href="#终止容器">终止容器</a></li>
<li><a href="#进入容器">进入容器</a></li>
<li><a href="#删除容器">删除容器</a></li>
</ul>
</li>
<li><a href="#数据管理">数据管理</a><ul>
<li><a href="#数据卷">数据卷</a></li>
<li><a href="#挂载主机目录">挂载主机目录</a></li>
</ul>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Docker 包含三个基本概念: 镜像，容器，仓库。镜像是模板，容器是根据镜像的定义生成的，仓库是存放镜像的地方。镜像在 VirtualBox 的概念相当于一个 OVA 文件，VirtualBox 可以导入这个 OVA 文件创建一个虚拟机，这个虚拟机就相当于容器的概念（并不是完全相似，容器在退出时会删除所有容器中的数据，每次启动容器就好像第一次启动，通过一些方法可以保存容器中的数据），存放 OVA 文件的地方就相当于一个仓库。</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序，库，资源，配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷，环境变量，用户等）。镜像不包含任何动态数据，其内容在构建之后也不会改变。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。命令格式为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号] /][用户名/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>其中大部分参数可以省略，一个最简单的 <code>docker pull</code> 命令如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure>
<p>如果没有指定镜像的地址，那么默认地址为 Docker Hub 的地址，如果没有指定标签，那么默认标签为 latest。执行上面命令，会默认从 Docker Hub 拉取 hello-world:latest 镜像。</p>
<h3 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h3><p>通过 <code>docker imager ls</code> 命令可以查看本地安装的镜像</p>
<p>在本地运行上述命令得到的结果如下：</p>
<table>
<thead>
<tr>
<th>REPOSITORY</th>
<th>TAG</th>
<th>IMAGE ID</th>
<th>CREATED</th>
<th>SIZE</th>
</tr>
</thead>
<tbody>
<tr>
<td>hello-world</td>
<td>latest</td>
<td>4ab4c602aa5e</td>
<td>7 weeks ago</td>
<td>1.84kB</td>
<td></td>
</tr>
</tbody>
</table>
<p>上述命令会列出本地镜像的所有信息，包括镜像名称，镜像标签，镜像 ID，镜像创建时间和镜像大小。</p>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>获取到一个镜像之后，就可以利用这个镜像为基础启动一个容器。</p>
<p>使用 <code>docker run</code> 命令可以运行一个容器。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>在执行 <code>docker run</code> 命令时，会首先检查本地镜像，如果本地没有指定的镜像，会从指定的仓库拉取指定镜像。</p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>启动一个容器之后可以通过 <code>docker container ls</code> 命令来查看容器的运行状态。</p>
<p>如果想要终止容器，使用 <code>docker container stop</code> 命令终止。对于已经停止的容器可以使用 <code>docker container start</code> 来重新启动。此外 <code>docker container restart</code> 命令会将一个正在运行的容器终止，然后重新启动。</p>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>删除本地镜像使用 <code>docker image rm</code>命令，其格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<p>其中镜像可以是镜像短 ID，镜像长 ID，镜像名或者镜像摘要</p>
<h3 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h3><p>Docker Hub 提供了很多镜像可以直接使用，对于在 Docker Hub 或者其他 Docker 仓库没有找到合适的镜像时，可以依赖某个镜像来创建符合自己需要的镜像。</p>
<p>这里使用 Dockerfile 来定制镜像。</p>
<p>这里定制的镜像以 Ngxin 镜像来基础进行创建，修改的内容为改变 Nginx 的 index.html 页面。首先创建 <code>mynginx</code> 目录，在 <code>mynginx</code> 目录中创建 <code>Dockerfile</code> 文件，Dockerfile 文件内容如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"&lt;h1&gt;Hello, Docker!&lt;/h1&gt;"</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<p>接着使用 <code>docker build -t nginx:v3 .</code> 命令来构建这个镜像，执行该命令输出如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"> ---&gt; dbfc48660aeb</span><br><span class="line">Step 2/2 : RUN <span class="built_in">echo</span> <span class="string">"&lt;h1&gt;Hello, Docker!&lt;/h1&gt;"</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e0233dda1b82</span><br><span class="line">Removing intermediate container e0233dda1b82</span><br><span class="line"> ---&gt; 135ca948fc71</span><br><span class="line">Successfully built 135ca948fc71</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure>
<p>接着使用 <code>docker image ls</code> 命令来查看本地镜像，可以看见本地镜像中已经创建好了 <code>nginx:v3</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[canxing@debian docker] $ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               v3                  135ca948fc71        40 seconds ago      109MB</span><br><span class="line">nginx               v2                  03fa889452ca        About an hour ago   109MB</span><br><span class="line">nginx               latest              dbfc48660aeb        2 weeks ago         109MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        7 weeks ago         1.84kB</span><br></pre></td></tr></table></figure>
<p>接着使用 <code>docker run --name web3 -d -p 80:80 nginx:v3</code> 命令来启动容器，在浏览器中输入 <code>localhost</code> 即可看见 Nginx 的 index.html 页面已经改变。</p>
<p>定制一个 Docker 镜像的关键在于 Dockerfile 文件，对于 Dockerfile 文件中的指令信息请看下面。</p>
<h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>声明制作的镜像是以哪个镜像为基础的</td>
<td><code>FROM &lt;仓库&gt;[:&lt;标签&gt;]</code></td>
<td>每个 Dockerfile 文件必须有一个 FROM 指令，并且该指令必须是第一条指令。如果只声明了仓库名没有声明标签，那么标签默认为 latest</td>
</tr>
<tr>
<td>RUN</td>
<td>用来执行命令行的命令</td>
<td><code>RUN &lt;命令&gt;</code> 或者 <code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></td>
<td></td>
</tr>
<tr>
<td>COPY</td>
<td>选择本地文件复制到 Docker 镜像</td>
<td><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code> 或者 <code>COPY [&quot;&lt;源路径1&gt;&quot;, ..., &quot;&lt;目标路径&gt;&quot;]</code></td>
<td>这里的源路径不是指本地路径，而是 Docker 构建的上下文路径</td>
</tr>
<tr>
<td>ADD</td>
<td>比 COPY 更高级的复制指令</td>
<td>同 COPY</td>
<td>可以使用 RUN 或者 COPY 代替</td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td><code>CMD &lt;命令&gt;</code> 或者 <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, ...]</code></td>
<td>在容器启动时执行的命令，和 RUN 不同，RUN 是在镜像构建过程执行的命令。CMD 命令在容器启动时可以输入新命令替代</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>定义容器的入口点，指定容器启动时执行的命令</td>
<td><code>ENTRYPOINT &lt;命令&gt;</code> 或者 <code>ENTRYPOINT [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code></td>
<td>和 CMD 不同，定义了 ENTRYPOINT 指令后，CMD 指令接受的都是参数，并且都会传递给 ENTRYPOINT 作为参数执行</td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量</td>
<td><code>ENV &lt;key&gt; &lt;value&gt;</code> 或者 <code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></td>
<td>定义好环境变量后，在 ADD, COPY, ENV, EXPOSE, LABEL, USER, WORKDIR, VOLUME, STOPSIGNAL, ONBUILD 指令中都可以展开</td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></td>
<td>和 ENV 效果相同，设置环境变量，但是 ARG 设置的环境变量在容器启动时不存在</td>
</tr>
<tr>
<td>VOLUME</td>
<td>设置卷</td>
<td><code>VOLUME &lt;路径&gt;</code> 或者 <code>VOLUME [&quot;&lt;路径1&gt;, &lt;路径2&gt; ...&quot;]</code></td>
<td></td>
</tr>
<tr>
<td>EXPOSE</td>
<td>声明运行时容器提供服务的端口</td>
<td><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt; ...]</code></td>
<td>EXPOSE 只是声明容器打算使用的端口，并不会绑定宿主端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>指定工作目录，以后各层的当前目录就被改为指定的目录，如果命令不存在，WORKDIR 就会创建</td>
<td><code>WORKDIR &lt;工作目录路径&gt;</code></td>
</tr>
<tr>
<td>USER</td>
<td>指定用户</td>
<td><code>USER &lt;用户名&gt;</code></td>
<td>保证用户名存在</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>告诉 Docker 应该如何进行判断容器的状态是否正常</td>
<td><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code></td>
<td>如果基础镜像有健康检查可以使用 <code>HEALTHCHECK NONE</code> 屏蔽。HEALTHCHECK 是 Docker 1.12 引入的新指令</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当以当前镜像为基础，构建下一层镜像时才会被执行</td>
<td><code>ONBUILD &lt;其他指令&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="导入导出镜像"><a href="#导入导出镜像" class="headerlink" title="导入导出镜像"></a>导入导出镜像</h3><p>Docker 镜像可以本地导出再分享。导出命令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image save -o &lt;<span class="built_in">source</span>&gt; &lt;仓库&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure>
<p>比如导出一个 ubuntu:base 镜像使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image save -o ~/ubuntu_base.tar ubuntu:base</span><br></pre></td></tr></table></figure>
<p>导入一个镜像使用 <code>docker image load</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image load -i ~/ubuntu_base.tar</span><br></pre></td></tr></table></figure>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像是静态的，容器是动态的。容器是基于镜像创建的，每个容器包含两层，底层是基于镜像的基础层，顶层是当前容器的容器存储层，容器运行于自己独立的<code>命名空间</code>，容器存储层的生命周期和容器的一样，当容器消亡时，容器存储层也随之消亡。下次启动的容器又会创建新的空间和容器存储层，因此不应该向容器存储层写入任何数据，存储数据应该使用数据卷或者宿主目录。</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动一个容器使用 <code>docker run</code> 命令，docker run 命令可以带很多参数，有几个常用的参数</p>
<ul>
<li>-i 打开容器的标准输入</li>
<li>-t 让 Docker 分配一个伪终端到容器的标准输入上</li>
<li>-d 保持容器后台运行</li>
<li>-p 指定宿主和容器之间的端口映射</li>
<li>–name 指定容器运行的名称</li>
</ul>
<p>也可以使用 <code>docker container start</code> 命令启动一个已经终止了的容器。</p>
<h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><p>使用 <code>docker container ls</code> 可以查看运行的容器信息，<code>docker container ls -a</code> 可以查看所有容器信息，包括终止的。</p>
<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>终止容器使用 <code>docker container stop</code> 命令。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>如果在启动容器时使用了 <code>-d</code> 参数，那么容器会进入后台，在某些时候需要进入后台容器时，可以使用 <code>docker attach</code> 或者 <code>docker exec</code> 命令。</p>
<p>使用 <code>docker attach</code> 进入容器后退出会导致容器停止，而 <code>docker exec</code> 不会。建议使用 <code>docker exec</code>，停止容器使用 <code>docker container stop</code>。</p>
<p><code>docker exec</code> 需要知道容器的 id，可以通过 <code>docker container ls</code> 命令查看，然后通过 <code>docker exec -i -t &lt;id&gt;</code> 命令进入容器。</p>
<p>更多参数可以通过 <code>docker exec --help</code> 查看</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除容器使用 <code>docker container rm</code> 命令。同样需要知道容器的 id，如果需要删除正在运行的容器，需要加参数 <code>-f</code></p>
<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>容器运行与独立的空间，一个容器消亡时其容器存储层存储的数据也会丢失，对于容器中的数据管理只要有两种方式：数据卷和挂载主机目录</p>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，数据卷可以在容器之间共享和重用，对数据卷的修改会立马生效，对数据卷的更新不影响镜像，数据卷默认一直存在，即使容器被删除。</p>
<p>数据卷是一个特殊的目录，他的特殊之处在于这个目录完全由 Docker 进行管理。</p>
<p>创建一个数据卷</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my_vol</span><br></pre></td></tr></table></figure>
<p>查看数据卷</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my_vol</span><br></pre></td></tr></table></figure>
<p>查看数据卷详细信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my_vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2018-10-31T17:21:01+08:00"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my_vol/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my_vol"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>数据卷的位置不能自定义，数据卷存放在 Docker 目录下的 volumes 文件夹中。Docker 目录下存放了 Docker 镜像，数据卷等，可以通过修改 Docker 目录的方式转移数据卷的位置。</p>
<p>在 <code>/etc/docker/daemon.json</code> 文件夹中写入下面内容</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"graph"</span>: <span class="string">"/home/canxing/.docker/registry"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>graph 对应的路径就是 Docker 目录对应的路径，可以修改为实际路径。修改之后，使用 <code>systemctl restart docker</code> 重启 Docker。</p>
<p>删除数据卷</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my_vol</span><br><span class="line">my_vol</span><br><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br></pre></td></tr></table></figure>
<p>挂载数据卷</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br><span class="line">$ docker run -it --mount <span class="built_in">source</span>=my-vol,target=/opt ubuntu:base</span><br></pre></td></tr></table></figure>
<p>可以在容器的 <code>/opt</code> 目录下添加文件，然后在数据卷本地位置上查看。</p>
<h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><p>Docker 允许挂载一个普通的主机目录到容器，因为这个主机目录不归 Docker 管理，因此主机目录的位置可以随意放置，但是这也会在某些情况导致该目录读取存在权限拒绝的情况。</p>
<p>在用户目录下创建一个目录，然后挂在到容器中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make vol</span><br><span class="line">$ docker run -it --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/root/vol,target=/opt ubuntu:base</span><br></pre></td></tr></table></figure>
<blockquote>
<p>挂在主机目录时，需要使用绝对路径，因此需要将 /root/vol 改为自己主机上的绝对路径</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/10/Java-基本类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/10/Java-基本类型/" class="post-title-link" itemprop="url">Java_基本类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-10 10:22:40" itemprop="dateCreated datePublished" datetime="2018-10-10T10:22:40+08:00">2018-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a href="#基本类型">基本类型</a></li>
<li><a href="#引用类型">引用类型</a></li>
</ul>
<p>在 Java 中，每一个变量属于一种类型。在声明变量时，变量所属的类型位于变量名之前。</p>
<p>Java 的类型包括：基本类型和引用类型。基本类型和引用类型的区别在于，基本类型存储在栈上，而引用类型存储在堆上，并且基本类型没有方法。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>其中基本类型包括 byte, char, short, int, long, float, double, boolean。</p>
<p>基本类型的定义初始化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">3l</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">boolean</span> bool = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>所有基本类型在使用时必须先初始化后才能使用，否则会出现错误。</p>
<p>如果基本类型在类中方法之外定义但是没有初始化，那么类在创建时会对基本类型自动初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicTypeInit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">char</span> c ; </span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">boolean</span> bool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicTypeInit bti = <span class="keyword">new</span> BasicTypeInit();</span><br><span class="line">        System.out.println(bti.b);</span><br><span class="line">        System.out.println(bti.c);</span><br><span class="line">        System.out.println(bti.s);</span><br><span class="line">        System.out.println(bti.i);</span><br><span class="line">        System.out.println(bti.l);</span><br><span class="line">        System.out.println(bti.f);</span><br><span class="line">        System.out.println(bti.d);</span><br><span class="line">        System.out.println(bti.bool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0.0</span><br><span class="line">0.0</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>不同类型的变量初始化的值不同，byte, short, int, long 都会初始化为 0, float 和 double 初始化为 0.0，boolean 初始化为 false， char 初始化为空字符 “”。</p>
<p>不同类型所占用的存储空间不同</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1 字节</td>
</tr>
<tr>
<td>char</td>
<td>2 字节</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
</tr>
<tr>
<td>int</td>
<td>4 字节</td>
</tr>
<tr>
<td>long</td>
<td>8 字节</td>
</tr>
<tr>
<td>float</td>
<td>4 字节</td>
</tr>
<tr>
<td>double</td>
<td>8 字节</td>
</tr>
</tbody>
</table>
<p>Java 是一门面向对象的语言，但是基本类型是一个特例，在 Java SE5 中为基本类型提供了包装功能，将基本类型对应的引用类型称为包装器类型。可以将基本类型转换为对应的包装器类型，也可以在某些时候自动的将包装器类型转换为基本类型。基本类型和其对应的包装器类型对应如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>Void</td>
</tr>
</tbody>
</table>
<p>包装器对象可以进行和基本类型一样的操作，这是因为 Java SE5 的自动装箱和拆包机制，在需要的时候会将一个包装器对象转换为基本类型或者将一个基本类型封装成包装器对象。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicAndWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">1</span>;</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer i3 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">1.2f</span>;</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        System.out.println(i3 == i2);</span><br><span class="line">        System.out.println(i1 + i2);</span><br><span class="line">        System.out.println(f1 + i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">2</span><br><span class="line">2.2</span><br></pre></td></tr></table></figure>
<p>可以看见包装器对象可以和基本类型进行算数运算和比较运算，但是有趣的是，就算创建两个完全相同的包装器对象，对它们使用 == 运算的结果也为 false。这是因为包装器对象和基本类型 == 运算时，会将包装器对象拆包成基本类型，这样比较的时候就相当于比较两个数值之间的比较，而两个类对象之间的 == 运算，比较的是两个类对象的地址，也就是查看两个类对象是否指向同一个区域。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型有五种：类，接口，数组，枚举，注解。</p>
<p>引用类型和基本类型不同，引用类型创建的变量称为引用，引用的值为对象，对象通过类创建。类是构造对象的模板或蓝图。由类构造对象的过程称为创建类的实例。</p>
<p>类可以是 Java 预定义的类，也可以是自定义的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个简单的类，通过该类可以定义了一个引用，指向由该类创建的对象。</p>
<p>创建它们的语法格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure>
<p>通过持有对象的引用，可以访问该对象的方法或者域。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/23/ngxin-customize-module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/23/ngxin-customize-module/" class="post-title-link" itemprop="url">nginx 自定义模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-23 19:30:46" itemprop="dateCreated datePublished" datetime="2018-08-23T19:30:46+08:00">2018-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/nginx/" itemprop="url" rel="index"><span itemprop="name">nginx</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Nginx 有核心模块和第三方模块，我们也可以自定义模块来使用。Nginx 就像一个小型的编程语言，要添加自定义模块就要满足一些 Nginx 的编写要求，就像 C 语言必须有一个 main 函数一样。</p>
<p>这里大部分的内容來自于《Nginx 开发从入门到精通》，只不过整理了一下以满足我自己的思考方式，更详细的内容可以访问 <a href="http://tengine.taobao.org/book/chapter_03.html" target="_blank" rel="noopener">《Nginx 开发从入门到精通》</a>。<code>ngx_http_hello_module.c</code> 为主要模块，<code>config</code> 是添加自定义模块到 Nginx 时使用的。</p>
<p>模块所有代码在<a href="https://github.com/canxing/the-road-to-learning/tree/master/nginx/module" target="_blank" rel="noopener">这里</a></p>
<h2 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h2><p>Nginx 都是以指令的形式进行配置的，所以我们的自定义模块也需要自定义指令来实现功能。自定义指令需要借助于 <code>ngx_command_t</code> 结构体。<code>ngx_command_t</code> 结构体定义在 <code>src/core/ngx_conf_file.h</code> 文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_command_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_str_t</span>             name;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line">    <span class="keyword">char</span>               *(*<span class="built_in">set</span>)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf);</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            conf;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            offset;</span><br><span class="line">    <span class="keyword">void</span>                 *post;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>src/core/ngx_core.h</code> 文件中将使用 <code>ngx_command_t</code> 来表示 <code>struct ngx_command_s</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_command_s</span>         <span class="title">ngx_command_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>这是关于自定义指令的描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span> ngx_http_hello_commands[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_string(<span class="string">"hello_string"</span>),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1,</span><br><span class="line">        ngx_http_hello_string,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(<span class="keyword">ngx_http_hello_loc_conf_t</span>, hello_string),</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_string(<span class="string">"hello_counter"</span>),</span><br><span class="line">        NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,</span><br><span class="line">        ngx_http_hello_counter,</span><br><span class="line">        NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">        offsetof(<span class="keyword">ngx_http_hello_loc_conf_t</span>, hello_counter),</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ngx_null_command</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>name</strong> 表示指令的名称，定义好后在 Nginx 配置文件中就可以直接使用该名称作为指令，比如在配置文件中可以使用 <code>hello_string</code> 来配置。</li>
<li><strong>type</strong> 为指令接受参数的条件。条件由两部分构成：位置和参数个数。 </li>
</ul>
<p>位置由以下参数表示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>    NGX_DIRECT_CONF</td>
<td>可以出现在配置文件中最外层。例如已经提供的配置指令 daemon, master_process 等。</td>
</tr>
<tr>
<td>    NGX_MAIN_CONF</td>
<td>http, mail, events, error_log 等。</td>
</tr>
<tr>
<td>    NGX_ANY_CONF</td>
<td>该配置指令可以出现在任意配置级别上。</td>
</tr>
<tr>
<td>    NGX_HTTP_MAIN_CONF</td>
<td>可以直接出现在 http 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_SRV_CONF</td>
<td>可以出现在 http 里面的 server 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_LOC_CONF</td>
<td>可以出现在 http server 块里面的 location 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_UPS_CONF</td>
<td>可以出现在 http 里面的 upstream 配置指令里。</td>
</tr>
<tr>
<td>    NGX_HTTP_SIF_CONF</td>
<td>可以出现在 http 里面的 server 配置指令里的 if 语句所在的 block 中。</td>
</tr>
<tr>
<td>    NGX_HTTP_LMT_CONF</td>
<td>可以出现在 http 里面的 limit_except 指令的 block 中。</td>
</tr>
<tr>
<td>    NGX_HTTP_LIF_CONF</td>
<td>可以出现在 http server 块里面的 location 配置指令里的 if 语句所在 block 中。</td>
</tr>
</tbody>
</table>
<p>参数个数由以下参数表示</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NGX_CONF_NOARGS</td>
<td>配置指令不接受任何参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE1</td>
<td>配置指令接受 1 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE2</td>
<td>配置指令接受 2 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE3</td>
<td>配置指令接受 3 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE4</td>
<td>配置指令接受 4 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE5</td>
<td>配置指令接受 5 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE6</td>
<td>配置指令接受 6 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_TAKE7</td>
<td>配置指令接受 7 个参数。</td>
</tr>
<tr>
<td>NGX_CONF_MULTI</td>
<td>配置指令接受多个参数，即个数不定。</td>
</tr>
<tr>
<td>NGX_CONF_BLOCK</td>
<td>配置指令可以接受的值是一个配置信息。也就是一对大括号扩起来的内容。里面可以再包括很多个配置指令。比如常见的 server 指令就是这个属性。</td>
</tr>
<tr>
<td>NGX_CONF_FLAG</td>
<td>配置指令可以接受的值是 on 或者 off，最终会被转成 bool 值。</td>
</tr>
<tr>
<td>NGX_CONF_ANY</td>
<td>配置指令可以接受的任意的参数值</td>
</tr>
</tbody>
</table>
<p>上面这些参数可以使用 <code>|</code> 进行组合，比如上面配置中 <code>NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1</code> 就表示定义在 http server 块中的 location 配置指令中，接受 0 个或者 1 个参数。</p>
<ul>
<li><strong><em>set</em></strong> 是一个函数指针，为该指令的处理函数，因为指令如何处理只有定义这个指令的人最清楚。</li>
</ul>
<p>函数处理成功时返回 <code>NGX_OK</code>，否则返回 <code>NGX_CONF_ERROR</code> 或者一个自定义的错误信息的字符串。</p>
<p>函数调用时会传入三个参数：</p>
<ol>
<li>cf: 该参数里面保存从配置文件读取到的原始字符串以及相关的一些信息。特别注意的是这个参数的 args 字段是一个 ngx_str_t 类型的数组，该数组的首个元素是这个配置指令本身，第二个元素是指令的第一个参数，第三个元素是第二个参数，依次类推。</li>
<li>cmd: 这个配置指令对应的 ngx_command_t 结构。</li>
<li>conf: 就是定义的存储这个配置值的结构体。</li>
</ol>
<p>为了方便对配置指令参数的读取，Nginx 默认提供了一些对标准类型的参数进行读取的函数，可以直接复制给 set 字段使用。</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ngx_conf_set_flag_slot</td>
<td>读取 NGX_CONF_FLAG 类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_str_slot</td>
<td>读取字符串类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_str_array_slot</td>
<td>读取字符串数组类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_keyval_slot</td>
<td>读取键值对类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_num_slot</td>
<td>读取整数类型（有符号）的参数</td>
</tr>
<tr>
<td>ngx_conf_set_size_slot</td>
<td>读取 size_t 类型的参数，也就是无符号数。</td>
</tr>
<tr>
<td>ngx_conf_set_off_slot</td>
<td>读取 off_t 类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_msec_slot</td>
<td>读取毫秒值类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_sec_slot</td>
<td>读取秒值类型的参数。</td>
</tr>
<tr>
<td>ngx_conf_set_bufs_slot</td>
<td>读取的参数值是 2 个，一个是 buf 的个数，一个是 buf 的大小。</td>
</tr>
<tr>
<td>ngx_conf_set_enum_slot</td>
<td>读取枚举类型的参数，将其转换成 ngx_uint_t 类型。</td>
</tr>
<tr>
<td>ngx_conf_set_bitmask_slot</td>
<td>读取参数的值，并将这些参数以 bit 位的形式存储。</td>
</tr>
</tbody>
</table>
<p>下面是对 hello_string 进行处理的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">ngx_http_hello_counter</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_http_hello_loc_conf_t</span>* local_conf;</span><br><span class="line">    local_conf = conf;</span><br><span class="line">    <span class="keyword">char</span>* rv = <span class="literal">NULL</span>;</span><br><span class="line">    rv = ngx_conf_set_flag_slot(cf, cmd, conf);</span><br><span class="line">    ngx_conf_log_error(NGX_LOG_EMERG, cf, <span class="number">0</span>, <span class="string">"hello_counter:%d"</span>, local_conf-&gt;hello_counter);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数返回的是指令接收的参数，使用 ntx_http_hello_loc_conf_t 只是为了打印一下输出。</p>
<p>ngx_http_hello_loc_conf_t 的定义如下。在传入 set 函数指针时，conf 指向的就是这个结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_str_t</span> hello_string;</span><br><span class="line">    <span class="keyword">ngx_int_t</span> hello_counter;</span><br><span class="line">&#125;<span class="keyword">ngx_http_hello_loc_conf_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>conf</em></strong> 该字段被NGX_HTTP_MODULE类型模块所用 (我们编写的基本上都是NGX_HTTP_MOUDLE，只有一些nginx核心模块是非NGX_HTTP_MODULE)，该字段指定当前配置项存储的内存位置。实际上是使用哪个内存池的问题。因为http模块对所有http模块所要保存的配置信息，划分了main, server和location三个地方进行存储，每个地方都有一个内存池用来分配存储这些信息的内存。这里可能的值为 NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET或NGX_HTTP_LOC_CONF_OFFSET。当然也可以直接置为0，就是NGX_HTTP_MAIN_CONF_OFFSET。</li>
<li><strong><em>offset</em></strong>: 指定该配置项值的精确存放位置，一般指定为某一个结构体变量的字段偏移。因为对于配置信息的存储，一般我们都是定义个结构体来存储的。那么比如我们定义了一个结构体A，该项配置的值需要存储到该结构体的b字段。那么在这里就可以填写为offsetof(A, b)。</li>
<li>该字段存储一个指针。可以指向任何一个在读取配置过程中需要的数据，以便于进行配置读取的处理。大多数时候，都不需要，所以简单地设为0即可。</li>
</ul>
<p><strong><em>需要注意的是，就是在ngx_http_hello_commands这个数组定义的最后，都要加一个ngx_null_command作为结尾。</em></strong></p>
<h2 id="模块上下文"><a href="#模块上下文" class="headerlink" title="模块上下文"></a>模块上下文</h2><p>模块上下文和 <code>ngx_http_module_t</code> 有关，这个结构体的定义在 <code>src/http/ngx_http_config.h</code> 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_int_t</span>   (*preconfiguration)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>   (*postconfiguration)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>       *(*create_main_conf)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">char</span>       *(*init_main_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *conf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>       *(*create_srv_conf)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">char</span>       *(*merge_srv_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *prev, <span class="keyword">void</span> *conf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>       *(*create_loc_conf)(<span class="keyword">ngx_conf_t</span> *cf);</span><br><span class="line">    <span class="keyword">char</span>       *(*merge_loc_conf)(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">void</span> *prev, <span class="keyword">void</span> *conf);</span><br><span class="line">&#125; <span class="keyword">ngx_http_module_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个变量实际上是提供一组回调函数指针，这些函数有在创建存储配置信息的对象的函数，也有在创建前和创建后会调用的函数。这些函数都将被nginx在合适的时间进行调用。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>preconfiguration</td>
<td>在创建和读取该模块的配置信息之前被调用。</td>
</tr>
<tr>
<td>postconfiguration</td>
<td>在创建和读取该模块的配置信息之后被调用。</td>
</tr>
<tr>
<td>create_main_conf</td>
<td>调用该函数创建本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。</td>
</tr>
<tr>
<td>init_main_conf</td>
<td>调用该函数初始化本模块位于 http block 的配置信息存储结构。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串</td>
</tr>
<tr>
<td>create_srv_conf</td>
<td>调用该函数创建本模块位于 http server block 的配置信息存储结构，每个 server block 会创建一个。该函数成功的时候，返回创建的配置对象。失败的话，返回 NULL。</td>
</tr>
<tr>
<td>merge_srv_conf</td>
<td>因为有些配置指令既可以出现在 http block，也可以出现在 http server block 中。那么遇到这种情况，每个 server都会有自己存储结构来存储该 server 的配置，但是在这种情况下 http block 中的配置与 server block 中的配置信息发生冲突的时候，就需要调用此函数进行合并，该函数并非必须提供，当预计到绝对不会发生需要合并的情况的时候，就无需提供。当然为了安全起见还是建议提供。该函数执行成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。</td>
</tr>
<tr>
<td>create_loc_conf</td>
<td>调用该函数创建本模块位于 location block 的配置信息存储结构。每个在配置中指明的 location 创建一个。该函数执行成功，返回创建的配置对象。失败的话，返回 NULL。</td>
</tr>
<tr>
<td>merge_loc_conf</td>
<td>与 merge_srv_conf 类似，这个也是进行配置值合并的地方。该函数成功的时候，返回 NGX_CONF_OK。失败的话，返回 NGX_CONF_ERROR 或错误字符串。</td>
</tr>
</tbody>
</table>
<p>Nginx 里面的配置信息都是上下一层层的嵌套的，对于具体某个 location 的话，对于同一个配置，如果当前层次没有定义，那么就使用上层的配置，否则使用当前层次的配置。</p>
<p>下面为该自定义模块的上下文定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span> ngx_http_hello_module_ctx = &#123;</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    ngx_http_hello_init,</span><br><span class="line"></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">    ngx_http_hello_create_loc_conf,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述配置说明了在创建和读取该模块的配置信息之后调用初始化函数，并且在 location 块中配配置信息存储结构。</p>
<p>ngx_http_hello_init 函数定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_hello_init(<span class="keyword">ngx_conf_t</span> *cf) </span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_handler_pt *h;</span><br><span class="line">    <span class="keyword">ngx_http_core_main_conf_t</span> *cmcf;</span><br><span class="line"></span><br><span class="line">    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</span><br><span class="line">    </span><br><span class="line">    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *h = ngx_http_hello_handler;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ngx_http_hello_handler 函数定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_hello_handler(<span class="keyword">ngx_http_request_t</span> *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_int_t</span> rc;</span><br><span class="line">    <span class="keyword">ngx_buf_t</span> *b;</span><br><span class="line">    <span class="keyword">ngx_chain_t</span> out;</span><br><span class="line">    <span class="keyword">ngx_http_hello_loc_conf_t</span>* my_conf;</span><br><span class="line">    u_char ngx_hello_string[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span> content_length = <span class="number">0</span>;</span><br><span class="line">    ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"ngx_http_hello_handler is called!"</span>);</span><br><span class="line"></span><br><span class="line">    my_conf = ngx_http_get_module_loc_conf(r, ngx_http_hello_module);</span><br><span class="line">    <span class="keyword">if</span> (my_conf-&gt;hello_string.len == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"hello string is empty!"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_conf-&gt;hello_counter == NGX_CONF_UNSET || my_conf-&gt;hello_counter == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ngx_sprintf(ngx_hello_string, <span class="string">"%s"</span>, my_conf-&gt;hello_string.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ngx_sprintf(ngx_hello_string, <span class="string">"%s Visited Times:%d"</span>, my_conf-&gt;hello_string.data, </span><br><span class="line">                ++ngx_hello_visited_times);</span><br><span class="line">    &#125;</span><br><span class="line">    ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"hello_string:%s"</span>, ngx_hello_string);</span><br><span class="line">    content_length = ngx_strlen(ngx_hello_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_HTTP_NOT_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_discard_request_body(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_str_set(&amp;r-&gt;headers_out.content_type, <span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;method == NGX_HTTP_HEAD) &#123;</span><br><span class="line">        r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">        r-&gt;headers_out.content_length_n = content_length;</span><br><span class="line">        <span class="keyword">return</span> ngx_http_send_header(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_buf_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    out.buf = b;</span><br><span class="line">    out.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    b-&gt;pos = ngx_hello_string;</span><br><span class="line">    b-&gt;last = ngx_hello_string + content_length;</span><br><span class="line">    b-&gt;memory = <span class="number">1</span>;</span><br><span class="line">    b-&gt;last_buf = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">    r-&gt;headers_out.content_length_n = content_length;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_send_header(r);</span><br><span class="line">    <span class="keyword">if</span> (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) &#123;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ngx_http_output_filter(r, &amp;out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块的定义"><a href="#模块的定义" class="headerlink" title="模块的定义"></a>模块的定义</h2><p>上面分别说了指令的配置以及模块的上下文定义，关于模块本身的定义说的不多。</p>
<p>对于开发一个模块来说，我们都需要定义一个 <code>ngx_module_t</code> 类型的变量来说明这个模块本身的信息，从某种意义上来说，这是这个模块最重要的一个信息，它告诉了 Nginx 这个模块的一些信息，上面定义的配置信息，还有模块上下文信息，都是通过这个结构来告诉 Nginx 系统的，也就是加载模块的上层代码，都需要通过定义的这个结构，来获取这些信息。</p>
<p><code>ngx_module_t</code> 的定义在 <code>src/core/ngx_module.h</code> 文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            ctx_index;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>                 *name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare0;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            version;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>           *signature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                 *ctx;</span><br><span class="line">    <span class="keyword">ngx_command_t</span>        *commands;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_module)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                (*exit_master)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook0;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook1;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook2;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook3;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook4;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook5;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook6;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook7;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MODULE_V1                                                         \</span></span><br><span class="line">    NGX_MODULE_UNSET_INDEX, NGX_MODULE_UNSET_INDEX,                           \</span><br><span class="line">    <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, nginx_version, NGX_MODULE_SIGNATURE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MODULE_V1_PADDING  0, 0, 0, 0, 0, 0, 0, 0</span></span><br></pre></td></tr></table></figure>
<p>在 <code>src/core/ngx_core.h</code> 中有如下定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span>          <span class="title">ngx_module_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>Nginx 为了简化配置，将前面 7 个配置使用 <code>NGX_MODULE_V1</code> 宏来表示，后 8 个配置使用 <code>NGX_MODULE_V1_PADDING</code> 宏来表示。因此只需要配置 10 个参数就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ngx_module_t</span> ngx_http_hello_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_hello_module_ctx,   <span class="comment">//该模块的上下文</span></span><br><span class="line">    ngx_http_hello_commands,      <span class="comment">//该模块的指令集合</span></span><br><span class="line">    NGX_HTTP_MODULE,              <span class="comment">//该模块的种类</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//在 master 初始化的函数</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//模块初始化函数</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//初始化工作进程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//初始化线程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//离开线程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//离开工作进程</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//离开 master</span></span><br><span class="line">    NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="模块挂载"><a href="#模块挂载" class="headerlink" title="模块挂载"></a>模块挂载</h2><p>定义好一个模块之后还需要把模块挂载到相应的请求处理阶段上，Nginx 有 11 个请求处理阶段，其中有 4 个阶段不能配置，剩下 7 个可以进行挂载。在 <code>ngx_http_hello_module_ctx</code> 中传入的指针函数 <code>ngx_http_hello_init</code> 就是用来挂载到相应模块上的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_hello_init(<span class="keyword">ngx_conf_t</span> *cf) </span><br><span class="line">&#123;</span><br><span class="line">    ngx_http_handler_pt *h;</span><br><span class="line">    <span class="keyword">ngx_http_core_main_conf_t</span> *cmcf;</span><br><span class="line"></span><br><span class="line">    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</span><br><span class="line">    </span><br><span class="line">    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *h = ngx_http_hello_handler;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ngx_http_conf_get_module_main_conf</code> 根据 conf 结构和模块得到主配置，然后使用 ngx_array_push 在 <code>NGX_HTTP_CONTENT_PHASE</code> 阶段进行挂载。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个模块可以有多个指令，Nginx 使用 <code>ngx_command_t</code> 来描述一个指令，比如指令名称，指令所在位置，指令参数，指令处理函数，指令存储空间以及指令参数在哪个结构体的哪个属性等。</p>
<p>为了将指令的参数在回调函数中可以被明白的解析，需要定义一个结构体来存储传入的参数，这里使用的结构体是 <code>ngx_http_hello_loc_conf_t</code>，其中 hello_string 指令的参数通过 offsetof(ngx_http_hello_loc_conf_t, hello_string) 传入 <code>ngx_http_hello_loc_conf_t</code> 的 hello_string 属性。封装好后 Nginx 会将 ngx_http_hello_loc_conf_t 传入处理回调函数，因为 C 语言的原因，所以传入的指针为 void* 类型的指针，在处理函数中需要进行转换。hello_string 指令的处理函数为 <code>ngx_http_hello_string</code>，hello_counter 指令的处理函数为 <code>ngx_http_hello_counter</code>。</p>
<p>指令在不同阶段可能进行各种初始化工作，Nginx 定义了 <code>ngx_http_module_t</code> 结构体来描述一个指令的上下文环境。可以根据情况来进行上下文的初始化。</p>
<p>最后需要使用 <code>ngx_module_t</code> 结构体来描述该模块本身的信息，模块本身的信息需要传入模块上下文，模块的指令，模块的类型，以及各种钩子函数等。值得注意的是，Nginx 提供了两个宏来减少配置操作，分别时 <code>NGX_MODULE_V1</code> 和 <code>NGX_MODULE_V1_PADDING</code>。</p>
<p>hello 模块在模块上下文定义中，在配置读取和创建结束之后传入了 <code>ngx_http_hello_init</code> 函数，该函数会将模块挂载到 <code>NGX_HTTP_CONTENT_PHASE</code>，并且将 <code>ngx_hettp_hello_handler</code> 函数作为主要的处理函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/VIM-config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/12/VIM-config/" class="post-title-link" itemprop="url">VIM 配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-12 11:34:05" itemprop="dateCreated datePublished" datetime="2018-08-12T11:34:05+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VIM/" itemprop="url" rel="index"><span itemprop="name">VIM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>VIM 配置</p>
<p>这个配置比较简单，只有有限的几个插件，涉及少数几个 VIM 命令，不同于其他 VIM 成熟的配置，如果你需要的是一个成熟的 VIM 配置，那么你应该去别的地方找找，如果你只需要一份简单的配置以便与后续的自定义，这个说不定就是你想要的。</p>
<p>VIM 显示界面</p>
<p><img src="./VIM图形.png" alt="VIM图形"></p>
<p>上述 VIM 样式是终端 VIM，对于 GUI VIM 也有一定的效果，但是不一定完全一样。</p>
<p>VIM 配置包括两部分，一部分是 VIM 插件，一部分 VIM 配置文件。</p>
<p>VIM 插件集中在 bundle 目录下，bundle 应该放在 <code>~/.vim/</code> 目录下，对于 windows 用户需要自行搜索插件存放目录。</p>
<p>VIM 配置文件 <code>.vimrc</code> 应该放在用户的根目录下，用于启动 VIM 时加载。</p>
<p>VIM 配置使用了以下几个插件</p>
<ul>
<li>Vundle 用于管理其他插件的插件</li>
<li>nerdtree 用于在 VIM 中显示目录树的插件 </li>
<li>gruvbox VIM 的主题插件</li>
<li>tabular 和 vim-markdown 是让 VIM 可以支持 Markdonw 的插件</li>
</ul>
<p>插件和配置文件可以在<a href="https://github.com/canxing/the-road-to-learning/tree/master/vim" target="_blank" rel="noopener">这里</a>找到</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/24/mongodb-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/mongodb-note/" class="post-title-link" itemprop="url">mongodb-学习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-24 22:27:28" itemprop="dateCreated datePublished" datetime="2018-07-24T22:27:28+08:00">2018-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mongodb/" itemprop="url" rel="index"><span itemprop="name">mongodb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MongoDB-学习记录"><a href="#MongoDB-学习记录" class="headerlink" title="MongoDB 学习记录"></a>MongoDB 学习记录</h1><ul>
<li><a href="#什么是MongoDB">什么是 MongoDB</a></li>
<li><a href="#MongoDB的组织形式">MongoDB 的组织形式</a></li>
<li><a href="#MongoDB有几种数据结构">MongoDB 有几种数据结构</a></li>
<li><a href="#如何创建数据库">如何创建数据库</a></li>
<li><a href="#那么怎么样才可以创建集合">那么怎么样才可以创建集合</a></li>
<li><a href="#如何删除集合和数据库">如何删除集合和数据库</a></li>
<li><a href="#如何查看帮助文档">如何查看帮助文档</a></li>
<li><a href="#如何插入文档">如何插入文档</a><ul>
<li><a href="#插入一条数据">插入一条数据</a></li>
<li><a href="#插入多条数据">插入多条数据</a></li>
</ul>
</li>
<li><a href="#如何查询插入的数据">如何查询插入的数据</a><ul>
<li><a href="#查询全部数据">查询全部数据</a></li>
<li><a href="#如何仅查询需要的字段">如何仅查询需要的字段</a></li>
<li><a href="#如何根据条件进行查询">如何根据条件进行查询</a></li>
<li><a href="#如何查询stars大于50的数据">如何查询 <code>stars</code> 大于 50 的数据</a></li>
<li><a href="#如何多条件查询">如何多条件查询</a></li>
<li><a href="#如何查询满足其中一个条件的数据">如何查询满足其中一个条件的数据</a></li>
<li><a href="#如何按照stars从大到小从小到大排序">如何按照 <code>stars</code> 从大到小，从小到大排序</a></li>
<li><a href="#如何实现分页">如何实现分页</a></li>
<li><a href="#如何实现分组">如何实现分组</a></li>
</ul>
</li>
<li><a href="#如何删除数据">如何删除数据</a><ul>
<li><a href="#如何删除一条数据">如何删除一条数据</a></li>
<li><a href="#如何删除多条数据">如何删除多条数据</a></li>
</ul>
</li>
<li><a href="#如何更新数据">如何更新数据</a><ul>
<li><a href="#如何更新一条数据">如何更新一条数据</a></li>
<li><a href="#如何更新多条数据">如何更新多条数据</a></li>
<li><a href="#如何更新数据中的文档数据">如何更新数据中的文档数据</a><ul>
<li><a href="#如何删除文档类型数据中的域">如何删除文档类型数据中的域</a></li>
<li><a href="#如何在文档类型数据中插入新的数据">如何在文档类型数据中插入新的数据</a></li>
</ul>
</li>
<li><a href="#如何更新数组中的数据">如何更新数组中的数据</a><ul>
<li><a href="#如何往数组中插入新的数据">如何往数组中插入新的数据</a></li>
<li><a href="#如何删除数组中的数据">如何删除数组中的数据</a></li>
<li><a href="#如何向数组中插入另一个数组的内容">如何向数组中插入另一个数组的内容</a></li>
<li><a href="#如何向数组中插入不重复数据">如何向数组中插入不重复数据</a></li>
<li><a href="#如何删除数组中的多个元素">如何删除数组中的多个元素</a></li>
</ul>
</li>
<li><a href="#如何创建索引">如何创建索引</a><ul>
<li><a href="#创建升序索引">创建升序索引</a></li>
<li><a href="#创建降序索引">创建降序索引</a></li>
</ul>
</li>
<li><a href="#如何查看创建索引">如何查看创建索引</a></li>
<li><a href="#如何删除创建的索引">如何删除创建的索引</a></li>
</ul>
</li>
</ul>
<h2 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h2><p>MongoDB 是一个 NoSQL 数据库，和 MySQL 等关系型数据库不一样 MongoDB 更简单易用。MongoDB 是 NoSQL 的一种。</p>
<h2 id="MongoDB的组织形式"><a href="#MongoDB的组织形式" class="headerlink" title="MongoDB的组织形式"></a>MongoDB的组织形式</h2><p>MongoDB 中可以有多个<code>数据库</code>，每个数据库中可以有多个<code>集合</code>，每个集合有多个<code>文档</code>（文档就相当于 MySQL 中的表，但是表中的数据都有相同的域，文档中的每一条数据不一定有相同的域），每个文档都有<code>域</code>，这些域可能存在也可能不存在，在实际使用中每个文档应该有相同的域。</p>
<p>MongoDB 的组织形式图解:  </p>
<p><img src="./MongoDB结构.png" alt="MongoDB结构"></p>
<p>MongoDB 和 MySQL 的对对比：  </p>
<p><img src="./MongoDB和MySQL的对比.png" alt="MongoDB和MySQL的对比"></p>
<h2 id="MongoDB有几种数据结构"><a href="#MongoDB有几种数据结构" class="headerlink" title="MongoDB有几种数据结构"></a>MongoDB有几种数据结构</h2><p>MongoDB 中以下几种数据结构：</p>
<ul>
<li>数字</li>
<li>字符串</li>
<li>布尔</li>
<li>日期</li>
<li>数组</li>
<li>文档（JavaScript 中的对象）</li>
</ul>
<h2 id="如何创建数据库"><a href="#如何创建数据库" class="headerlink" title="如何创建数据库"></a>如何创建数据库</h2><p>MongoDB 中的数据库不用手动创建，只需要使用 <code>use &lt;collection&gt;</code> 就可以选择数据库，如何没有这个数据库，在创建一个集合的同时也会创建数据库</p>
<h2 id="那么怎么样才可以创建集合"><a href="#那么怎么样才可以创建集合" class="headerlink" title="那么怎么样才可以创建集合"></a>那么怎么样才可以创建集合</h2><p>使用以下命令就可以创建一个集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(<span class="string">"collectionName"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="如何删除集合和数据库"><a href="#如何删除集合和数据库" class="headerlink" title="如何删除集合和数据库"></a>如何删除集合和数据库</h2><p>使用以下命令可以删除一个集合，其中 <code>&lt;collection&gt;</code> 表示选中的集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;collection&gt;.drop()</span><br></pre></td></tr></table></figure>
<p>删除数据库可以使用以下命令删除，注意，这个 db 是由 <code>use &lt;database&gt;</code> 选中的数据库</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>
<h2 id="如何查看帮助文档"><a href="#如何查看帮助文档" class="headerlink" title="如何查看帮助文档"></a>如何查看帮助文档</h2><p>在 Mongo shell 中直接使用 <code>help</code> 命令可以查看在线帮助文档</p>
<p>使用 <code>db.help()</code> 可以查看数据库相关的帮助文档</p>
<p>使用 <code>db.&lt;collectionname&gt;.help()</code> 可以查看数据库集合的相关帮助文档</p>
<h2 id="如何插入文档"><a href="#如何插入文档" class="headerlink" title="如何插入文档"></a>如何插入文档</h2><p>查看 <code>db.&lt;collectionname&gt;.help()</code> 可以看见 MongoDB 定义了三种方式来插入文档，有 <code>insert</code>,<code>insertOne</code>,<code>insertMany</code>，其中 <code>insert</code> 用处最多，具备有 <code>insertOne</code> 和 <code>insertMany</code> 的功能。</p>
<p><code>insertOne</code> 用于向数据库中插入单条数据的情况，<code>insertMany</code> 用于一条命令向数据库中插入多条数据。</p>
<h3 id="插入一条数据"><a href="#插入一条数据" class="headerlink" title="插入一条数据"></a>插入一条数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.blog.insert(&#123;</span><br><span class="line">    title: <span class="string">'mongodb 的使用'</span>,</span><br><span class="line">    author: <span class="string">'canxing'</span>,</span><br><span class="line">    publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">31</span>),</span><br><span class="line">    content : <span class="string">'mongodb 插入语句的实现'</span>,</span><br><span class="line">    stars : <span class="number">10</span>,</span><br><span class="line">    comment : []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.blog.insert([</span><br><span class="line">&#123;</span><br><span class="line">    title: <span class="string">'mongodb 插入多条数据的使用'</span>,</span><br><span class="line">    author: <span class="string">'canxing'</span>,</span><br><span class="line">    publishDate : <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">33</span>),</span><br><span class="line">    content : <span class="string">"mongodb 插入多条数据的实现"</span>,</span><br><span class="line">    stars: <span class="number">12</span>,</span><br><span class="line">    comment : []</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    title: <span class="string">'mongodb 插入多条数据的使用2'</span>,</span><br><span class="line">    author:<span class="string">'canxing'</span>,</span><br><span class="line">    publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">34</span>),</span><br><span class="line">    content: <span class="string">"mongodb 插入多条数据的实现2"</span>,</span><br><span class="line">    stars: <span class="number">2</span>,</span><br><span class="line">    comment : []</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="如何查询插入的数据"><a href="#如何查询插入的数据" class="headerlink" title="如何查询插入的数据"></a>如何查询插入的数据</h2><p>首先保证数据库中已经插入了下面这些数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">db.blog.insert([</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">'mongodb 数据库的创建'</span>,</span><br><span class="line">        author: &#123;</span><br><span class="line">            firstName: <span class="string">'liu'</span>,</span><br><span class="line">            lastName: <span class="string">'xin'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">12</span>),</span><br><span class="line">        content: <span class="string">'mongodb 数据库的创建'</span>,</span><br><span class="line">        stars: <span class="number">30</span>,</span><br><span class="line">        comment:[</span><br><span class="line">            <span class="string">'aaaa'</span>,</span><br><span class="line">            <span class="string">'bbbb'</span>,</span><br><span class="line">            <span class="string">'cccc'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"走两步"</span>,</span><br><span class="line">        author: &#123;</span><br><span class="line">            firstName: <span class="string">"tom"</span>,</span><br><span class="line">            lastName: <span class="string">"jerry"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">8</span>, <span class="number">23</span>),</span><br><span class="line">        content: <span class="string">"随便走两步"</span>,</span><br><span class="line">        stars: <span class="number">32</span>,</span><br><span class="line">        comment: [</span><br><span class="line">            <span class="string">'dddd'</span>,</span><br><span class="line">            <span class="string">'eeee'</span>,</span><br><span class="line">            <span class="string">'ffff'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"葫芦娃救爷爷"</span>,</span><br><span class="line">        author: &#123;</span><br><span class="line">            firstName: <span class="string">"忘了"</span>,</span><br><span class="line">            lastName: <span class="string">"忘了"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        publishDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">10</span>, <span class="number">23</span>),</span><br><span class="line">        content: <span class="string">"7个葫芦娃轮流救爷爷，结果都被抓了"</span>,</span><br><span class="line">        stars: <span class="number">11000</span>,</span><br><span class="line">        comment: [</span><br><span class="line">            <span class="string">'gggggggggg'</span>,</span><br><span class="line">            <span class="string">'hhhhhhhhhhh'</span>,</span><br><span class="line">            <span class="string">'iiiiiiiiiii'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="查询全部数据"><a href="#查询全部数据" class="headerlink" title="查询全部数据"></a>查询全部数据</h3><blockquote>
<p>要想查询的结果可读性更强，可以试试 pretty 方法 db.blog.find().pretty()</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find()</span><br></pre></td></tr></table></figure>
<h3 id="如何仅查询需要的字段"><a href="#如何仅查询需要的字段" class="headerlink" title="如何仅查询需要的字段"></a>如何仅查询需要的字段</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find(&#123;&#125;, &#123;<span class="attr">title</span>:<span class="number">1</span>, <span class="attr">author</span>:<span class="number">1</span>, <span class="attr">publishDate</span>:<span class="number">1</span>, <span class="attr">_id</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>查询的第一个参数是筛选条件，<code>{}</code> 表示不过滤直接查询，也就是查询所有的数据，第二个参数设置需要显示的域，要显示的设置为 1, 不显示的设置为 0, <code>_id</code> 域默认显示，不想显示需要手动指定。</p>
<h3 id="如何根据条件进行查询"><a href="#如何根据条件进行查询" class="headerlink" title="如何根据条件进行查询"></a>如何根据条件进行查询</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;)  <span class="comment">//根据博客名称进行查询</span></span><br><span class="line">db.blog.find(&#123;<span class="attr">author</span>: &#123;<span class="attr">firstName</span>: <span class="string">"liu"</span>, <span class="attr">lastName</span>: <span class="string">"xin"</span>&#125;&#125;)  <span class="comment">//根据作者进行查询</span></span><br><span class="line">db.blog.find(&#123;<span class="attr">comment</span>: <span class="string">'dddd'</span>&#125;)  <span class="comment">//根据评论进行查询</span></span><br></pre></td></tr></table></figure>
<p>上面展示了三种根据条件进行查询的方式，这种方式类似于 MySQL 中的 where 字句但是也有不同。</p>
<p>第一条查询语句使用 <code>{title: &quot;mongodb 数据库的创建&quot;}</code> 来筛选，返回所有数据中满足 <code>title</code> 域对应的值等于 <code>mongodb 数据库的创建</code> 的语句。</p>
<p>第二条查询语句使用 <code>{author: {firstName: &quot;liu&quot;, lastName: &quot;xin&quot;}}</code> 来筛选，注意，这个 <code>author</code> 是一个文档类型，查询的时候需要该文档类型中的所有域都相等。</p>
<p>第三条查询语句使用 <code>{comment: &#39;dddd&#39;}</code> 来筛选，<code>comment</code> 是一个数组类型，查询时可以使用这种方式，表示查询的数组中含有 <code>dddd</code> 元素的数据，也可以使用 <code>db.blog.find({comment: [&quot;aaaa&quot;, &quot;bbbb&quot;, &quot;cccc&quot;]})</code> 来查询，使用后一种方式时要使用匹配该数组中的所有元素才行。</p>
<h3 id="如何查询stars大于-50-的数据"><a href="#如何查询stars大于-50-的数据" class="headerlink" title="如何查询stars大于 50 的数据"></a>如何查询stars大于 50 的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">stars</span>: &#123;<span class="attr">$gt</span>: <span class="number">50</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>在 MongoDB 中 <code>&gt;</code>,<code>&lt;</code>, 都不能使用，要使用特殊符号来表示这些。符号如下:</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>大于</td>
<td>$gt</td>
</tr>
<tr>
<td>小于</td>
<td>$lt</td>
</tr>
<tr>
<td>不等于</td>
<td>$ne</td>
</tr>
<tr>
<td>大于等于</td>
<td>$gte</td>
</tr>
<tr>
<td>小于等于</td>
<td>$lte</td>
</tr>
</tbody>
</table>
<p>用法和示例类似</p>
<h3 id="如何多条件查询"><a href="#如何多条件查询" class="headerlink" title="如何多条件查询"></a>如何多条件查询</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">stars</span>: <span class="number">32</span>, <span class="attr">title</span>: <span class="string">"走两步"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>要查询同时满足多个条件的数据，只需要如示例添加条件就行了。</p>
<h3 id="如何查询满足其中一个条件的数据"><a href="#如何查询满足其中一个条件的数据" class="headerlink" title="如何查询满足其中一个条件的数据"></a>如何查询满足其中一个条件的数据</h3><p>如果要求返回匹配多个条件中的一个条件的数据，需要使用关键字 <code>$or</code>，相当于 or 语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find(&#123;<span class="attr">$or</span>: [&#123;<span class="attr">stars</span>: <span class="number">32</span>&#125;, &#123;<span class="attr">stars</span>: <span class="number">30</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="如何按照stars从大到小从小到大排序"><a href="#如何按照stars从大到小从小到大排序" class="headerlink" title="如何按照stars从大到小从小到大排序"></a>如何按照stars从大到小从小到大排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find(&#123;&#125;).sort(&#123;<span class="attr">stars</span>:<span class="number">1</span>&#125;)  <span class="comment">//升序</span></span><br><span class="line">db.blog.find(&#123;&#125;).sort(&#123;<span class="attr">stars</span>:<span class="number">-1</span>&#125;) <span class="comment">//降序</span></span><br></pre></td></tr></table></figure>
<h3 id="如何实现分页"><a href="#如何实现分页" class="headerlink" title="如何实现分页"></a>如何实现分页</h3><p>MongoDB 中也有 limit 方法，但是这个 limit 和 MySQL 中的 limit 不同，这个 limit 只会返回指定条数的数据，不能指定从什么位置开始读取。要实现和 MySQL 中的 limit 相同的功能，需要同时使用 skip 和 limit。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.find(&#123;&#125;).skip(<span class="number">1</span>).limit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>skip 表示跳过多条数据，limit 表示只读取多条数据，这里跳过第一条，只读取一条，那么就会读取所有数据的第二条。</p>
<h3 id="如何实现分组"><a href="#如何实现分组" class="headerlink" title="如何实现分组"></a>如何实现分组</h3><p>在 MySQL 中，分组首先要有一个字段，按照这个字段的不同分成不同的组。MongoDB 中也是一样，需要某一个域作为参数，返回这个参数的不同的值。</p>
<p>分组要 <code>aggregate</code> 方法和 <code>$group</code> 操作符，在 <code>$group</code> 操作符中，使用 <code>_id</code> 来说明分组的 key 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.aggregate([&#123;<span class="attr">$group</span>: &#123;<span class="attr">_id</span>:<span class="string">'$stars'</span>&#125;&#125;]) <span class="comment">//按照 stars 字段进行分组</span></span><br></pre></td></tr></table></figure>
<h2 id="如何删除数据"><a href="#如何删除数据" class="headerlink" title="如何删除数据"></a>如何删除数据</h2><p>删除数据可以使用 <code>remove</code>,<code>deleteOne</code> 和 <code>deleteMany</code> 中的某一个。</p>
<h3 id="如何删除一条数据"><a href="#如何删除一条数据" class="headerlink" title="如何删除一条数据"></a>如何删除一条数据</h3><p>如果只想删除一条数据，使用 <code>deleteOne</code>，它会删除满足条件的第一条语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.deleteOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="如何删除多条数据"><a href="#如何删除多条数据" class="headerlink" title="如何删除多条数据"></a>如何删除多条数据</h3><p>删除多条数据使用 <code>deleteMany</code> 是很不错的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.deleteMany(&#123;<span class="attr">stars</span>: &#123;<span class="attr">$gt</span>: <span class="number">30</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>删除单条数据使用 <code>deleteOne</code>，删除多条数据使用 <code>deleteMany</code>，至于 <code>remove</code> 一般情况下不需要使用，毕竟 <code>deleteMany</code> 既可以删除一条也可以删除多条。</p>
<h2 id="如何更新数据"><a href="#如何更新数据" class="headerlink" title="如何更新数据"></a>如何更新数据</h2><p>更新数据使用 <code>update</code>,<code>updateOne</code> 和 <code>updateMany</code>。</p>
<h3 id="如何更新一条数据"><a href="#如何更新一条数据" class="headerlink" title="如何更新一条数据"></a>如何更新一条数据</h3><p>更新一条数据使用 <code>updateOne</code> 方法，<code>updateOne</code> 方法会更新第一个匹配的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="attr">stars</span>: <span class="number">50</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>updateOne</code> 接收两个参数，第一个参数是要修改数据的查询条件，和查询时使用的条件一样，第二个参数表示要更新的数据。<em> 注意 </em>：如果没有使用 <code>$set</code> 那么这条数据就只有一个域那就是 <code>{stars:50}</code>，使用 <code>$set</code> 之后才会修改指定的域，不然就是覆盖整条数据。</p>
<h3 id="如何更新多条数据"><a href="#如何更新多条数据" class="headerlink" title="如何更新多条数据"></a>如何更新多条数据</h3><p>更新多条数据使用 <code>updateMany</code>，使用 <code>update</code> 也可以，可是使用 <code>update</code> 需要额外添加 <code>{multi: true}</code>，有些时候会忘记添加，忘记添加就相当于使用 <code>updateOne</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateMany(&#123;<span class="attr">$or</span>: [&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">title</span>: <span class="string">"走两步"</span>&#125;]&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="attr">stars</span>: <span class="number">1000</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="如何更新数据中的文档数据"><a href="#如何更新数据中的文档数据" class="headerlink" title="如何更新数据中的文档数据"></a>如何更新数据中的文档数据</h3><p>在我们插入的数据中有 <code>author</code> 域，该域是一个文档类型，和普通数据类型不同，如何修改，删除，添加里面的数据</p>
<h4 id="如何删除文档类型数据中的域"><a href="#如何删除文档类型数据中的域" class="headerlink" title="如何删除文档类型数据中的域"></a>如何删除文档类型数据中的域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$unset</span>: &#123;<span class="string">'author.lastName'</span>: <span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>这里使用了 <code>$unset</code>，这个操作会删除一个域，<code>&#39;author.lastName&#39;</code> 表示 <code>author</code> 文档的 <code>lastName</code> 属性，1 表示删除。<code>$unset</code> 不仅可以删除一个文档中的域，也可以删除一个域。</p>
<h4 id="如何在文档类型数据中插入新的数据"><a href="#如何在文档类型数据中插入新的数据" class="headerlink" title="如何在文档类型数据中插入新的数据"></a>如何在文档类型数据中插入新的数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$set</span>: &#123;<span class="string">'author.lastName'</span>: <span class="string">'xin'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>上述操作不仅可以插入新的数据，也可以用来更新数据</p>
<h3 id="如何更新数组中的数据"><a href="#如何更新数组中的数据" class="headerlink" title="如何更新数组中的数据"></a>如何更新数组中的数据</h3><p>和数组有关的操作符看<a href="https://docs.mongodb.com/manual/reference/operator/update-array/" target="_blank" rel="noopener">这里</a></p>
<h4 id="如何往数组中插入新的数据"><a href="#如何往数组中插入新的数据" class="headerlink" title="如何往数组中插入新的数据"></a>如何往数组中插入新的数据</h4><p>往数组中插入新的数据使用 <code>$push</code> 操作符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$push</span>: &#123;<span class="attr">comment</span>: <span class="string">'zzzzzzzzzz'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="如何删除数组中的数据"><a href="#如何删除数组中的数据" class="headerlink" title="如何删除数组中的数据"></a>如何删除数组中的数据</h4><p>删除数组中的数据使用 <code>$pop</code> 操作符和 <code>$pull</code> 操作符。<code>$pop</code> 操作符用于删除并返回数组中的第一个或最后一个元素。<code>$pull</code> 操作符用于精确删除数组中匹配的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$pop</span>:&#123;<span class="attr">comment</span>:<span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>其中 <code>{comment: 1}</code> 中的 1 表示弹出并删除最后一个元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>:<span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$pull</span>: &#123;<span class="attr">comment</span>: <span class="string">'bbbb'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="如何向数组中插入另一个数组的内容"><a href="#如何向数组中插入另一个数组的内容" class="headerlink" title="如何向数组中插入另一个数组的内容"></a>如何向数组中插入另一个数组的内容</h4><p>如果直接使用 <code>$push</code> 向数组中插入一个数组的话，都将数组作为一个元素插入，而不是将数组中的所有元素依次插入。</p>
<p>为了将一个数组中的所有元素都插入到数组中，需要使用 <code>$each</code> 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">title</span>:<span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$push</span>: &#123;<span class="attr">comment</span>: &#123;<span class="attr">$each</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="如何向数组中插入不重复数据"><a href="#如何向数组中插入不重复数据" class="headerlink" title="如何向数组中插入不重复数据"></a>如何向数组中插入不重复数据</h4><p>mongodb 没有提供编程语言中集合类型相似的数据结构，只有数组，为了不插入重复数据，可以使用 <code>$addToSet</code> 关键字，或者在输出的时候去重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.log.updateOne(&#123;title: &quot;mongodb 数据库的创建&quot;&#125;, &#123;$addToPush: &#123;comment: &#123;$each: [7, 7, 7, 7]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="如何删除数组中的多个元素"><a href="#如何删除数组中的多个元素" class="headerlink" title="如何删除数组中的多个元素"></a>如何删除数组中的多个元素</h4><p>只使用 <code>$pusll</code> 关键字无法删除数组中的多个元素，只能删除一个元素，要删除多个使用 <code>$in</code> 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.updateOne(&#123;<span class="attr">titile</span>: <span class="string">"mongodb 数据库的创建"</span>&#125;, &#123;<span class="attr">$pull</span> : &#123;<span class="attr">comment</span>: &#123;<span class="attr">$in</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><p>使用文档中某个域创建索引，使用该域进行查询时可以加快查询速度</p>
<h3 id="创建升序索引"><a href="#创建升序索引" class="headerlink" title="创建升序索引"></a>创建升序索引</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.createIndex(&#123;<span class="attr">title</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="创建降序索引"><a href="#创建降序索引" class="headerlink" title="创建降序索引"></a>创建降序索引</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.createIndex(&#123;<span class="attr">title</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="如何查看创建索引"><a href="#如何查看创建索引" class="headerlink" title="如何查看创建索引"></a>如何查看创建索引</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.getIndexes()</span><br></pre></td></tr></table></figure>
<h2 id="如何删除创建的索引"><a href="#如何删除创建的索引" class="headerlink" title="如何删除创建的索引"></a>如何删除创建的索引</h2><p>删除对应索引，删除索引时的名称不是创建索引时的名称，而是使用 <code>getIndexes</code> 查看的 <code>name</code> 属性的名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.blog.dropIndex(<span class="string">'title_1'</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/30/python-reptile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/30/python-reptile/" class="post-title-link" itemprop="url">python-简单爬虫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-30 16:27:59" itemprop="dateCreated datePublished" datetime="2018-06-30T16:27:59+08:00">2018-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python3/" itemprop="url" rel="index"><span itemprop="name">python3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="python-简单爬虫"><a href="#python-简单爬虫" class="headerlink" title="python 简单爬虫"></a>python 简单爬虫</h1><blockquote>
<p>这不是一篇完整的爬虫教程，这是一篇使用python完成简单爬虫的使用过程记录。<br>使用 python3 以及第三方库 requests 和 lxml 以及 xpath 技术来爬取一些网页数据<br>这里只是用了 GET 请求，没有使用 POST 请求</p>
</blockquote>
<h2 id="第三方库和技术介绍"><a href="#第三方库和技术介绍" class="headerlink" title="第三方库和技术介绍"></a>第三方库和技术介绍</h2><p>requests: 这里使用 requests 来请求一个网页，并将响应结果封装在一个对象中返回</p>
<p>lxml: 使用 lxml 中的 etree 库对响应的 HTML 页面进行解析</p>
<p>xpath: 一种解析 xml 文档的技术，也可以解析 HTML 页面。在w3c可以找到文档</p>
<h2 id="过程介绍"><a href="#过程介绍" class="headerlink" title="过程介绍"></a>过程介绍</h2><ol>
<li>使用 <code>requests.get</code> 函数请求对应的<code>URL</code></li>
<li>如果请求正常并有返回，将返回结果通过<code>etree.HTML</code>处理</li>
<li>使用<code>xpath</code>技术对<code>etree.HTML</code>处理过的对象进行解析，获取对应的数据</li>
<li>数据存储</li>
</ol>
<h2 id="请求页面"><a href="#请求页面" class="headerlink" title="请求页面"></a>请求页面</h2><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>使用<code>requests.get(url)</code>方式可以请求对应的<code>url</code>内容，并将响应结果封装在一个对象中返回，但是直接使用这种方式的请求头中包含这个<code>&quot;User-Agent&quot;:&quot;python-requests/2.19.1&quot;</code><br>有些服务器会通过这个请求头得知这是一个python爬虫请求从而拒绝响应。为了正常访问，需要传入一个请求头来覆盖这个属性，从而骗过请求服务器。</p>
<p>在<code>firefox</code>浏览器中通过请求<code>http://httpbin.org/get</code>可以获得本机的请求头，下面是我请求的该链接的部分内容</p>
<p><img src="httpbing-request.png" alt="本机请求httpbin.org"></p>
<p>将请求中的<code>User-Agent</code>对应的属性作为键值对形式传入<code>requests.get()</code>的<code>headers</code>参数，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;<span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"</span>&#125;</span><br><span class="line">response = requests.get(url, headers=header)</span><br></pre></td></tr></table></figure>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>如果你想要传入查询参数，只需要以键值对的形式传入<code>requests.get</code>中的<code>params</code>，下面的查询键为’user’，对应的值为’tom’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">"user"</span>:<span class="string">"tom"</span>&#125;</span><br><span class="line">response = requests.get(url, params=data)</span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line">如果你有多个查询值也可以添加多个键值对</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">data = &#123;<span class="string">"user"</span>:<span class="string">"tom"</span>,<span class="string">"pwd"</span>:<span class="string">"jerry"</span>&#125;</span><br><span class="line">response = requests.get(url, params=data)</span><br></pre></td></tr></table></figure>
<h3 id="请求超时设置"><a href="#请求超时设置" class="headerlink" title="请求超时设置"></a>请求超时设置</h3><p>对<code>requests.get</code>函数的<code>timeout</code>参数传入一个数字可以设置请求的最长时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(url, timeout=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><p>使用<code>response = requests.get()</code>之后就获取了响应结果，这时可以对响应做一些处理</p>
<h3 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h3><p><code>response.status_code</code>返回请求的响应码，正常情况下返回<code>200</code></p>
<h3 id="字符设置"><a href="#字符设置" class="headerlink" title="字符设置"></a>字符设置</h3><p>响应返回的结果不一定可以正常显示，对<code>response.encoding</code>属性进行赋值可以修改返回的字符集，一般设置为<code>utf-8</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.encoding = <span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p><code>response.text</code>将数据以文本形式返回，文本形式的字符集和字符设置有关，如果没有设置则返回响应数据设置的字符集</p>
<p><code>response.content</code>将数据以字节形式返回，使用这种方式返回就不用担心返回的数据出现乱码问题</p>
<h2 id="一个完整的请求实例"><a href="#一个完整的请求实例" class="headerlink" title="一个完整的请求实例"></a>一个完整的请求实例</h2><p>请求一个<code>url</code>并将响应结果以文本的形式返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">user_agent = <span class="string">"User-Agent"</span></span><br><span class="line">my_user_agent = <span class="string">"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"</span></span><br><span class="line">header = &#123;user_agent: my_user_agent&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(url, data=None)</span> :</span></span><br><span class="line">    <span class="string">'''根据url请求一个html页面并返回'''</span></span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        r = requests.get(url, headers=header, params=data)</span><br><span class="line">        r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> r.text</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"返回页面信息失败"</span>)</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"请求链接失败"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="xpath处理"><a href="#xpath处理" class="headerlink" title="xpath处理"></a>xpath处理</h2><p>使用<code>lxml</code>中的<code>etree</code>库中的<code>HTML</code>函数可以将一个<code>HTML</code>页面转换为一个对象，对该对象使用<code>xpath</code>语法即可获取对应的数据。有关更多的<code>xpath</code>技术点击<a href="http://www.w3school.com.cn/xpath/" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.HTML(html)</span><br><span class="line">html.xpath(xpath)</span><br></pre></td></tr></table></figure>
<p>对于使用<code>xpath</code>语法来获取数据，在<code>firefox</code>浏览器中使用<a href="https://addons.mozilla.org/zh-CN/firefox/addon/try-xpath/?src=search" target="_blank" rel="noopener">这个</a>插件，可以在线使用<code>xpath</code>语法来匹配</p>
<p>注意:使用<code>xpath</code>语法返回的数据都是以列表形式返回</p>
<p><a href="https://github.com/canxing/code-repository/blob/master/python/reptile/tencent_job_reptile.py" target="_blank" rel="noopener">一个完整的可以爬取腾讯社招技术类的所有招聘信息的爬虫程序</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/IntelljJ-IDEA-Community-Edition-maven-webapp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/17/IntelljJ-IDEA-Community-Edition-maven-webapp/" class="post-title-link" itemprop="url">IDEA社区版使用maven搭建web开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-17 19:41:02" itemprop="dateCreated datePublished" datetime="2018-04-17T19:41:02+08:00">2018-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ide/" itemprop="url" rel="index"><span itemprop="name">ide</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>IDEA社区版是不支持web应用程序开发，但是IDEA支持Maven，在Maven配置文件中可以添加tomcat插件，因此可以使用IDEA进行web应用程序开发</p>
<h1 id="一-新建Maven项目"><a href="#一-新建Maven项目" class="headerlink" title="一 新建Maven项目"></a>一 新建Maven项目</h1><p>在选择新项目时选择maven项目，勾选 Create from archetype，在下方选择maven-archetype-webapp，点击Next<br><img src="idea-maven.png" alt="idea-创建maven类型项目"></p>
<p>输入GroupId和ArtifactId<br><img src="输入名称.png" alt="GroupId和ArtifactId"></p>
<p>选择Maven位置，如果Maven已经添加到环境变量，那么可以自动找到，如果没有配置，那么需要手动添加<br>User setting file为你的Maven配置文件，如果不是默认路径需要手动添加<br>Local repository为你的Maven仓库，如果不是默认路径需要手动添加<br><img src="maven-position.png" alt="Maven工程配置"></p>
<p>最后输入工程名称和工程位置<br><img src="最后.png" alt="工程名称和位置"></p>
<p>首次使用Maven会下载一些东西需要一些时间</p>
<h1 id="二-配置tomcat"><a href="#二-配置tomcat" class="headerlink" title="二 配置tomcat"></a>二 配置tomcat</h1><ol>
<li>首先在tomcat中添加tomcat插件  </li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hostName</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">hostName</span>&gt;</span>    <span class="comment">&lt;!-- Default: localhost --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span>    <span class="comment">&lt;!-- 启动端口 Default:8080 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span>      <span class="comment">&lt;!-- uri编码 Default: ISO-8859-1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用的tomcat7</p>
<ol start="2">
<li>配置tomcat7</li>
</ol>
<p>单击菜单栏 Run，选择Edit Configurations…，进入如下界面  </p>
<p><img src="tomcat7配置.png" alt="tomcat7配置">  </p>
<p>默认只有一个Defaults，Maven是我配置好了的</p>
<p>选择+-&gt;Maven</p>
<p><img src="选择Mave.png" alt="选择Maven">  </p>
<p>输入Tomcat7，在Command line输入tomcat7:run完成配置</p>
<p><img src="tomcat7配置运行.png" alt></p>
<ol start="3">
<li>点击Run开始运行，打开浏览器查看结果如下</li>
</ol>
<p><img src="运行结果.png" alt="运行结果"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/数据结构c语言描述九-插入排序和希尔排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残星">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/23/数据结构c语言描述九-插入排序和希尔排序/" class="post-title-link" itemprop="url">数据结构c语言描述九-插入排序和希尔排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-23 19:58:01" itemprop="dateCreated datePublished" datetime="2018-03-23T19:58:01+08:00">2018-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-13 11:51:23" itemprop="dateModified" datetime="2022-06-13T11:51:23+08:00">2022-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data-structure/" itemprop="url" rel="index"><span itemprop="name">data_structure</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序基于这样一种情况，待插入的数组是顺序的(升序或降序)，此时将插入数据从数组从后向前比较，满足条件就插入，不满足就依次向后移动</p>
<p>插入排序就好象玩扑克时一张一张的拿牌，大的在左边，小的在右边，每拿一张牌就从右到左一次比较，在第一张大于的牌的右边插入新的扑克</p>
<h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(ElementType* <span class="built_in">array</span>,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayMaxIndex = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> arrayMinIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(index = arrayMinIndex + <span class="number">1</span>;index &lt;= arrayMaxIndex;index++)&#123;</span><br><span class="line">		<span class="keyword">int</span> insertValue = <span class="built_in">array</span>[index];</span><br><span class="line">		<span class="keyword">for</span>(j = index - <span class="number">1</span>;j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; insertValue;j--)&#123;</span><br><span class="line">			<span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">array</span>[j + <span class="number">1</span>] = insertValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序通过比较相距一定间隔的元素来工作，将比较的元素按照大小排列到比较元素的位置，然后通过减小间隔再次比较，最后间隔为1时所有比较完成</p>
<p><img src="希尔排序.png" alt="希尔排序"></p>
<p>最上面数据为未排序数据，由上往下增量依次为 5,3,1</p>
<h3 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(ElementType* <span class="built_in">array</span>,<span class="keyword">int</span> increment,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arrayMinIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arrayMaxIndex = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sortTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> insertValue = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//当一趟的增量大于排序数组长度时进行的处理</span></span><br><span class="line">	<span class="keyword">if</span>(increment &gt; len)&#123;</span><br><span class="line">		shellSort(<span class="built_in">array</span>,<span class="number">1</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;sortTime &lt; increment;sortTime++)&#123;</span><br><span class="line">		<span class="comment">//插入排序的变形</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = sortTime + increment;i &lt; len;i += increment)&#123;</span><br><span class="line">			insertValue = <span class="built_in">array</span>[i];</span><br><span class="line">			<span class="keyword">for</span>(j = i - increment;j &gt;= arrayMinIndex &amp;&amp; <span class="built_in">array</span>[j] &gt;= insertValue;j -= increment)&#123;</span><br><span class="line">				<span class="built_in">array</span>[j + increment] = <span class="built_in">array</span>[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">array</span>[j + increment] = insertValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/canxing/code-repository/blob/master/c/data_structure_and_algorithm_analysis" target="_blank" rel="noopener">参考源码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/archives/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/archives/page/4/">4</a><a class="extend next" rel="next" href="/archives/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">残星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/canxing" title="GitHub → https://github.com/canxing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">残星</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
